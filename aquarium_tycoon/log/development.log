Started GET "/" for 127.0.0.1 at 2017-11-18 16:21:54 -0500
Processing by Rails::WelcomeController#index as HTML
  Rendering /usr/local/lib/ruby/gems/2.4.0/gems/railties-5.1.4/lib/rails/templates/rails/welcome/index.html.erb
  Rendered /usr/local/lib/ruby/gems/2.4.0/gems/railties-5.1.4/lib/rails/templates/rails/welcome/index.html.erb (3.4ms)
Completed 200 OK in 237ms (Views: 8.9ms)


Started GET "/" for 127.0.0.1 at 2017-11-18 16:57:51 -0500
Processing by Rails::WelcomeController#index as HTML
  Rendering /usr/local/lib/ruby/gems/2.4.0/gems/railties-5.1.4/lib/rails/templates/rails/welcome/index.html.erb
  Rendered /usr/local/lib/ruby/gems/2.4.0/gems/railties-5.1.4/lib/rails/templates/rails/welcome/index.html.erb (3.6ms)
Completed 200 OK in 233ms (Views: 8.1ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 16:57:58 -0500
  
ActionController::RoutingError (No route matches [GET] "/animals"):
  
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:63:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/animal" for 127.0.0.1 at 2017-11-18 16:58:06 -0500
  
ActionController::RoutingError (No route matches [GET] "/animal"):
  
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:63:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/" for 127.0.0.1 at 2017-11-18 17:04:16 -0500
Processing by ApplicationController#hello as HTML
  Rendering html template
  Rendered html template (0.0ms)
Completed 200 OK in 160ms (Views: 5.2ms)


Started GET "/animal" for 127.0.0.1 at 2017-11-18 17:04:24 -0500
  
ActionController::RoutingError (No route matches [GET] "/animal"):
  
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:63:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/animals" for 127.0.0.1 at 2017-11-18 17:04:28 -0500
Processing by AnimalsController#index as HTML
Completed 500 Internal Server Error in 2ms


  
NameError (uninitialized constant AnimalsController::Animal):
  
app/controllers/animals_controller.rb:7:in `index'
Started GET "/animals/new" for 127.0.0.1 at 2017-11-18 17:05:15 -0500
Processing by AnimalsController#new as HTML
Completed 500 Internal Server Error in 1ms


  
NameError (uninitialized constant AnimalsController::Animal):
  
app/controllers/animals_controller.rb:17:in `new'
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (9.3ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (8.6ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.6ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (1)
  [1m[35m (0.7ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.9ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` LIMIT 11[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` LIMIT 11[0m
Started GET "/" for 127.0.0.1 at 2017-11-18 18:33:53 -0500
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
ActiveRecord::PendingMigrationError (

Migrations are pending. To resolve this issue, run:

        bin/rails db:migrate RAILS_ENV=development

):
  
activerecord (5.1.4) lib/active_record/migration.rb:576:in `check_pending!'
activerecord (5.1.4) lib/active_record/migration.rb:553:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:26:in `block in call'
activesupport (5.1.4) lib/active_support/callbacks.rb:97:in `run_callbacks'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:24:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:59:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/" for 127.0.0.1 at 2017-11-18 18:35:25 -0500
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
ActiveRecord::PendingMigrationError (

Migrations are pending. To resolve this issue, run:

        bin/rails db:migrate RAILS_ENV=development

):
  
activerecord (5.1.4) lib/active_record/migration.rb:576:in `check_pending!'
activerecord (5.1.4) lib/active_record/migration.rb:553:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:26:in `block in call'
activesupport (5.1.4) lib/active_support/callbacks.rb:97:in `run_callbacks'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:24:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:59:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/" for 127.0.0.1 at 2017-11-18 18:35:47 -0500
Processing by ApplicationController#hello as HTML
  Rendering html template
  Rendered html template (0.0ms)
Completed 200 OK in 157ms (Views: 4.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:35:53 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (14.7ms)
Completed 200 OK in 229ms (Views: 198.6ms | ActiveRecord: 1.6ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-11-18 18:35:58 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (1.4ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animalID` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 29ms (Views: 20.9ms | ActiveRecord: 1.4ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:36:00 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (2.8ms)
Completed 200 OK in 24ms (Views: 21.4ms | ActiveRecord: 0.3ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-11-18 18:36:14 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (0.9ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animalID` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.9ms)
Completed 200 OK in 28ms (Views: 23.4ms | ActiveRecord: 0.9ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:36:43 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (3.1ms)
Completed 200 OK in 42ms (Views: 39.1ms | ActiveRecord: 0.3ms)


Started GET "/animals/1/edit" for 127.0.0.1 at 2017-11-18 18:36:44 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animalID` = 1 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  Rendered animals/_form.html.erb (10.3ms)
  Rendered animals/edit.html.erb within layouts/application (13.4ms)
Completed 200 OK in 63ms (Views: 58.1ms | ActiveRecord: 0.3ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:36:47 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (4.1ms)
Completed 200 OK in 40ms (Views: 35.1ms | ActiveRecord: 0.3ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-11-18 18:37:00 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  Rendered animals/_form.html.erb (1.5ms)
  Rendered animals/new.html.erb within layouts/application (4.3ms)
Completed 200 OK in 49ms (Views: 45.2ms | ActiveRecord: 0.0ms)


Started POST "/animals" for 127.0.0.1 at 2017-11-18 18:37:01 -0500
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"IWHkcLp1YdJSU7rYywTq88LZ1LBNeIR7PvJXTnjiF5UdziQWHHMWHcFRx6wiWqAfadTwPDUavoAC1v92ghJiBg==", "commit"=>"Create Animal"}
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `animals` VALUES ()[0m
  [1m[35m (0.1ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 4ms (ActiveRecord: 1.1ms)


  
ActiveRecord::NotNullViolation (Mysql2::Error: Field 'name' doesn't have a default value: INSERT INTO `animals` VALUES ()):
  
app/controllers/animals_controller.rb:30:in `block in create'
app/controllers/animals_controller.rb:29:in `create'
Started GET "/" for 127.0.0.1 at 2017-11-18 18:40:33 -0500
Processing by ApplicationController#hello as HTML
  Rendering html template
  Rendered html template (0.0ms)
Completed 200 OK in 220ms (Views: 3.8ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:40:40 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (14.6ms)
Completed 200 OK in 198ms (Views: 152.8ms | ActiveRecord: 1.4ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-11-18 18:40:44 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (0.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animalID` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.9ms)
Completed 200 OK in 24ms (Views: 18.2ms | ActiveRecord: 0.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:40:45 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (2.6ms)
Completed 200 OK in 50ms (Views: 47.3ms | ActiveRecord: 0.4ms)


Started GET "/animals/2" for 127.0.0.1 at 2017-11-18 18:40:46 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"2"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animalID` = 2 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 23ms (Views: 19.5ms | ActiveRecord: 0.3ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:40:47 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (2.8ms)
Completed 200 OK in 22ms (Views: 19.7ms | ActiveRecord: 0.3ms)


Started GET "/animal" for 127.0.0.1 at 2017-11-18 18:40:50 -0500
  
ActionController::RoutingError (No route matches [GET] "/animal"):
  
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:63:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:40:52 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.2ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (2.9ms)
Completed 200 OK in 26ms (Views: 23.7ms | ActiveRecord: 0.2ms)


Started GET "/animals/1/edit" for 127.0.0.1 at 2017-11-18 18:40:56 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animalID` = 1 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  Rendered animals/_form.html.erb (12.8ms)
  Rendered animals/edit.html.erb within layouts/application (16.1ms)
Completed 200 OK in 60ms (Views: 55.0ms | ActiveRecord: 0.4ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:40:57 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (1.7ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (7.2ms)
Completed 200 OK in 138ms (Views: 133.2ms | ActiveRecord: 1.7ms)


Started GET "/animals/2" for 127.0.0.1 at 2017-11-18 18:40:58 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"2"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animalID` = 2 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.7ms)
Completed 200 OK in 20ms (Views: 16.3ms | ActiveRecord: 0.3ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:41:00 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (2.6ms)
Completed 200 OK in 21ms (Views: 18.7ms | ActiveRecord: 0.3ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-11-18 18:41:20 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  Rendered animals/_form.html.erb (1.7ms)
  Rendered animals/new.html.erb within layouts/application (4.8ms)
Completed 200 OK in 130ms (Views: 127.2ms | ActiveRecord: 0.0ms)


Started POST "/animals" for 127.0.0.1 at 2017-11-18 18:41:22 -0500
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"hxvZ9RggrfGvZ+FHRYt+MBGcDR6RGZEgK6iKHWJeEXq7tBmTvibaPjxlnDOs1TTcupEpkul7q9sXjCIlmK5k6Q==", "commit"=>"Create Animal"}
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `animals` VALUES ()[0m
  [1m[35m (0.1ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 3ms (ActiveRecord: 0.7ms)


  
ActiveRecord::NotNullViolation (Mysql2::Error: Field 'name' doesn't have a default value: INSERT INTO `animals` VALUES ()):
  
app/controllers/animals_controller.rb:30:in `block in create'
app/controllers/animals_controller.rb:29:in `create'
Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:43:18 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (18.5ms)
Completed 200 OK in 439ms (Views: 207.5ms | ActiveRecord: 1.9ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:43:59 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (3.3ms)
Completed 200 OK in 16ms (Views: 14.0ms | ActiveRecord: 0.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:44:11 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (12.2ms)
Completed 200 OK in 368ms (Views: 173.0ms | ActiveRecord: 1.5ms)


Started GET "/" for 127.0.0.1 at 2017-11-18 18:44:18 -0500
Processing by ApplicationController#hello as HTML
  Rendering html template
  Rendered html template (0.0ms)
Completed 200 OK in 2ms (Views: 1.3ms | ActiveRecord: 0.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:45:32 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (3.3ms)
Completed 200 OK in 15ms (Views: 12.9ms | ActiveRecord: 0.6ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-11-18 18:45:39 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  Rendered animals/_form.html.erb (6.2ms)
  Rendered animals/new.html.erb within layouts/application (8.7ms)
Completed 200 OK in 32ms (Views: 29.1ms | ActiveRecord: 0.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:45:41 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (2.4ms)
Completed 200 OK in 20ms (Views: 17.6ms | ActiveRecord: 0.3ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-11-18 18:45:46 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (0.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animalID` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.7ms)
Completed 200 OK in 24ms (Views: 17.4ms | ActiveRecord: 0.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-18 18:45:47 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (3.0ms)
Completed 200 OK in 21ms (Views: 19.0ms | ActiveRecord: 0.4ms)


  [1m[35m (18.7ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (3.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (109.3ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.1ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (19.7ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (9.7ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.6ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (1.2ms)[0m  [1m[35m      CREATE TABLE habitats (
        habitat_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        year_added int(11) NOT NULL,
        PRIMARY KEY (habitat_id)
      );


      CREATE TABLE tanks (
        tank_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        water_type enum('fresh','salt') NOT NULL,
        volume double NOT NULL,
        temperature double NOT NULL,
        year_built int(11) NOT NULL,
        habitat_id int(11) NOT NULL,
        PRIMARY KEY (tank_id),
        CONSTRAINT FK_habitat_tank FOREIGN KEY (habitat_id) REFERENCES habitats (habitat_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE animals (
        animal_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) DEFAULT NULL,
        species varchar(45) NOT NULL,
        tank int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT FK_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );


      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT FK_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT FK_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT FK_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT FK_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT FK_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );


      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );


      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registrationCode),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT FK_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT FK_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.8ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (2.7ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (0.4ms)[0m  [1m[35m      CREATE TABLE habitats (
        habitat_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        year_added int(11) NOT NULL,
        PRIMARY KEY (habitat_id)
      );

      CREATE TABLE tanks (
        tank_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        water_type enum('fresh','salt') NOT NULL,
        volume double NOT NULL,
        temperature double NOT NULL,
        year_built int(11) NOT NULL,
        habitat_id int(11) NOT NULL,
        PRIMARY KEY (tank_id),
        CONSTRAINT FK_habitat_tank FOREIGN KEY (habitat_id) REFERENCES habitats (habitat_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE animals (
        animal_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) DEFAULT NULL,
        species varchar(45) NOT NULL,
        tank int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT FK_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );


      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT FK_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT FK_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT FK_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT FK_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT FK_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );


      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );


      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT FK_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT FK_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (0.6ms)[0m  [1m[35m      CREATE TABLE habitats (
        habitat_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        year_added int(11) NOT NULL,
        PRIMARY KEY (habitat_id)
      );

      CREATE TABLE tanks (
        tank_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        water_type enum('fresh','salt') NOT NULL,
        volume double NOT NULL,
        temperature double NOT NULL,
        year_built int(11) NOT NULL,
        habitat_id int(11) NOT NULL,
        PRIMARY KEY (tank_id),
        CONSTRAINT FK_habitat_tank FOREIGN KEY (habitat_id) REFERENCES habitats (habitat_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE animals (
        animal_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) DEFAULT NULL,
        species varchar(45) NOT NULL,
        tank int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT FK_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );


      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT FK_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT FK_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT FK_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT FK_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT FK_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );


      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );


      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT FK_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT FK_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (0.4ms)[0m  [1m[35m      CREATE TABLE habitats (
        habitat_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        year_added int(11) NOT NULL,
        PRIMARY KEY (habitat_id)
      );

      CREATE TABLE tanks (
        tank_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        water_type enum('fresh','salt') NOT NULL,
        volume double NOT NULL,
        temperature double NOT NULL,
        year_built int(11) NOT NULL,
        habitat_id int(11) NOT NULL,
        PRIMARY KEY (tank_id),
        CONSTRAINT fk_habitat_tank FOREIGN KEY (habitat_id) REFERENCES habitats (habitat_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE animals (
        animal_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) DEFAULT NULL,
        species varchar(45) NOT NULL,
        tank int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );


      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );


      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );


      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (0.4ms)[0m  [1m[35m      CREATE TABLE habitats (
        habitat_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        year_added int(11) NOT NULL,
        PRIMARY KEY (habitat_id)
      );

      CREATE TABLE tanks (
        tank_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        water_type enum('fresh','salt') NOT NULL,
        volume double NOT NULL,
        temperature double NOT NULL,
        year_built int(11) NOT NULL,
        habitat_id int(11) NOT NULL,
        PRIMARY KEY (tank_id),
        CONSTRAINT fk_habitat_tank FOREIGN KEY (habitat_id) REFERENCES habitats (habitat_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE animals (
        animal_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) DEFAULT NULL,
        species varchar(45) NOT NULL,
        tank int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );


      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );


      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );


      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (0.8ms)[0m  [1m[35m      CREATE TABLE habitats (
        habitat_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        year_added int(11) NOT NULL,
        PRIMARY KEY (habitat_id)
      )

      CREATE TABLE tanks (
        tank_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) NOT NULL,
        description varchar(200) DEFAULT NULL,
        water_type enum('fresh','salt') NOT NULL,
        volume double NOT NULL,
        temperature double NOT NULL,
        year_built int(11) NOT NULL,
        habitat_id int(11) NOT NULL,
        PRIMARY KEY (tank_id),
        CONSTRAINT fk_habitat_tank FOREIGN KEY (habitat_id) REFERENCES habitats (habitat_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE animals (
        animal_id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(45) DEFAULT NULL,
        species varchar(45) NOT NULL,
        tank int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );


      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );


      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );


      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );


      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );


      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (14.4ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );

      -- CREATE TABLE `tanks` (
      --   `tank_id` int(11) NOT NULL AUTO_INCREMENT,
      --   `name` varchar(45) NOT NULL,
      --   `description` varchar(200) DEFAULT NULL,
      --   `water_type` enum('fresh','salt') NOT NULL,
      --   `volume` double NOT NULL,
      --   `temperature` double NOT NULL,
      --   `year_built` int(11) NOT NULL,
      --   `habitat_id` int(11) NOT NULL,
      --   PRIMARY KEY (`tank_id`),
      --   CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE `animals` (
      --   `animal_id` int(11) NOT NULL AUTO_INCREMENT,
      --   `name` varchar(45) DEFAULT NULL,
      --   `species` varchar(45) NOT NULL,
      --   `tank` int(11) NOT NULL,
      --   birth_date datetime DEFAULT NULL,
      --   PRIMARY KEY (animal_id),
      --   CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
      --   ON DELETE CASCADE ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE employees (
      --   employee_id int(11) NOT NULL AUTO_INCREMENT,
      --   first_name varchar(45) NOT NULL,
      --   last_name varchar(45) NOT NULL,
      --   hired_date varchar(45) NOT NULL,
      --   salary double NOT NULL,
      --   PRIMARY KEY (employee_id)
      -- );
      --
      --
      -- CREATE TABLE feeding_logs (
      --   feeding_id int(11) NOT NULL AUTO_INCREMENT,
      --   time datetime NOT NULL,
      --   food varchar(45) NOT NULL,
      --   quantity float NOT NULL,
      --   employee int(11) DEFAULT NULL,
      --   tank int(11) DEFAULT NULL,
      --   PRIMARY KEY (feeding_id),
      --   CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE,
      --   CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE treatment_logs (
      --   treatment_id int(11) NOT NULL AUTO_INCREMENT,
      --   time datetime NOT NULL,
      --   medicine varchar(45) NOT NULL,
      --   quantity float NOT NULL,
      --   employee int(11) DEFAULT NULL,
      --   animal int(11) DEFAULT NULL,
      --   PRIMARY KEY (treatment_id),
      --   CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE,
      --   CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE events (
      --   event_id int(11) NOT NULL AUTO_INCREMENT,
      --   title varchar(45) NOT NULL,
      --   description varchar(200),
      --   price float NOT NULL,
      --   managing_employee int(11) NOT NULL,
      --   max_guests_per_person int(11) DEFAULT NULL,
      --   max_attending int(11) NOT NULL,
      --   event_date datetime NOT NULL,
      --   PRIMARY KEY (event_id),
      --   KEY manager (managing_employee),
      --   CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE members (
      --   member_id int(11) NOT NULL AUTO_INCREMENT,
      --   first_name varchar(45) NOT NULL,
      --   last_name varchar(45) NOT NULL,
      --   date_joined date NOT NULL,
      --   expiration_date date NOT NULL,
      --   fee double NOT NULL,
      --   PRIMARY KEY (member_id)
      -- );
      --
      --
      -- CREATE TABLE event_registrations (
      --   registration_code int(11) NOT NULL AUTO_INCREMENT,
      --   time datetime NOT NULL,
      --   member int(11) NOT NULL,
      --   event int(11) NOT NULL,
      --   guest_count int(11) DEFAULT NULL,
      --   PRIMARY KEY (registration_code),
      --   KEY eventRegistered (event),
      --   KEY memberRegistering (member),
      --   CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
      --   ON DELETE CASCADE ON UPDATE CASCADE,
      --   CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
      --   ON DELETE CASCADE ON UPDATE CASCADE
      -- );
[0m
  [1m[35m (1.8ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.4ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-11-23 02:29:27', '2017-11-23 02:29:27')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (7.3ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (10.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (9.5ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (7.5ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );

      -- CREATE TABLE `tanks` (
      --   `tank_id` int(11) NOT NULL AUTO_INCREMENT,
      --   `name` varchar(45) NOT NULL,
      --   `description` varchar(200) DEFAULT NULL,
      --   `water_type` enum('fresh','salt') NOT NULL,
      --   `volume` double NOT NULL,
      --   `temperature` double NOT NULL,
      --   `year_built` int(11) NOT NULL,
      --   `habitat_id` int(11) NOT NULL,
      --   PRIMARY KEY (`tank_id`),
      --   CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE `animals` (
      --   `animal_id` int(11) NOT NULL AUTO_INCREMENT,
      --   `name` varchar(45) DEFAULT NULL,
      --   `species` varchar(45) NOT NULL,
      --   `tank` int(11) NOT NULL,
      --   birth_date datetime DEFAULT NULL,
      --   PRIMARY KEY (animal_id),
      --   CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
      --   ON DELETE CASCADE ON UPDATE CASCADE
      -- );
      --
      --
      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
      --
      --
      -- CREATE TABLE feeding_logs (
      --   feeding_id int(11) NOT NULL AUTO_INCREMENT,
      --   time datetime NOT NULL,
      --   food varchar(45) NOT NULL,
      --   quantity float NOT NULL,
      --   employee int(11) DEFAULT NULL,
      --   tank int(11) DEFAULT NULL,
      --   PRIMARY KEY (feeding_id),
      --   CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE,
      --   CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE treatment_logs (
      --   treatment_id int(11) NOT NULL AUTO_INCREMENT,
      --   time datetime NOT NULL,
      --   medicine varchar(45) NOT NULL,
      --   quantity float NOT NULL,
      --   employee int(11) DEFAULT NULL,
      --   animal int(11) DEFAULT NULL,
      --   PRIMARY KEY (treatment_id),
      --   CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE,
      --   CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE events (
      --   event_id int(11) NOT NULL AUTO_INCREMENT,
      --   title varchar(45) NOT NULL,
      --   description varchar(200),
      --   price float NOT NULL,
      --   managing_employee int(11) NOT NULL,
      --   max_guests_per_person int(11) DEFAULT NULL,
      --   max_attending int(11) NOT NULL,
      --   event_date datetime NOT NULL,
      --   PRIMARY KEY (event_id),
      --   KEY manager (managing_employee),
      --   CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE members (
      --   member_id int(11) NOT NULL AUTO_INCREMENT,
      --   first_name varchar(45) NOT NULL,
      --   last_name varchar(45) NOT NULL,
      --   date_joined date NOT NULL,
      --   expiration_date date NOT NULL,
      --   fee double NOT NULL,
      --   PRIMARY KEY (member_id)
      -- );
      --
      --
      -- CREATE TABLE event_registrations (
      --   registration_code int(11) NOT NULL AUTO_INCREMENT,
      --   time datetime NOT NULL,
      --   member int(11) NOT NULL,
      --   event int(11) NOT NULL,
      --   guest_count int(11) DEFAULT NULL,
      --   PRIMARY KEY (registration_code),
      --   KEY eventRegistered (event),
      --   KEY memberRegistering (member),
      --   CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
      --   ON DELETE CASCADE ON UPDATE CASCADE,
      --   CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
      --   ON DELETE CASCADE ON UPDATE CASCADE
      -- );
[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (9.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (9.3ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (7.5ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (2.1ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (7.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (8.9ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );

      --
      --
      -- CREATE TABLE `animals` (
      --   `animal_id` int(11) NOT NULL AUTO_INCREMENT,
      --   `name` varchar(45) DEFAULT NULL,
      --   `species` varchar(45) NOT NULL,
      --   `tank` int(11) NOT NULL,
      --   birth_date datetime DEFAULT NULL,
      --   PRIMARY KEY (animal_id),
      --   CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
      --   ON DELETE CASCADE ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE employees (
      --   employee_id int(11) NOT NULL AUTO_INCREMENT,
      --   first_name varchar(45) NOT NULL,
      --   last_name varchar(45) NOT NULL,
      --   hired_date varchar(45) NOT NULL,
      --   salary double NOT NULL,
      --   PRIMARY KEY (employee_id)
      -- );
      --
      --
      -- CREATE TABLE feeding_logs (
      --   feeding_id int(11) NOT NULL AUTO_INCREMENT,
      --   time datetime NOT NULL,
      --   food varchar(45) NOT NULL,
      --   quantity float NOT NULL,
      --   employee int(11) DEFAULT NULL,
      --   tank int(11) DEFAULT NULL,
      --   PRIMARY KEY (feeding_id),
      --   CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE,
      --   CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE treatment_logs (
      --   treatment_id int(11) NOT NULL AUTO_INCREMENT,
      --   time datetime NOT NULL,
      --   medicine varchar(45) NOT NULL,
      --   quantity float NOT NULL,
      --   employee int(11) DEFAULT NULL,
      --   animal int(11) DEFAULT NULL,
      --   PRIMARY KEY (treatment_id),
      --   CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE,
      --   CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
      --   ON DELETE SET NULL ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE events (
      --   event_id int(11) NOT NULL AUTO_INCREMENT,
      --   title varchar(45) NOT NULL,
      --   description varchar(200),
      --   price float NOT NULL,
      --   managing_employee int(11) NOT NULL,
      --   max_guests_per_person int(11) DEFAULT NULL,
      --   max_attending int(11) NOT NULL,
      --   event_date datetime NOT NULL,
      --   PRIMARY KEY (event_id),
      --   KEY manager (managing_employee),
      --   CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      -- );
      --
      --
      -- CREATE TABLE members (
      --   member_id int(11) NOT NULL AUTO_INCREMENT,
      --   first_name varchar(45) NOT NULL,
      --   last_name varchar(45) NOT NULL,
      --   date_joined date NOT NULL,
      --   expiration_date date NOT NULL,
      --   fee double NOT NULL,
      --   PRIMARY KEY (member_id)
      -- );
      --
      --
      -- CREATE TABLE event_registrations (
      --   registration_code int(11) NOT NULL AUTO_INCREMENT,
      --   time datetime NOT NULL,
      --   member int(11) NOT NULL,
      --   event int(11) NOT NULL,
      --   guest_count int(11) DEFAULT NULL,
      --   PRIMARY KEY (registration_code),
      --   KEY eventRegistered (event),
      --   KEY memberRegistering (member),
      --   CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
      --   ON DELETE CASCADE ON UPDATE CASCADE,
      --   CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
      --   ON DELETE CASCADE ON UPDATE CASCADE
      -- );
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-11-23 02:33:38', '2017-11-23 02:33:38')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (0.4ms)[0m  [1m[35m      DROP TABLE event_registrations;
[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (21.4ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (12.5ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (12.5ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (9.4ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (8.3ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (9.5ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (10.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (13.2ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (6.9ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.8ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.0ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (11.9ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-11-23 02:38:53', '2017-11-23 02:38:53')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (2.2ms)[0m  [1m[35m      DROP TABLE event_registrations;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      DROP TABLE members;
[0m
  [1m[35m (1.4ms)[0m  [1m[35m      DROP TABLE events;
[0m
  [1m[35m (1.8ms)[0m  [1m[35m      DROP TABLE treatment_logs;
[0m
  [1m[35m (1.6ms)[0m  [1m[35m      DROP TABLE feeding_logs;
[0m
  [1m[35m (1.4ms)[0m  [1m[35m      DROP TABLE employees;
[0m
  [1m[35m (1.3ms)[0m  [1m[35m      DROP TABLE animals;
[0m
  [1m[35m (1.7ms)[0m  [1m[35m      DROP TABLE tanks;
[0m
  [1m[35m (2.3ms)[0m  [1m[35m      DROP TABLE habitats;
[0m
  [1m[35mSQL (6.1ms)[0m  [1m[31mDELETE FROM `schema_migrations` WHERE `schema_migrations`.`version` = '20171123010118'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.9ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.9ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (10.0ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (7.7ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (21.4ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (11.2ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (11.2ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (10.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (10.0ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (11.7ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (17.4ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (12.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (11.2ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-11-23 02:44:00', '2017-11-23 02:44:00')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.8ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (2.6ms)[0m  [1m[35m      DROP TABLE event_registrations;
[0m
  [1m[35m (1.9ms)[0m  [1m[35m      DROP TABLE members;
[0m
  [1m[35m (1.9ms)[0m  [1m[35m      DROP TABLE events;
[0m
  [1m[35m (2.9ms)[0m  [1m[35m      DROP TABLE treatment_logs;
[0m
  [1m[35m (2.6ms)[0m  [1m[35m      DROP TABLE feeding_logs;
[0m
  [1m[35m (2.1ms)[0m  [1m[35m      DROP TABLE employees;
[0m
  [1m[35m (7.6ms)[0m  [1m[35m      DROP TABLE animals;
[0m
  [1m[35m (7.3ms)[0m  [1m[35m      DROP TABLE tanks;
[0m
  [1m[35m (9.3ms)[0m  [1m[35m      DROP TABLE habitats;
[0m
  [1m[35mSQL (1.4ms)[0m  [1m[31mDELETE FROM `schema_migrations` WHERE `schema_migrations`.`version` = '20171123010118'[0m
  [1m[35m (1.6ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (3.7ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.6ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (10.5ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (7.3ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (6.3ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (7.3ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.2ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.4ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (9.0ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (9.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.7ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (10.7ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-11-23 02:44:41', '2017-11-23 02:44:41')[0m
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.7ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (33.3ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.7ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (9.4ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (8.4ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (7.4ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (10.5ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.3ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (10.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (9.9ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.4ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.1ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (10.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-11-23 03:20:30', '2017-11-23 03:20:30')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/animals" for 127.0.0.1 at 2017-11-22 23:07:32 -0500
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (20.1ms)
Completed 500 Internal Server Error in 40ms (ActiveRecord: 1.8ms)


  
ActionView::Template::Error (undefined method `animalID' for #<Animal:0x007fa701c198a0>
Did you mean?  animal_id
               animal_id=
               animal_id?):
    12:   <tbody>
    13:     <% @animals.each do |animal| %>
    14:       <tr>
    15:         <td><%= animal.animalID %><td>
    16:         <td><%= animal.name %><td>
    17:         <td><%= animal.species %><td>
    18:         <td><%= link_to 'Show', animal %></td>
  
app/views/animals/index.html.erb:15:in `block in _app_views_animals_index_html_erb__4316480841099830243_70177682577960'
app/views/animals/index.html.erb:13:in `_app_views_animals_index_html_erb__4316480841099830243_70177682577960'
Started GET "/animals" for 127.0.0.1 at 2017-11-22 23:08:08 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (1.6ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (37.3ms)
Completed 200 OK in 239ms (Views: 234.5ms | ActiveRecord: 1.9ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-22 23:09:13 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (33.5ms)
Completed 200 OK in 53ms (Views: 50.7ms | ActiveRecord: 0.3ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-22 23:09:15 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.6ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (51.0ms)
Completed 200 OK in 80ms (Views: 76.7ms | ActiveRecord: 0.6ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-22 23:09:17 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (35.2ms)
Completed 200 OK in 50ms (Views: 48.1ms | ActiveRecord: 0.3ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-22 23:09:18 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (25.6ms)
Completed 200 OK in 39ms (Views: 37.4ms | ActiveRecord: 0.3ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-11-22 23:09:30 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (1.1ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.9ms)
Completed 200 OK in 41ms (Views: 32.5ms | ActiveRecord: 1.1ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-22 23:09:31 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (40.1ms)
Completed 200 OK in 78ms (Views: 76.3ms | ActiveRecord: 0.4ms)


  [1m[35m (18.8ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.3ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (46.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (11.4ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (10.5ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (9.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (9.4ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.0ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.3ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (7.7ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (9.3ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (9.4ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (9.1ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (9.5ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.8ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.8ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-11-23 21:51:29', '2017-11-23 21:51:29')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/animals" for 127.0.0.1 at 2017-11-23 16:57:51 -0500
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (42.7ms)
Completed 200 OK in 332ms (Views: 317.3ms | ActiveRecord: 2.1ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-11-23 16:59:09 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (1.1ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 28ms (Views: 20.1ms | ActiveRecord: 1.3ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-23 16:59:10 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (34.3ms)
Completed 200 OK in 68ms (Views: 65.8ms | ActiveRecord: 0.5ms)


  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` LIMIT 11[0m
Started GET "/animals" for 127.0.0.1 at 2017-11-23 17:17:40 -0500
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.8ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (5.2ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (77.5ms)
Completed 200 OK in 853ms (Views: 825.6ms | ActiveRecord: 9.5ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-11-23 17:18:00 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (0.7ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (1.4ms)
Completed 200 OK in 56ms (Views: 47.9ms | ActiveRecord: 1.0ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-11-23 17:18:16 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.7ms)
Completed 200 OK in 17ms (Views: 14.5ms | ActiveRecord: 0.3ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-23 17:18:18 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (49.3ms)
Completed 200 OK in 67ms (Views: 64.8ms | ActiveRecord: 0.4ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-11-23 17:18:25 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (1.1ms)
Completed 200 OK in 25ms (Views: 21.2ms | ActiveRecord: 0.3ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-11-23 17:20:24 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (1.1ms)
Completed 200 OK in 23ms (Views: 18.6ms | ActiveRecord: 0.3ms)


Started GET "/animals/1/edit" for 127.0.0.1 at 2017-11-23 17:20:29 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (2.4ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  Rendered animals/_form.html.erb (46.4ms)
  Rendered animals/edit.html.erb within layouts/application (50.3ms)
Completed 200 OK in 89ms (Views: 81.8ms | ActiveRecord: 2.4ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-23 17:21:00 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (57.3ms)
Completed 200 OK in 79ms (Views: 76.8ms | ActiveRecord: 0.4ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-11-23 17:21:21 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  Rendered animals/_form.html.erb (6.9ms)
  Rendered animals/new.html.erb within layouts/application (10.0ms)
Completed 200 OK in 61ms (Views: 57.3ms | ActiveRecord: 0.0ms)


Started POST "/animals" for 127.0.0.1 at 2017-11-23 17:23:36 -0500
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"uCBRwc5fiilwRxRTW+HHUCv8EiXEi9LeH3IJj8FRv4SEj5GnaFn95uNFaSeyv428gPE2qbzp6CUjVqG3O6HKFw==", "animal"=>{"animal_id"=>"200", "name"=>"Bruce", "species"=>"Great White Shark", "tank"=>"1", "birth_date(1i)"=>"2017", "birth_date(2i)"=>"11", "birth_date(3i)"=>"23", "birth_date(4i)"=>"22", "birth_date(5i)"=>"21"}, "commit"=>"Create Animal"}
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `animals` (`animal_id`, `name`, `species`, `tank`, `birth_date`) VALUES (200, 'Bruce', 'Great White Shark', 1, '2017-11-23 22:21:00')[0m
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals/200
Completed 302 Found in 5ms (ActiveRecord: 1.2ms)


Started GET "/animals/200" for 127.0.0.1 at 2017-11-23 17:23:36 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"200"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 200 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 20ms (Views: 17.5ms | ActiveRecord: 0.3ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-23 17:23:39 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (58.6ms)
Completed 200 OK in 84ms (Views: 80.3ms | ActiveRecord: 0.4ms)


Started DELETE "/animals/200" for 127.0.0.1 at 2017-11-23 17:23:48 -0500
Processing by AnimalsController#destroy as HTML
  Parameters: {"authenticity_token"=>"Ahdkm2XBgX+Fxq/PlJ1ycgSFaz8ZOSZkro6eo6R2vr/sM27Av+JXSPxzwOz8y36Pwi9XkusyRv2lp6WkjeJi1g==", "id"=>"200"}
  [1m[36mAnimal Load (0.6ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 200 LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.1ms)[0m  [1m[31mDELETE FROM `animals` WHERE `animals`.`animal_id` = 200[0m
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals
Completed 302 Found in 12ms (ActiveRecord: 8.4ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-23 17:23:48 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.7ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (60.2ms)
Completed 200 OK in 102ms (Views: 98.2ms | ActiveRecord: 0.7ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-23 17:33:35 -0500
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.6ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (48.4ms)
Completed 200 OK in 760ms (Views: 746.8ms | ActiveRecord: 1.9ms)


Started GET "/animals/9" for 127.0.0.1 at 2017-11-23 17:33:40 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"9"}
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 9 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (1.2ms)
Completed 200 OK in 32ms (Views: 23.7ms | ActiveRecord: 0.7ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-23 17:33:41 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (59.9ms)
Completed 200 OK in 86ms (Views: 83.2ms | ActiveRecord: 0.4ms)


Started GET "/animals/5/edit" for 127.0.0.1 at 2017-11-23 17:33:43 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"5"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 5 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  Rendered animals/_form.html.erb (30.9ms)
  Rendered animals/edit.html.erb within layouts/application (33.6ms)
Completed 200 OK in 51ms (Views: 46.9ms | ActiveRecord: 0.3ms)


Started PATCH "/animals/5" for 127.0.0.1 at 2017-11-23 17:33:51 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"2BSkodxZsD1Y1ek/3VXNaq+Q2yIxcnKh69BrFUgTdCYBj9LsOgUwffhA1VrhOo2BvYSJGSuhoaqH8iEiRnAttA==", "animal"=>{"animal_id"=>"5", "name"=>"", "species"=>"Guppy", "tank"=>"1", "birth_date(1i)"=>"2010", "birth_date(2i)"=>"6", "birth_date(3i)"=>"6", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"5"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 5 LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.7ms)[0m  [1m[33mUPDATE `animals` SET `name` = '', `species` = 'Guppy' WHERE `animals`.`animal_id` = 5[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals/5
Completed 302 Found in 8ms (ActiveRecord: 2.7ms)


Started GET "/animals/5" for 127.0.0.1 at 2017-11-23 17:33:51 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"5"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 5 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (1.0ms)
Completed 200 OK in 17ms (Views: 14.6ms | ActiveRecord: 0.3ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-23 17:33:54 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (71.0ms)
Completed 200 OK in 87ms (Views: 84.6ms | ActiveRecord: 0.4ms)


  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.7ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (62.3ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (72.4ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (59.8ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (52.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (58.3ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (48.5ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (75.7ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (63.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (84.4ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (69.0ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (75.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-11-24 18:26:11', '2017-11-24 18:26:11')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/" for 127.0.0.1 at 2017-11-25 00:06:50 -0500
  [1m[35m (0.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by ApplicationController#hello as HTML
  Rendering html template
  Rendered html template (0.0ms)
Completed 200 OK in 88ms (Views: 38.9ms | ActiveRecord: 0.0ms)


Started GET "/employees" for 127.0.0.1 at 2017-11-25 00:07:01 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEmployee Load (7.5ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (195.1ms)
Completed 200 OK in 5684ms (Views: 5370.6ms | ActiveRecord: 17.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-25 00:07:57 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (8.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (356.8ms)
Completed 200 OK in 1315ms (Views: 1077.5ms | ActiveRecord: 14.0ms)


Started GET "/animals/147" for 127.0.0.1 at 2017-11-25 00:08:07 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"147"}
  [1m[36mAnimal Load (2.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 147 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (6.0ms)
Completed 200 OK in 1228ms (Views: 940.2ms | ActiveRecord: 2.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-11-25 00:08:11 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (185.7ms)
Completed 200 OK in 1072ms (Views: 914.6ms | ActiveRecord: 0.0ms)


Started GET "/employees" for 127.0.0.1 at 2017-11-25 00:08:18 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (4.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (16.0ms)
Completed 200 OK in 960ms (Views: 779.1ms | ActiveRecord: 4.0ms)


Started GET "/feedinglogs" for 127.0.0.1 at 2017-11-25 00:08:31 -0500
  
ActionController::RoutingError (No route matches [GET] "/feedinglogs"):
  
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:63:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/feedinglog" for 127.0.0.1 at 2017-11-25 00:08:42 -0500
  
ActionController::RoutingError (No route matches [GET] "/feedinglog"):
  
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:63:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/tanks" for 127.0.0.1 at 2017-11-25 00:08:50 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (4.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (60.0ms)
Completed 200 OK in 772ms (Views: 673.1ms | ActiveRecord: 8.0ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-11-25 00:10:41 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  Rendered tanks/_form.html.erb (65.9ms)
  Rendered tanks/new.html.erb within layouts/application (224.0ms)
Completed 200 OK in 1153ms (Views: 1018.9ms | ActiveRecord: 0.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-11-25 00:10:50 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"/Ht+lLw5iju7o5Gi8Hix3GNEt3YKu2kIpANM5q4VmKc09XTktdt366NjWfe14HXgi8helBhjX2IYpEzfMZubqQ==", "tank"=>{"tank_id"=>"1", "name"=>"", "description"=>"", "water_type"=>"", "volume"=>"", "temperature"=>"", "year_built"=>"", "habitat_id"=>""}, "commit"=>"Create Tank"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  Rendered tanks/_form.html.erb (32.0ms)
  Rendered tanks/new.html.erb within layouts/application (239.2ms)
Completed 200 OK in 1356ms (Views: 1272.1ms | ActiveRecord: 2.5ms)


Started POST "/tanks" for 127.0.0.1 at 2017-11-25 00:11:31 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"jDKGit4m7ThLc9eo39ty+nnGRCbLe2d7HgAI7ETRQJ6HyGPvyF1RuRR2TRMm3OHazs/9otHPovl6RHIKMgx78Q==", "tank"=>{"tank_id"=>"1", "name"=>"test1", "description"=>"test", "water_type"=>"asdf", "volume"=>"2000", "temperature"=>"40", "year_built"=>"1999", "habitat_id"=>"6"}, "commit"=>"Create Tank"}
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 6 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  Rendered tanks/_form.html.erb (16.0ms)
  Rendered tanks/new.html.erb within layouts/application (148.0ms)
Completed 200 OK in 978ms (Views: 908.6ms | ActiveRecord: 13.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-11-25 00:11:43 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"y5C64NlCopqwrssXFa61eJRXjMRWgPmfVo4zO9Rsv7LAal+FzzkeG++rUazsqSZYI141QEw0PB0yykndorGE3Q==", "tank"=>{"tank_id"=>"1", "name"=>"test1", "description"=>"test", "water_type"=>"asdf", "volume"=>"2000", "temperature"=>"40", "year_built"=>"1999", "habitat_id"=>"2"}, "commit"=>"Create Tank"}
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (8.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 2 LIMIT 1[0m
  [1m[35mSQL (6.5ms)[0m  [1m[32mINSERT INTO `tanks` (`tank_id`, `name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES (1, 'test1', 'test', 'asdf', 2000.0, 40.0, 1999, 2)[0m
  [1m[35m (4.0ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 60ms (ActiveRecord: 18.5ms)


  
ActiveRecord::StatementInvalid (Mysql2::Error: Data truncated for column 'water_type' at row 1: INSERT INTO `tanks` (`tank_id`, `name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES (1, 'test1', 'test', 'asdf', 2000.0, 40.0, 1999, 2)):
  
app/controllers/tanks_controller.rb:30:in `block in create'
app/controllers/tanks_controller.rb:29:in `create'
Started GET "/tanks" for 127.0.0.1 at 2017-11-25 00:11:57 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (2837.6ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (3082.4ms)
Completed 200 OK in 17640ms (Views: 11941.9ms | ActiveRecord: 2837.6ms)


Started GET "/tanks" for 127.0.0.1 at 2017-11-25 00:12:42 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (16.0ms)
Completed 200 OK in 772ms (Views: 563.8ms | ActiveRecord: 0.0ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-11-25 00:12:45 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  Rendered tanks/_form.html.erb (11.0ms)
  Rendered tanks/new.html.erb within layouts/application (156.6ms)
Completed 200 OK in 914ms (Views: 773.9ms | ActiveRecord: 0.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-11-25 00:13:04 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"A4/oGUYWK8x/tJ02ZmEvv8LF5rFZLtNCSd/ELmpdt33LAeJpT/TWHGd0VWMj+euDKkkPU0v25Sj1eMQX9dO0cw==", "tank"=>{"tank_id"=>"14", "name"=>"test1", "description"=>"test", "water_type"=>"salt", "volume"=>"40", "temperature"=>"400", "year_built"=>"1999", "habitat_id"=>"2"}, "commit"=>"Create Tank"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (1.5ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 2 LIMIT 1[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `tanks` (`tank_id`, `name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES (14, 'test1', 'test', 'salt', 40.0, 400.0, 1999, 2)[0m
  [1m[35m (0.0ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 33ms (ActiveRecord: 6.0ms)


  
ActiveRecord::RecordNotUnique (Mysql2::Error: Duplicate entry '14' for key 'PRIMARY': INSERT INTO `tanks` (`tank_id`, `name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES (14, 'test1', 'test', 'salt', 40.0, 400.0, 1999, 2)):
  
app/controllers/tanks_controller.rb:30:in `block in create'
app/controllers/tanks_controller.rb:29:in `create'
Started POST "/tanks" for 127.0.0.1 at 2017-11-25 00:14:19 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"uG3zM7YfDB0VRhLkqLY41CgAyNjhnk6tF/a3nktUho6zlxZWoGSwnEpDiF9Rsav0nwlxXPsqiy9zss14PYm94Q==", "tank"=>{"tank_id"=>"18", "name"=>"test1", "description"=>"test", "water_type"=>"salt", "volume"=>"40", "temperature"=>"400", "year_built"=>"1999", "habitat_id"=>"2"}, "commit"=>"Create Tank"}
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (4.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 2 LIMIT 1[0m
  [1m[35mSQL (2.5ms)[0m  [1m[32mINSERT INTO `tanks` (`tank_id`, `name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES (18, 'test1', 'test', 'salt', 40.0, 400.0, 1999, 2)[0m
  [1m[35m (17.1ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/18
Completed 302 Found in 52ms (ActiveRecord: 23.6ms)


Started GET "/tanks/18" for 127.0.0.1 at 2017-11-25 00:14:19 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"18"}
  [1m[36mTank Load (4.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 18 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (3.5ms)
Completed 200 OK in 1465ms (Views: 1231.6ms | ActiveRecord: 4.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-11-25 00:14:25 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (2.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (44.0ms)
Completed 200 OK in 1387ms (Views: 1236.5ms | ActiveRecord: 2.5ms)


Started DELETE "/tanks/18" for 127.0.0.1 at 2017-11-25 00:20:53 -0500
Processing by TanksController#destroy as HTML
  Parameters: {"authenticity_token"=>"hE2WzZiO2kyaht9uB/lX6Ljv9//JVJ6iIQNw56pCt8uPt3OojvVmzcWDRdX+/sTID+ZOe9PgWyBFRwoB3J+MpA==", "id"=>"18"}
  [1m[36mTank Load (0.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 18 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[31mDELETE FROM `tanks` WHERE `tanks`.`tank_id` = 18[0m
  [1m[35m (27.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks
Completed 302 Found in 52ms (ActiveRecord: 33.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-11-25 00:20:53 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (4.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (24.0ms)
Completed 200 OK in 1073ms (Views: 865.5ms | ActiveRecord: 4.0ms)


  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (5.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (5.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- delete employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE deleteEmployee(ID int)
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE fName VARCHAR(45);
    DECLARE lName VARCHAR(45);
    DECLARE theHiredDate DATE;
    DECLARE theSalary double;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    SET fName = (SELECT firstName from employees where ID = employeeID);
    SET lName = (SELECT lastName from employees where ID = employeeID);
    SET theHiredDate = (SELECT hiredDate from employees where employeeID = ID);
    SET theSalary = (SELECT salary from employees where ID = employeeID);


    START TRANSACTION;
    INSERT INTO formerEmployees VALUES (ID, fName, lName, theHiredDate, CURDATE(), theSalary);
    DELETE FROM Employees WHERE ID = employeeID;

    IF sqlError = FALSE and employeeExist = 1 THEN
      COMMIT;
        SELECT CONCAT('Employee ', ID, ' no longer listed as current employee') as 'result';
    ELSE
      ROLLBACK;
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (2.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managingEmployee, maxGuestsPerPerson, maxAttending, eventDate) 
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';    

    END; 

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (13.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managingEmployee, maxGuestsPerPerson, maxAttending, eventDate) 
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';    

    END; 

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (25.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (24.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (12.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (66.2ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (49.1ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (68.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (65.2ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (129.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (82.2ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (60.6ms)[0m  [1m[35m      CREATE TABLE former_employees (
        employee_id int(11) NOT NULL,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        end_date date NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (64.2ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (74.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (62.7ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (66.3ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (80.6ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (6.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- delete employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE deleteEmployee(ID int)
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE fName VARCHAR(45);
    DECLARE lName VARCHAR(45);
    DECLARE theHiredDate DATE;
    DECLARE theSalary double;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    SET fName = (SELECT firstName from employees where ID = employeeID);
    SET lName = (SELECT lastName from employees where ID = employeeID);
    SET theHiredDate = (SELECT hiredDate from employees where employeeID = ID);
    SET theSalary = (SELECT salary from employees where ID = employeeID);


    START TRANSACTION;
    INSERT INTO formerEmployees VALUES (ID, fName, lName, theHiredDate, CURDATE(), theSalary);
    DELETE FROM Employees WHERE ID = employeeID;

    IF sqlError = FALSE and employeeExist = 1 THEN
      COMMIT;
        SELECT CONCAT('Employee ', ID, ' no longer listed as current employee') as 'result';
    ELSE
      ROLLBACK;
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (7.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managingEmployee, maxGuestsPerPerson, maxAttending, eventDate) 
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';    

    END; 

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN 

    SELECT * FROM events
      ORDER BY eventDate DESC;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN 

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managingEmployee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN 

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN 

    SELECT * FROM events
      WHERE MONTH(eventDate) = Emonth AND YEAR(eventDate) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events 
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events 
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

    CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events 
    SET manager = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END; 

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';    
      ELSE 
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (4.0ms)[0m  [1m[35m        -- ------------------------------------------
        -- Register a member for an event
        -- ------------------------------------------
        CREATE PROCEDURE registerForEvent(memID int, eventNo int, guests int)

        BEGIN
        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;
        DECLARE maxGuestsPerP INT DEFAULT 0;
        DECLARE maxGuestsTotal INT DEFAULT 0;
        DECLARE guestsSoFar INT DEFAULT 0;
        DECLARE registeredAlready INT DEFAULT 0;

        SET registeredAlready = (SELECT count(*) FROM eventRegistrations where eventNo = event AND memID = member);
        SET maxGuestsPerP = (SELECT maxGuestsPerPerson FROM events where eventID = eventNo);
        SET maxGuestsTotal = (SELECT maxGuestsPerPerson FROM events where eventID = eventNo);
        SET guestsSoFar = (SELECT SUM(guestCount) FROM eventRegistrations where event = eventNo);
        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        IF (guests >= maxGuestsPerP) THEN
          SELECT CONCAT('Guests exceed maximum allowed. Up to ', maxGuestsPerP, ' permitted.') as 'result';
        ELSEIF (guestsSoFar + guests > maxGuestsTotal) THEN
          SELECT CONCAT('Not enough spaces available to register this member and their ', guests, ' guests.') as 'result';
        ELSEIF (registeredAlready != 0) THEN
          SELECT CONCAT('Member ', memID, ' already registered for event ', eventNo) as 'result';
        ELSE
        INSERT INTO EventRegistrations (time, member, event, guestCount)
          VALUES (NOW(), memID, eventNo, guests);
        SELECT CONCAT('Registration complete.') AS 'result';
        END IF;
        END;

        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (4.5ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (10.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (10.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (34.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-03 13:47:57', '2017-12-03 13:47:57')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/animals" for 127.0.0.1 at 2017-12-03 08:51:44 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (4.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (180.1ms)
Completed 200 OK in 1687ms (Views: 1575.3ms | ActiveRecord: 7.5ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-12-03 08:52:25 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (2.5ms)
Completed 200 OK in 600ms (Views: 457.3ms | ActiveRecord: 1.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-03 08:52:28 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (102.6ms)
Completed 200 OK in 621ms (Views: 527.3ms | ActiveRecord: 1.0ms)


Started GET "/animals/1/edit" for 127.0.0.1 at 2017-12-03 08:52:31 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  Rendered animals/_form.html.erb (309.7ms)
  Rendered animals/edit.html.erb within layouts/application (571.4ms)
Completed 200 OK in 1693ms (Views: 1518.7ms | ActiveRecord: 1.0ms)


Started PATCH "/animals/1" for 127.0.0.1 at 2017-12-03 08:52:37 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"VgIR+6Mdl0yNC2JxY1krB+bHWg/DNEz20azct6DOFqNDTJEOnMFLZwYuATKCa91rWgmL21tINCcNDalGJEAMOg==", "animal"=>{"animal_id"=>"4", "name"=>"", "species"=>"Piranha", "tank"=>"", "birth_date(1i)"=>"2010", "birth_date(2i)"=>"1", "birth_date(3i)"=>"18", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"1"}
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 97ms (ActiveRecord: 3.0ms)


  
ActiveRecord::AssociationTypeMismatch (Tank(#42600888) expected, got "" which is an instance of String(#20642256)):
  
app/controllers/animals_controller.rb:44:in `block in update'
app/controllers/animals_controller.rb:43:in `update'
Started GET "/animals" for 127.0.0.1 at 2017-12-03 08:53:22 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (16.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (174.4ms)
Completed 200 OK in 1599ms (Views: 1285.6ms | ActiveRecord: 16.0ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-12-03 08:53:26 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (2.0ms)
Completed 200 OK in 361ms (Views: 275.2ms | ActiveRecord: 1.0ms)


Started GET "/animals/2" for 127.0.0.1 at 2017-12-03 08:53:31 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"2"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 2 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (3.5ms)
Completed 200 OK in 767ms (Views: 608.2ms | ActiveRecord: 1.0ms)


Started GET "/animals/8" for 127.0.0.1 at 2017-12-03 08:53:35 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"8"}
  [1m[36mAnimal Load (2.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 8 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (4.0ms)
Completed 200 OK in 1901ms (Views: 1697.9ms | ActiveRecord: 2.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-03 08:53:49 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (7.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (116.1ms)
Completed 200 OK in 1914ms (Views: 1411.0ms | ActiveRecord: 23.0ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-03 08:54:07 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  Rendered tanks/_form.html.erb (39.5ms)
  Rendered tanks/new.html.erb within layouts/application (307.7ms)
Completed 200 OK in 1422ms (Views: 1224.3ms | ActiveRecord: 0.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-03 08:54:31 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"HqIOaQRPOIy6PFVCOi7pnLEG+5SiAjuJUS9sfBa4a3YZ6XQbav507jLJzP/0PqmGMa9qonXRtZNItYBiDYya9w==", "tank"=>{"tank_id"=>"14", "name"=>"a", "description"=>"b", "water_type"=>"salt", "volume"=>"12", "temperature"=>"20", "year_built"=>"1990", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (24.5ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (7.5ms)[0m  [1m[32mINSERT INTO `tanks` (`tank_id`, `name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES (14, 'a', 'b', 'salt', 12.0, 20.0, 1990, 1)[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 391ms (ActiveRecord: 87.1ms)


  
ActiveRecord::RecordNotUnique (Mysql2::Error: Duplicate entry '14' for key 'PRIMARY': INSERT INTO `tanks` (`tank_id`, `name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES (14, 'a', 'b', 'salt', 12.0, 20.0, 1990, 1)):
  
app/controllers/tanks_controller.rb:30:in `block in create'
app/controllers/tanks_controller.rb:29:in `create'
Started GET "/tanks" for 127.0.0.1 at 2017-12-03 08:55:17 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (15.6ms)
Completed 200 OK in 832ms (Views: 592.2ms | ActiveRecord: 1.0ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-03 08:57:01 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  Rendered tanks/_form.html.erb (12.5ms)
  Rendered tanks/new.html.erb within layouts/application (189.6ms)
Completed 200 OK in 1113ms (Views: 912.1ms | ActiveRecord: 0.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-03 08:57:20 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Azq6HWgEAsYpLXsXOGO+voVf0txg27hUpyqMCvzG4mgEccBvBrVOpKHY4qr2c/6kBfZD6rcINk6+sGAU5/IT6Q==", "tank"=>{"tank_id"=>"78", "name"=>"a", "description"=>"b", "water_type"=>"salt", "volume"=>"20", "temperature"=>"20", "year_built"=>"1990", "habitat_id"=>"-1"}, "commit"=>"Create Tank"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (21.5ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = -1 LIMIT 1[0m
  [1m[35m (12.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  Rendered tanks/_form.html.erb (25.8ms)
  Rendered tanks/new.html.erb within layouts/application (271.4ms)
Completed 200 OK in 1474ms (Views: 1346.4ms | ActiveRecord: 34.5ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-03 08:57:37 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"DA3a1iZdQSPmWClHUgF6GdKykHIeyX2uubbRX5i6K1Uwnx5EpchWQQRUoKrzsWfon0de/CPkm22GjKB2Q9BAlQ==", "tank"=>{"tank_id"=>"78", "name"=>"a", "description"=>"b", "water_type"=>"asf", "volume"=>"20", "temperature"=>"20", "year_built"=>"1990", "habitat_id"=>"2"}, "commit"=>"Create Tank"}
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (2.5ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 2 LIMIT 1[0m
  [1m[35mSQL (3.5ms)[0m  [1m[32mINSERT INTO `tanks` (`tank_id`, `name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES (78, 'a', 'b', 'asf', 20.0, 20.0, 1990, 2)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 35ms (ActiveRecord: 8.5ms)


  
ActiveRecord::StatementInvalid (Mysql2::Error: Data truncated for column 'water_type' at row 1: INSERT INTO `tanks` (`tank_id`, `name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES (78, 'a', 'b', 'asf', 20.0, 20.0, 1990, 2)):
  
app/controllers/tanks_controller.rb:30:in `block in create'
app/controllers/tanks_controller.rb:29:in `create'
Started GET "/feedinglogs" for 127.0.0.1 at 2017-12-03 09:30:22 -0500
  [1m[35m (27.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
ActionController::RoutingError (No route matches [GET] "/feedinglogs"):
  
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:63:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/feedinglog" for 127.0.0.1 at 2017-12-03 09:31:26 -0500
  
ActionController::RoutingError (No route matches [GET] "/feedinglog"):
  
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:63:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/employees" for 127.0.0.1 at 2017-12-03 09:32:03 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEmployee Load (6.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (109.6ms)
Completed 200 OK in 2593ms (Views: 2359.4ms | ActiveRecord: 14.5ms)


Started GET "/employees/new" for 127.0.0.1 at 2017-12-03 09:32:52 -0500
Processing by EmployeesController#new as HTML
  Rendering employees/new.html.erb within layouts/application
  Rendered employees/_form.html.erb (284.2ms)
  Rendered employees/new.html.erb within layouts/application (735.5ms)
Completed 200 OK in 2031ms (Views: 1876.0ms | ActiveRecord: 0.0ms)


Started POST "/employees" for 127.0.0.1 at 2017-12-03 09:32:58 -0500
Processing by EmployeesController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"N4+weynSXTTaktCkPEv7hgRVBH3DDk43aUkuBdyrxRUNd/ZCDkKZ61GI98LtpngzOF7GR2UHyD6LIhLZ4btiJg==", "employee"=>{"employee_id"=>"1", "first_name"=>"", "last_name"=>"", "hired_date(1i)"=>"2017", "hired_date(2i)"=>"12", "hired_date(3i)"=>"3", "salary"=>""}, "commit"=>"Create Employee"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.5ms)[0m  [1m[32mINSERT INTO `employees` (`employee_id`, `first_name`, `last_name`, `hired_date`) VALUES (1, '', '', '{1=>2017, 2=>12, 3=>3}')[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 41ms (ActiveRecord: 11.0ms)


  
ActiveRecord::NotNullViolation (Mysql2::Error: Field 'salary' doesn't have a default value: INSERT INTO `employees` (`employee_id`, `first_name`, `last_name`, `hired_date`) VALUES (1, '', '', '{1=>2017, 2=>12, 3=>3}')):
  
app/controllers/employees_controller.rb:30:in `block in create'
app/controllers/employees_controller.rb:29:in `create'
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events" for 127.0.0.1 at 2017-12-03 11:26:08 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/controllers/events_controller.rb:77: syntax error, unexpected end-of-input, expecting keyword_end):
  
app/controllers/events_controller.rb:77: syntax error, unexpected end-of-input, expecting keyword_end
Started GET "/events" for 127.0.0.1 at 2017-12-03 11:30:30 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (26.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (189.9ms)
Completed 200 OK in 2491ms (Views: 2234.8ms | ActiveRecord: 33.0ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 11:32:01 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (6.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (4.0ms)
Completed 200 OK in 915ms (Views: 766.0ms | ActiveRecord: 7.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 11:32:05 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (21.7ms)
Completed 200 OK in 786ms (Views: 678.1ms | ActiveRecord: 1.5ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 11:32:07 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (422.3ms)
  Rendered events/edit.html.erb within layouts/application (655.5ms)
Completed 200 OK in 2186ms (Views: 1905.9ms | ActiveRecord: 1.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 11:32:12 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (22.5ms)
Completed 200 OK in 969ms (Views: 794.7ms | ActiveRecord: 1.5ms)


Started GET "/events/new" for 127.0.0.1 at 2017-12-03 11:32:24 -0500
Processing by EventsController#new as HTML
  Rendering events/new.html.erb within layouts/application
  Rendered events/_form.html.erb (21.5ms)
  Rendered events/new.html.erb within layouts/application (175.2ms)
Completed 200 OK in 1157ms (Views: 966.7ms | ActiveRecord: 0.0ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 11:32:27 -0500
Processing by EventsController#index as HTML
Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 11:32:29 -0500
Processing by EventsController#edit as HTML
  Rendering events/index.html.erb within layouts/application
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (3.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  [1m[36mEvent Load (63.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendered events/index.html.erb within layouts/application (616.9ms)
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (12.0ms)
  Rendered events/edit.html.erb within layouts/application (101.1ms)
Completed 200 OK in 3229ms (Views: 2798.1ms | ActiveRecord: 3.5ms)


Completed 200 OK in 1354ms (Views: 842.7ms | ActiveRecord: 63.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 11:42:10 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (28.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (262.4ms)
Completed 200 OK in 3305ms (Views: 3044.3ms | ActiveRecord: 35.5ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 11:42:55 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (8.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (116.7ms)
  Rendered events/edit.html.erb within layouts/application (260.3ms)
Completed 200 OK in 1383ms (Views: 1103.3ms | ActiveRecord: 10.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 11:43:03 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"lAjlb07hlG71OQPQVIvzxpPDJwTEXvqzc1HAyTNTzly14Lk3pD7OYNXi8KR6G5PZIDb/+PCrteWxcRjTvwSgCg==", "event"=>{"event_id"=>"2", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.0ms)[0m  [1m[33mUPDATE `events` SET `event_id` = 2 WHERE `events`.`event_id` = 1[0m
  [1m[35m (5.0ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 49ms (ActiveRecord: 16.5ms)


  
ActiveRecord::RecordNotUnique (Mysql2::Error: Duplicate entry '2' for key 'PRIMARY': UPDATE `events` SET `event_id` = 2 WHERE `events`.`event_id` = 1):
  
app/controllers/events_controller.rb:44:in `block in update'
app/controllers/events_controller.rb:43:in `update'
Started GET "/events" for 127.0.0.1 at 2017-12-03 11:43:38 -0500
Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 11:43:38 -0500
Processing by EventsController#index as HTML
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (2939.6ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (45.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (3.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (8.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (31.5ms)
  Rendered events/index.html.erb within layouts/application (1834.3ms)
  Rendered events/edit.html.erb within layouts/application (263.7ms)
Completed 500 Internal Server Error in 10089ms (ActiveRecord: 12.0ms)


  
ActionView::Template::Error (can't add a new key into hash during iteration):
     5:     <%= csrf_meta_tags %>
     6: 
     7:     <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>
     8:     <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
     9:   </head>
    10: 
    11:   <body>
  
app/views/layouts/application.html.erb:8:in `_app_views_layouts_application_html_erb___754457360_104526132'
Completed 200 OK in 6361ms (Views: 2138.0ms | ActiveRecord: 2985.1ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 11:44:42 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (25.5ms)
  Rendered events/edit.html.erb within layouts/application (240.2ms)
Completed 200 OK in 1310ms (Views: 1139.8ms | ActiveRecord: 1.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 11:44:46 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"BEWUaq7lZ0RX3BJCyR4939QTue/JtiC8R03FFcJDkUs411D4LXBwJrXQm69oriAumeZ3YfSbxn94d7Q8GSn6iw==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (7.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 216ms (ActiveRecord: 9.0ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 11:44:46 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (2.0ms)
Completed 200 OK in 1030ms (Views: 887.3ms | ActiveRecord: 1.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 11:44:54 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (22.6ms)
Completed 200 OK in 1021ms (Views: 883.6ms | ActiveRecord: 1.5ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 11:44:57 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (35.5ms)
  Rendered events/edit.html.erb within layouts/application (393.3ms)
Completed 200 OK in 2636ms (Views: 2414.7ms | ActiveRecord: 1.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 11:45:02 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"g9mYtRJyO5xb2zOud9E4/DrgXNkKWXVf9XMGJ4Pf2HiiMcTt+K1hknsAwNpZQVjjiRWEJT6sOgk3U949D4i2Lg==", "event"=>{"event_id"=>"2", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (10.0ms)[0m  [1m[33mUPDATE `events` SET `event_id` = 2 WHERE `events`.`event_id` = 1[0m
  [1m[35m (6.0ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 60ms (ActiveRecord: 19.0ms)


  
ActiveRecord::RecordNotUnique (Mysql2::Error: Duplicate entry '2' for key 'PRIMARY': UPDATE `events` SET `event_id` = 2 WHERE `events`.`event_id` = 1):
  
app/controllers/events_controller.rb:44:in `block in update'
app/controllers/events_controller.rb:43:in `update'
Started GET "/events/1" for 127.0.0.1 at 2017-12-03 11:45:28 -0500
Started GET "/events" for 127.0.0.1 at 2017-12-03 11:45:29 -0500
Processing by EventsController#show as HTML
Processing by EventsController#index as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (194.1ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (3723.2ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (3.0ms)
  Rendered events/index.html.erb within layouts/application (4153.9ms)
Completed 200 OK in 12637ms (Views: 5065.8ms | ActiveRecord: 194.1ms)


Completed 200 OK in 13284ms (Views: 9112.6ms | ActiveRecord: 3723.2ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 11:52:39 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (4.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (61.0ms)
Completed 200 OK in 1496ms (Views: 1352.3ms | ActiveRecord: 8.0ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 11:53:19 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (7.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (193.2ms)
  Rendered events/edit.html.erb within layouts/application (416.3ms)
Completed 200 OK in 1438ms (Views: 1256.6ms | ActiveRecord: 9.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 11:53:26 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"8LCUqhle9pDacfxO1UgGUCrOfOnJJdJqYS/VWwUvdJLRWMjy84GsnvqqDzr72GZPmTukFf3QnTyjDw1BiXgaxA==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.5ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 78 WHERE `events`.`event_id` = 1[0m
  [1m[35m (10.0ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 34ms (ActiveRecord: 19.0ms)


  
ActiveRecord::InvalidForeignKey (Mysql2::Error: Cannot add or update a child row: a foreign key constraint fails (`aquarium_tycoon_development`.`events`, CONSTRAINT `fk_employee_events` FOREIGN KEY (`managing_employee`) REFERENCES `employees` (`employee_id`) ON UPDATE CASCADE): UPDATE `events` SET `managing_employee` = 78 WHERE `events`.`event_id` = 1):
  
app/controllers/events_controller.rb:44:in `block in update'
app/controllers/events_controller.rb:43:in `update'
Started GET "/tanks" for 127.0.0.1 at 2017-12-03 11:54:40 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (6.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (73.1ms)
Completed 200 OK in 1255ms (Views: 975.7ms | ActiveRecord: 11.0ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-03 11:54:44 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (16.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  Rendered tanks/_form.html.erb (7.0ms)
  Rendered tanks/edit.html.erb within layouts/application (280.9ms)
Completed 200 OK in 1543ms (Views: 1260.5ms | ActiveRecord: 16.0ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-03 11:54:53 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"MZsl5sH4gMdaez56JX4PPeyxBf5OcYZ7ndboI+4lzTUm43GZbIKzWTFBziZrRj6fSINfUfwDtcE3IWI24xS2iw==", "tank"=>{"tank_id"=>"1", "name"=>"River", "description"=>"Meet the menacing inhabitants of the Amazon River!", "water_type"=>"fresh", "volume"=>"2000.0", "temperature"=>"76.0", "year_built"=>"2015", "habitat_id"=>"79"}, "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (1.5ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 79 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/edit.html.erb within layouts/application
  Rendered tanks/_form.html.erb (27.7ms)
  Rendered tanks/edit.html.erb within layouts/application (263.5ms)
Completed 200 OK in 1358ms (Views: 1179.9ms | ActiveRecord: 15.0ms)


  [1m[35m (15.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (298.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (16.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (47.0ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (99.1ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (28.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (65.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (68.6ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (65.0ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (53.5ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (65.5ms)[0m  [1m[35m      CREATE TABLE former_employees (
        employee_id int(11) NOT NULL,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        end_date date NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (87.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (185.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (105.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (68.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (99.6ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (5.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (11.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (11.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (4.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (29.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (10.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (22.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (10.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (9.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (16.5ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (10.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (21.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (11.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (6.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- delete employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE deleteEmployee(ID int)
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE fName VARCHAR(45);
    DECLARE lName VARCHAR(45);
    DECLARE theHiredDate DATE;
    DECLARE theSalary double;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    SET fName = (SELECT firstName from employees where ID = employeeID);
    SET lName = (SELECT lastName from employees where ID = employeeID);
    SET theHiredDate = (SELECT hiredDate from employees where employeeID = ID);
    SET theSalary = (SELECT salary from employees where ID = employeeID);


    START TRANSACTION;
    INSERT INTO formerEmployees VALUES (ID, fName, lName, theHiredDate, CURDATE(), theSalary);
    DELETE FROM Employees WHERE ID = employeeID;

    IF sqlError = FALSE and employeeExist = 1 THEN
      COMMIT;
        SELECT CONCAT('Employee ', ID, ' no longer listed as current employee') as 'result';
    ELSE
      ROLLBACK;
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managingEmployee, maxGuestsPerPerson, maxAttending, eventDate) 
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';    

    END; 

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN 

    SELECT * FROM events
      ORDER BY eventDate DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN 

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managingEmployee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN 

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN 

    SELECT * FROM events
      WHERE MONTH(eventDate) = Emonth AND YEAR(eventDate) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events 
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events 
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

    CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events 
    SET manager = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END; 

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';    
      ELSE 
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (7.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (7.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (8.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END //
[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
Started GET "/events" for 127.0.0.1 at 2017-12-03 12:03:09 -0500
  [1m[35m (29.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
ActiveRecord::PendingMigrationError (

Migrations are pending. To resolve this issue, run:

        bin/rails db:migrate RAILS_ENV=development

):
  
activerecord (5.1.4) lib/active_record/migration.rb:576:in `check_pending!'
activerecord (5.1.4) lib/active_record/migration.rb:553:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:26:in `block in call'
activesupport (5.1.4) lib/active_support/callbacks.rb:97:in `run_callbacks'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:24:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:59:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/events" for 127.0.0.1 at 2017-12-03 12:11:59 -0500
  [1m[35m (25.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
ActiveRecord::PendingMigrationError (

Migrations are pending. To resolve this issue, run:

        bin/rails db:migrate RAILS_ENV=development

):
  
activerecord (5.1.4) lib/active_record/migration.rb:576:in `check_pending!'
activerecord (5.1.4) lib/active_record/migration.rb:553:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:26:in `block in call'
activesupport (5.1.4) lib/active_support/callbacks.rb:97:in `run_callbacks'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:24:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:59:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/events" for 127.0.0.1 at 2017-12-03 12:13:40 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
ActiveRecord::PendingMigrationError (

Migrations are pending. To resolve this issue, run:

        bin/rails db:migrate RAILS_ENV=development

):
  
activerecord (5.1.4) lib/active_record/migration.rb:576:in `check_pending!'
activerecord (5.1.4) lib/active_record/migration.rb:553:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:26:in `block in call'
activesupport (5.1.4) lib/active_support/callbacks.rb:97:in `run_callbacks'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:24:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:59:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
  [1m[35m (25.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (24.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (25.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (25.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.8ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-03 17:26:52', '2017-12-03 17:26:52')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (263.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (3.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (57.0ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (56.0ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (53.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (51.0ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (57.0ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (40.2ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (52.1ms)[0m  [1m[35m      CREATE TABLE former_employees (
        employee_id int(11) NOT NULL,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        end_date date NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (47.7ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (64.9ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (69.8ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (54.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (115.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (4.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (12.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (15.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (19.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (9.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (16.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (10.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (14.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- delete employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE deleteEmployee(ID int)
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE fName VARCHAR(45);
    DECLARE lName VARCHAR(45);
    DECLARE theHiredDate DATE;
    DECLARE theSalary double;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    SET fName = (SELECT firstName from employees where ID = employeeID);
    SET lName = (SELECT lastName from employees where ID = employeeID);
    SET theHiredDate = (SELECT hiredDate from employees where employeeID = ID);
    SET theSalary = (SELECT salary from employees where ID = employeeID);


    START TRANSACTION;
    INSERT INTO formerEmployees VALUES (ID, fName, lName, theHiredDate, CURDATE(), theSalary);
    DELETE FROM Employees WHERE ID = employeeID;

    IF sqlError = FALSE and employeeExist = 1 THEN
      COMMIT;
        SELECT CONCAT('Employee ', ID, ' no longer listed as current employee') as 'result';
    ELSE
      ROLLBACK;
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managingEmployee, maxGuestsPerPerson, maxAttending, eventDate) 
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';    

    END; 

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN 

    SELECT * FROM events
      ORDER BY eventDate DESC;
    END;

[0m
  [1m[35m (9.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN 

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managingEmployee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (5.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN 

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN 

    SELECT * FROM events
      WHERE MONTH(eventDate) = Emonth AND YEAR(eventDate) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events 
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events 
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

    CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events 
    SET manager = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END; 

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';    
      ELSE 
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (11.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (9.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (11.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END //
[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
Started GET "/events" for 127.0.0.1 at 2017-12-03 12:30:24 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (3.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
ActiveRecord::PendingMigrationError (

Migrations are pending. To resolve this issue, run:

        bin/rails db:migrate RAILS_ENV=development

):
  
activerecord (5.1.4) lib/active_record/migration.rb:576:in `check_pending!'
activerecord (5.1.4) lib/active_record/migration.rb:553:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:26:in `block in call'
activesupport (5.1.4) lib/active_support/callbacks.rb:97:in `run_callbacks'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:24:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:59:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Started GET "/tanks" for 127.0.0.1 at 2017-12-03 12:31:31 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
ActiveRecord::PendingMigrationError (

Migrations are pending. To resolve this issue, run:

        bin/rails db:migrate RAILS_ENV=development

):
  
activerecord (5.1.4) lib/active_record/migration.rb:576:in `check_pending!'
activerecord (5.1.4) lib/active_record/migration.rb:553:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:26:in `block in call'
activesupport (5.1.4) lib/active_support/callbacks.rb:97:in `run_callbacks'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:24:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:59:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (26.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (25.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (26.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (10.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (8.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (16.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (26.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-03 17:54:55', '2017-12-03 17:54:55')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (25.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (290.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (42.7ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (52.6ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (24.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (43.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (42.6ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (63.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (30.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date varchar(45) NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (41.7ms)[0m  [1m[35m      CREATE TABLE former_employees (
        employee_id int(11) NOT NULL,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        end_date date NOT NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (58.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (70.7ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE SET NULL ON UPDATE CASCADE
      );
[0m
  [1m[35m (107.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (82.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (72.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- delete employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE deleteEmployee(ID int)
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE fName VARCHAR(45);
    DECLARE lName VARCHAR(45);
    DECLARE theHiredDate DATE;
    DECLARE theSalary double;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    SET fName = (SELECT firstName from employees where ID = employeeID);
    SET lName = (SELECT lastName from employees where ID = employeeID);
    SET theHiredDate = (SELECT hiredDate from employees where employeeID = ID);
    SET theSalary = (SELECT salary from employees where ID = employeeID);


    START TRANSACTION;
    INSERT INTO formerEmployees VALUES (ID, fName, lName, theHiredDate, CURDATE(), theSalary);
    DELETE FROM Employees WHERE ID = employeeID;

    IF sqlError = FALSE and employeeExist = 1 THEN
      COMMIT;
        SELECT CONCAT('Employee ', ID, ' no longer listed as current employee') as 'result';
    ELSE
      ROLLBACK;
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND 
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;
      
    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND 
      (eSalary = salary OR eSalary IS NULL);
      
      RETURN numEmployees;
  END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managingEmployee, maxGuestsPerPerson, maxAttending, eventDate) 
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';    

    END; 

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN 

    SELECT * FROM events
      ORDER BY eventDate DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN 

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managingEmployee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN 

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN 

    SELECT * FROM events
      WHERE MONTH(eventDate) = Emonth AND YEAR(eventDate) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events 
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events 
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

    CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN 
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events 
    SET manager = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN 
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END; 

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';    
      ELSE 
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11), 
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND 
        (eManager = managingEmployee OR eManager IS NULL) AND
        (maxGuests = maxGuestsPerPerson OR maxGuests is NULL) AND
        ( maxAttend = maxAttending OR maxAttend is NULL) AND
        (eDate = eventDate OR eDate is NULL);
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (29.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (30.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (9.9ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m        -- ------------------------------------------
        -- Register a member for an event
        -- ------------------------------------------
        CREATE PROCEDURE registerForEvent(memID int, eventNo int, guests int)

          BEGIN 
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;
          DECLARE maxGuestsPerP INT DEFAULT 0;
          DECLARE maxGuestsTotal INT DEFAULT 0;
          DECLARE guestsSoFar INT DEFAULT 0;
          DECLARE registeredAlready INT DEFAULT 0;

          SET registeredAlready = (SELECT count(*) FROM eventRegistrations where eventNo = event AND memID = member);
          SET maxGuestsPerP = (SELECT maxGuestsPerPerson FROM events where eventID = eventNo);
          SET maxGuestsTotal = (SELECT maxGuestsPerPerson FROM events where eventID = eventNo);
          SET guestsSoFar = memsRegistered(eventNo);
          BEGIN
          -- Error handler setups
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

          IF (guests >= maxGuestsPerP) THEN
            SELECT CONCAT('Guests exceed maximum allowed. Up to ', maxGuestsPerP, ' permitted.') as 'result';
          ELSEIF (guestsSoFar + guests > maxGuestsTotal) THEN
            SELECT CONCAT('Not enough spaces available to register this member and their ', guests, ' guests.') as 'result';
          ELSEIF (registeredAlready != 0) THEN
            SELECT CONCAT('Member ', memID, ' already registered for event ', eventNo) as 'result';
          ELSE
          INSERT INTO EventRegistrations (time, member, event, guestCount) 
            VALUES (NOW(), memID, eventNo, guests);
          SELECT CONCAT('Registration complete.') AS 'result';  
          END IF;
          END;

          IF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Registration not logged.') AS 'result';    
            END IF;

          END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event OR eID is NULL) AND 
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.6ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-03 17:56:36', '2017-12-03 17:56:36')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events" for 127.0.0.1 at 2017-12-03 12:58:39 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (29.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (198.2ms)
Completed 200 OK in 3549ms (Views: 3293.5ms | ActiveRecord: 36.0ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:00:37 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (4.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (326.1ms)
  Rendered events/edit.html.erb within layouts/application (508.2ms)
Completed 200 OK in 1370ms (Views: 1246.0ms | ActiveRecord: 5.5ms)


  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:11:38 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
Completed 500 Internal Server Error in 170ms (ActiveRecord: 0.0ms)


  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/models/event.rb:2: syntax error, unexpected ':', expecting keyword_end
validate : future_date
          ^
C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/models/event.rb:10: syntax error, unexpected keyword_end, expecting ')'):
  
app/models/event.rb:2: syntax error, unexpected ':', expecting keyword_end
app/models/event.rb:10: syntax error, unexpected keyword_end, expecting ')'
app/controllers/events_controller.rb:67:in `set_event'
Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:11:53 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"/oIyoh5d3/40wN9SVpSxHZYV8/tcyKpN9LDXl83EZdDfam769IKF8BQbLCZ4BNECJeArB2g95Rs2kA+NQZMLhg==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2017", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
Completed 500 Internal Server Error in 14984ms (ActiveRecord: 0.0ms)


  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/models/event.rb:2: syntax error, unexpected ':', expecting keyword_end
validate : future_date
          ^
C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/models/event.rb:10: syntax error, unexpected keyword_end, expecting ')'):
  
app/models/event.rb:2: syntax error, unexpected ':', expecting keyword_end
app/models/event.rb:10: syntax error, unexpected keyword_end, expecting ')'
app/controllers/events_controller.rb:67:in `set_event'
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (27.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (28.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (4.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:16:05 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"/oIyoh5d3/40wN9SVpSxHZYV8/tcyKpN9LDXl83EZdDfam769IKF8BQbLCZ4BNECJeArB2g95Rs2kA+NQZMLhg==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2017", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
Completed 500 Internal Server Error in 30ms (ActiveRecord: 0.0ms)


  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/models/event.rb:10: syntax error, unexpected keyword_end, expecting ')'):
  
app/models/event.rb:10: syntax error, unexpected keyword_end, expecting ')'
app/controllers/events_controller.rb:67:in `set_event'
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (26.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/tanks" for 127.0.0.1 at 2017-12-03 13:19:56 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (25.6ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (197.5ms)
Completed 200 OK in 2379ms (Views: 2185.8ms | ActiveRecord: 32.1ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:21:00 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"/oIyoh5d3/40wN9SVpSxHZYV8/tcyKpN9LDXl83EZdDfam769IKF8BQbLCZ4BNECJeArB2g95Rs2kA+NQZMLhg==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2017", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[33mUPDATE `events` SET `event_date` = '2017-01-01 19:00:00' WHERE `events`.`event_id` = 1[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 158ms (ActiveRecord: 21.0ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 13:21:00 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (4.5ms)
Completed 200 OK in 915ms (Views: 813.6ms | ActiveRecord: 1.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 13:21:11 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (29.5ms)
Completed 200 OK in 1169ms (Views: 957.5ms | ActiveRecord: 2.0ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:21:17 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (273.7ms)
  Rendered events/edit.html.erb within layouts/application (524.4ms)
Completed 200 OK in 1435ms (Views: 1263.3ms | ActiveRecord: 2.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:21:25 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"chbkYKvClNBlST5u+OmvTHiSPFH88pA3piI5i2kc4D1T/rg4QR3O3kWSzRrWec9Ty2fkrcgH32FkAuGR5UuOaw==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2013", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (3.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[33mUPDATE `events` SET `event_date` = '2013-01-01 19:00:00' WHERE `events`.`event_id` = 1[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 44ms (ActiveRecord: 14.0ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 13:21:26 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (6.5ms)
Completed 200 OK in 1509ms (Views: 1310.8ms | ActiveRecord: 1.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 13:21:29 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (8.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (29.5ms)
Completed 200 OK in 917ms (Views: 735.6ms | ActiveRecord: 8.0ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:23:32 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (228.8ms)
  Rendered events/edit.html.erb within layouts/application (457.5ms)
Completed 200 OK in 3208ms (Views: 2819.0ms | ActiveRecord: 15.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:24:14 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"ArNfpkkV7s1zwvH6xKx65REkvjoELVYyVcl5m9XicnAjWwP+o8q0w1MZAo7qPBr6otFmxjDYGWSX6aGBWbUcJg==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"12", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 23ms (ActiveRecord: 3.5ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 13:24:14 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (7.6ms)
Completed 200 OK in 693ms (Views: 572.1ms | ActiveRecord: 1.0ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 13:24:20 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (15.0ms)
Completed 200 OK in 853ms (Views: 638.1ms | ActiveRecord: 1.5ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:24:24 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (19.5ms)
  Rendered events/edit.html.erb within layouts/application (164.6ms)
Completed 200 OK in 1383ms (Views: 954.4ms | ActiveRecord: 1.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:24:28 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"14AvVegKJtyujaDZvW6ebaM3H5ZCScGZECeVEUWyZFr2aHMNAtV80o5WU62T/v5yEMLHana8js/SB00LyeUKDA==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2013", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 25ms (ActiveRecord: 4.5ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 13:24:28 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (7.5ms)
Completed 200 OK in 1296ms (Views: 1020.2ms | ActiveRecord: 1.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 13:24:32 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (8.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (73.6ms)
Completed 200 OK in 2017ms (Views: 1292.0ms | ActiveRecord: 8.0ms)


  [1m[35m (16.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (7.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (2.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events" for 127.0.0.1 at 2017-12-03 13:27:47 -0500
Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:27:47 -0500
  [1m[35m (3.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (27.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (29.9ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/controllers/events_controller.rb:50: syntax error, unexpected tSYMBEG, expecting keyword_do or '{' or '('
...er json:@event.errors, status :unprocessable_entity}
...                               ^):
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/controllers/events_controller.rb:50: syntax error, unexpected tSYMBEG, expecting keyword_do or '{' or '('
...er json:@event.errors, status :unprocessable_entity}
...                               ^):
  
  
app/controllers/events_controller.rb:50: syntax error, unexpected tSYMBEG, expecting keyword_do or '{' or '('
app/controllers/events_controller.rb:50: syntax error, unexpected tSYMBEG, expecting keyword_do or '{' or '('
Started GET "/events" for 127.0.0.1 at 2017-12-03 13:30:42 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/controllers/events_controller.rb:50: syntax error, unexpected tSYMBEG, expecting keyword_do or '{' or '('
...er json:@event.errors, status :unprocessable_entity}
...                               ^):
  
app/controllers/events_controller.rb:50: syntax error, unexpected tSYMBEG, expecting keyword_do or '{' or '('
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events" for 127.0.0.1 at 2017-12-03 13:33:03 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (7.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (101.6ms)
Completed 200 OK in 3268ms (Views: 2990.0ms | ActiveRecord: 14.0ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:34:00 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (7.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (166.6ms)
  Rendered events/edit.html.erb within layouts/application (339.7ms)
Completed 200 OK in 1428ms (Views: 1234.8ms | ActiveRecord: 9.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:34:07 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Qtzb8AQjRhk1Mz1JEMnFNbpMPfACo7qtY5PYBuk0015jNIeo7vwcFxXozj0+WaUqCbnlDDZW9fuhswAcZWO9CA==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2013", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 31ms (ActiveRecord: 4.0ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 13:34:07 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (5.5ms)
Completed 200 OK in 1177ms (Views: 985.2ms | ActiveRecord: 1.5ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:34:12 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (30.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (53.0ms)
  Rendered events/edit.html.erb within layouts/application (385.3ms)
Completed 200 OK in 1700ms (Views: 1472.5ms | ActiveRecord: 30.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:34:18 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"0Gzms+wcuNS9OSdLNPzDaJcjgMO5BqkOis3bWG9ME4HxhLrrBsPi2p3i1D8abKN3JNZYP43z5lhI7QNC4xt91w==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[33mUPDATE `events` SET `event_date` = '2018-01-01 19:00:00' WHERE `events`.`event_id` = 1[0m
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 52ms (ActiveRecord: 11.5ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 13:34:18 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (2.5ms)
Completed 200 OK in 529ms (Views: 414.9ms | ActiveRecord: 1.0ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:34:22 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (89.6ms)
  Rendered events/edit.html.erb within layouts/application (659.0ms)
Completed 200 OK in 1977ms (Views: 1835.5ms | ActiveRecord: 1.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:34:28 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"gxpIxoGy8oaipUAjM17a7lhohBDHdgmz6A3HhZxRZxqi8hSea22oiIJ+s1cdzrrx651c7PODRuUqLR+fEAYJTA==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"3", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2013", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (2.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 30ms (ActiveRecord: 5.5ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 13:34:28 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (1.8ms)
Completed 200 OK in 1223ms (Views: 957.1ms | ActiveRecord: 1.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 13:34:47 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (21.5ms)
Completed 200 OK in 865ms (Views: 712.4ms | ActiveRecord: 1.5ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:34:50 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (91.1ms)
  Rendered events/edit.html.erb within layouts/application (413.8ms)
Completed 200 OK in 2502ms (Views: 2114.6ms | ActiveRecord: 2.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:34:57 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"zLMirN6mBIZn2+F/zpyX+1UTVV+1KMg3Fu71bKdF7ZftW370NHleiEcAEgvgDPfk5uaNo4Hdh2HUzi12KxKDwQ==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (9.0ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 78 WHERE `events`.`event_id` = 1[0m
  [1m[35m (4.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (36.5ms)
  Rendered events/edit.html.erb within layouts/application (349.2ms)
Completed 200 OK in 2278ms (Views: 2228.6ms | ActiveRecord: 17.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:35:20 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"gWbB7sCpWyLrd7DHupDLRld7O2MqKO7L1aKDsgozP1+99AV8QzxMQAl7OSobINa3Go717RcFCAjqmPKb0VlUnw==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (12.5ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 78 WHERE `events`.`event_id` = 1[0m
  [1m[35m (5.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (19.5ms)
  Rendered events/edit.html.erb within layouts/application (175.7ms)
Completed 200 OK in 1325ms (Views: 1279.1ms | ActiveRecord: 20.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:35:26 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"3jX8UrsX3kOlG0UXqmaMYvSt7tVOi2MYZTktRKL2SRnipzjAOILJIUcXzPoL1pGTuVggW3OmhdtaA1xteZwi2Q==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"2", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (2.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.5ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 2 WHERE `events`.`event_id` = 1[0m
  [1m[35m (6.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 46ms (ActiveRecord: 15.5ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 13:35:26 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1431ms (Views: 1131.7ms | ActiveRecord: 1.0ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:35:32 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (30.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (27.5ms)
  Rendered events/edit.html.erb within layouts/application (240.2ms)
Completed 200 OK in 1293ms (Views: 1080.9ms | ActiveRecord: 30.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:35:39 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"0RwpK191FoHM64y0ZnvG8Km/T03slcTkcjuwCJP71oPw9HVztapMj+wwf8BI66bvGkqXsdhgi7KwG2gSH6y41Q==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"30", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 30 WHERE `events`.`event_id` = 1[0m
  [1m[35m (3.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (25.5ms)
  Rendered events/edit.html.erb within layouts/application (197.1ms)
Completed 200 OK in 1339ms (Views: 1311.1ms | ActiveRecord: 10.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:35:56 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"ViXNa4DJKkri2Kc+XN0CeFnnGcR44f6Ci4v8UwXC01Vqtwn5A1w9KADULtP9bR+JFBLXSkXMGEG0sY163qi4lQ==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"30", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2013", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (19.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 99ms (ActiveRecord: 22.0ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 13:35:56 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (18.0ms)
Completed 200 OK in 1600ms (Views: 1414.3ms | ActiveRecord: 1.0ms)


  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events" for 127.0.0.1 at 2017-12-03 13:39:13 -0500
Started GET "/events" for 127.0.0.1 at 2017-12-03 13:39:14 -0500
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (8.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (26.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  [1m[36mEvent Load (29.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (209.1ms)
  Rendered events/index.html.erb within layouts/application (244.1ms)
Completed 200 OK in 4400ms (Views: 4186.9ms | ActiveRecord: 34.5ms)


Completed 200 OK in 4429ms (Views: 4146.4ms | ActiveRecord: 52.5ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:40:55 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (9.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (160.4ms)
  Rendered events/edit.html.erb within layouts/application (390.0ms)
Completed 200 OK in 1780ms (Views: 1508.7ms | ActiveRecord: 12.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:41:02 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Zm5ZF6elPOTO4CfpJ5YJR0cAqzXJ2TxluPOQlKhpl8tHhgVPTXpm6u471J0JBmlY9PVzyf0sczN600iOJD75nQ==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (20.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (31.0ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 78 WHERE `events`.`event_id` = 1[0m
  [1m[35m (54.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (18.0ms)
  Rendered events/edit.html.erb within layouts/application (196.6ms)
Completed 200 OK in 1546ms (Views: 1311.5ms | ActiveRecord: 107.6ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:41:17 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"r4pz/EiSptXCcbplD+BVvE7fZEfmEckO7FVEWwCeyT+TGLduywextyB9M4iuUEhNAyqqyds8L83TbzVy2/Si/w==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"4", "max_attending"=>"60", "event_date(1i)"=>"2013", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (29.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (28.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (28.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (16.0ms)
  Rendered events/edit.html.erb within layouts/application (154.1ms)
Completed 200 OK in 1159ms (Views: 928.0ms | ActiveRecord: 85.6ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:41:45 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"GMKwHJIooR1eyXWiRp03XKQcVD65Qyf2tNBm5xQqeCAkUHSOEb22f7zF/E/nLSqt6emasIRuwTWL6hfOz0AT4A==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2013", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (8.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (39.0ms)
  Rendered events/edit.html.erb within layouts/application (289.7ms)
Completed 200 OK in 1506ms (Views: 1463.0ms | ActiveRecord: 11.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:41:52 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Iu9USdBqHWyzYmqCiaFl1RAvIKWWBqqbgL3yRSYJWY0efZDbU/8KDlFu428oEXgkXdruK6srTFi/h4Ns/WMyTQ==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (32.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (38.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (17.0ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 78, `max_guests_per_person` = NULL WHERE `events`.`event_id` = 1[0m
  [1m[35m (5.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (17.5ms)
  Rendered events/edit.html.erb within layouts/application (152.1ms)
Completed 200 OK in 1387ms (Views: 1232.0ms | ActiveRecord: 93.6ms)


  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:43:52 -0500
  [1m[35m (15.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"FZzqCqb1xsG7UKoQi6YGrdlKpiZV9uW7yDRT264p31QpDi6YJWDRo1lcI/0qFhtclL9oqGjbA3j3DiLydUO0lA==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (0.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.5ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 78, `max_guests_per_person` = NULL WHERE `events`.`event_id` = 1[0m
  [1m[35m (6.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (167.1ms)
  Rendered events/edit.html.erb within layouts/application (392.3ms)
Completed 200 OK in 3140ms (Views: 3032.9ms | ActiveRecord: 16.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:44:34 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"iBlSx57kNQOAkGHO0R0qwNmOVwCeeY5AlncQ198l7j+0i5ZVHXEiYWKc6CNwrTcxlHuZjqNUaIOpTWH+BE+F/w==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (2.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.5ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 78, `max_guests_per_person` = NULL WHERE `events`.`event_id` = 1[0m
  [1m[35m (6.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (13.5ms)
  Rendered events/edit.html.erb within layouts/application (137.6ms)
Completed 200 OK in 811ms (Views: 756.3ms | ActiveRecord: 14.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:44:54 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"9xsgK5wZVzw2kpUB41eSq3gnEKjh7pzspPOtHs4RmfnLieS5H4xAXtSeHOxC549aNdLeJtzDei+bydw3FXvyOQ==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"1", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (3.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 1, `max_guests_per_person` = NULL WHERE `events`.`event_id` = 1[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/events/1
Completed 302 Found in 215ms (ActiveRecord: 13.0ms)


Started GET "/events/1" for 127.0.0.1 at 2017-12-03 13:44:54 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (2.0ms)
Completed 200 OK in 706ms (Views: 528.4ms | ActiveRecord: 2.0ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 13:46:21 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (3.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (105.1ms)
Completed 200 OK in 2146ms (Views: 1923.4ms | ActiveRecord: 3.0ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:46:26 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (0.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (7.5ms)
  Rendered events/edit.html.erb within layouts/application (74.5ms)
Completed 200 OK in 716ms (Views: 548.7ms | ActiveRecord: 0.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:46:30 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"GhcQGodrOBPOHbwdbD1hEcZHj7+9fBln0+7MbVSSiVc7/0xCbbRiHe7GT2lCrQEOdbJXQ4mJVjERzhR32MXnAQ==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"1", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2013", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (41.5ms)
  Rendered events/edit.html.erb within layouts/application (355.8ms)
Completed 200 OK in 1574ms (Views: 1551.1ms | ActiveRecord: 2.5ms)


  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events" for 127.0.0.1 at 2017-12-03 13:48:46 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (26.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (175.5ms)
Completed 200 OK in 2257ms (Views: 2089.8ms | ActiveRecord: 32.1ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:49:42 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (158.6ms)
  Rendered events/edit.html.erb within layouts/application (362.8ms)
Completed 200 OK in 1452ms (Views: 1270.9ms | ActiveRecord: 4.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:49:47 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"LNjVNsCNpVQdo5BBcy0I3R9yHdIaXPA61uyKx3dhBAQNMIluKlL/Wj14YzVdvWjCrIfFLi6pv2wUzFLd+zZqUg==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"1", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2013", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (20.0ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (10.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (13.5ms)
  Rendered events/edit.html.erb within layouts/application (89.6ms)
Completed 200 OK in 972ms (Views: 862.7ms | ActiveRecord: 31.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:50:02 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Pysj7BUdI8cszdsfXNCZe1Z5c0wduQjSUv63u41HISwDued+log0pc7BUvL9YISKG4y9wiCU7hFtxMaSVi1K7A==", "event"=>{"event_id"=>"2", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"1", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (11.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[33mUPDATE `events` SET `event_id` = 2 WHERE `events`.`event_id` = 1[0m
  [1m[35m (14.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (23.7ms)
  Rendered events/edit.html.erb within layouts/application (257.7ms)
Completed 200 OK in 1381ms (Views: 1311.9ms | ActiveRecord: 31.5ms)


  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (29.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started PATCH "/events/2" for 127.0.0.1 at 2017-12-03 13:55:21 -0500
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"kbPcC9AgKGMWf1lysHrG39yWvB2UT3SNW4h6sxbH33ytIRiZU7U/AfRz0J8RytsukWNyk6likk5ksguaza20vA==", "event"=>{"event_id"=>"2", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"1", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"2"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 2 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[33mUPDATE `events` SET `title` = 'Amazon River Lecture', `managing_employee` = 1, `max_guests_per_person` = NULL, `event_date` = '2018-01-01 19:00:00' WHERE `events`.`event_id` = 2[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/events/2
Completed 302 Found in 183ms (ActiveRecord: 16.5ms)


Started GET "/events/2" for 127.0.0.1 at 2017-12-03 13:55:52 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"2"}
  [1m[36mEvent Load (0.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 2 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (5.0ms)
Completed 200 OK in 824ms (Views: 756.0ms | ActiveRecord: 0.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-03 13:56:05 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (24.0ms)
Completed 200 OK in 879ms (Views: 727.3ms | ActiveRecord: 1.5ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-03 13:56:20 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (148.3ms)
  Rendered events/edit.html.erb within layouts/application (293.7ms)
Completed 200 OK in 1289ms (Views: 1145.9ms | ActiveRecord: 1.5ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:56:25 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"YSJ93HkrCudh9tqhv6TMjc8FBf5Vzz0v+th+fqRRdzBAyiGEk/RQ6UEtKdWRNKySfPDdAmE6cnk4+KZkKAYZZg==", "event"=>{"event_id"=>"1", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.0ms)[0m  [1m[33mUPDATE `events` SET `managing_employee` = 78 WHERE `events`.`event_id` = 1[0m
  [1m[35m (6.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (41.5ms)
  Rendered events/edit.html.erb within layouts/application (251.2ms)
Completed 200 OK in 1494ms (Views: 1443.5ms | ActiveRecord: 16.0ms)


Started PATCH "/events/1" for 127.0.0.1 at 2017-12-03 13:57:16 -0500
Processing by EventsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"d6RZcc6xqbiZilzdB7dtGmR1Xh/uGrurbKR64pvEL61LNp3jTSS+2nuG1TCmB3DrKYCQkdM3XWhTngvLQK5EbQ==", "event"=>{"event_id"=>"2", "title"=>"Amazon River Lecture", "price"=>"15.0", "managing_employee"=>"78", "max_guests_per_person"=>"", "max_attending"=>"60", "event_date(1i)"=>"2018", "event_date(2i)"=>"1", "event_date(3i)"=>"1", "event_date(4i)"=>"19", "event_date(5i)"=>"00"}, "commit"=>"Update Event", "id"=>"1"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[33mUPDATE `events` SET `event_id` = 2, `managing_employee` = 78 WHERE `events`.`event_id` = 1[0m
  [1m[35m (6.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/edit.html.erb within layouts/application
  Rendered events/_form.html.erb (26.0ms)
  Rendered events/edit.html.erb within layouts/application (231.2ms)
Completed 200 OK in 1684ms (Views: 1553.2ms | ActiveRecord: 13.0ms)


  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to AnimalChangeTankToTankId (20171203223317)
  [1m[35m (27.6ms)[0m  [1m[35mALTER TABLE `animals` CHANGE `tank` `tank_id` int(11) NOT NULL[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171203223317')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/animals" for 127.0.0.1 at 2017-12-03 17:59:32 -0500
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (53.7ms)
Completed 200 OK in 391ms (Views: 316.0ms | ActiveRecord: 2.7ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-12-03 17:59:37 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mTank Load (0.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  [1m[36mCACHE Tank Load (0.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered animals/_form.html.erb (57.0ms)
  Rendered animals/new.html.erb within layouts/application (59.5ms)
Completed 200 OK in 85ms (Views: 79.4ms | ActiveRecord: 1.8ms)


Started GET "/animals/1/edit" for 127.0.0.1 at 2017-12-03 17:59:42 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (0.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  [1m[36mCACHE Tank Load (0.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered animals/_form.html.erb (10.2ms)
  Rendered animals/edit.html.erb within layouts/application (12.5ms)
Completed 200 OK in 60ms (Views: 53.4ms | ActiveRecord: 0.8ms)


Started PATCH "/animals/1" for 127.0.0.1 at 2017-12-03 17:59:47 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"sUP/t7+8/k6N4SORi05avrn0o9Vs621Sx8ISw9GKAujm7hN/gRcQBukWk85w80XNAo6KXmhb8QF+NsKxvzdPYQ==", "animal"=>{"animal_id"=>"1", "name"=>"", "species"=>"Piranha", "tank_id"=>"5", "birth_date(1i)"=>"2010", "birth_date(2i)"=>"1", "birth_date(3i)"=>"18", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"1"}
  [1m[36mAnimal Load (0.3ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
Unpermitted parameter: :tank_id
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (0.7ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals/1
Completed 302 Found in 17ms (ActiveRecord: 1.3ms)


Started GET "/animals/1" for 127.0.0.1 at 2017-12-03 17:59:47 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (0.2ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (0.7ms)
Completed 200 OK in 24ms (Views: 21.0ms | ActiveRecord: 0.2ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-03 17:59:51 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (50.0ms)
Completed 200 OK in 71ms (Views: 69.3ms | ActiveRecord: 0.4ms)


  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (45.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (11.9ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (9.2ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.1ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (7.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (12.2ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.8ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (8.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) NOT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (9.3ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.7ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (8.6ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.6ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (12.1ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (11.8ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.3ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m        -- ------------------------------------------
        -- Register a member for an event
        -- ------------------------------------------
        CREATE PROCEDURE registerForEvent(memID int, eventNo int, guests int)

          BEGIN 
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;
          DECLARE maxGuestsPerP INT DEFAULT 0;
          DECLARE maxGuestsTotal INT DEFAULT 0;
          DECLARE guestsSoFar INT DEFAULT 0;
          DECLARE registeredAlready INT DEFAULT 0;

          SET registeredAlready = (SELECT count(*) FROM eventRegistrations where eventNo = event AND memID = member);
          SET maxGuestsPerP = (SELECT max_guests_per_person FROM events where eventID = eventNo);
          SET maxGuestsTotal = (SELECT max_guests_per_person FROM events where eventID = eventNo);
          SET guestsSoFar = memsRegistered(eventNo);
          BEGIN
          -- Error handler setups
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

          IF (guests >= maxGuestsPerP) THEN
            SELECT CONCAT('Guests exceed maximum allowed. Up to ', maxGuestsPerP, ' permitted.') as 'result';
          ELSEIF (guestsSoFar + guests > maxGuestsTotal) THEN
            SELECT CONCAT('Not enough spaces available to register this member and their ', guests, ' guests.') as 'result';
          ELSEIF (registeredAlready != 0) THEN
            SELECT CONCAT('Member ', memID, ' already registered for event ', eventNo) as 'result';
          ELSE
          INSERT INTO EventRegistrations (time, member, event, guestCount) 
            VALUES (NOW(), memID, eventNo, guests);
          SELECT CONCAT('Registration complete.') AS 'result';  
          END IF;
          END;

          IF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Registration not logged.') AS 'result';    
            END IF;

          END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event OR eID is NULL) AND 
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (13.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (12.7ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AnimalChangeTankToTankId (20171203223317)
  [1m[35m (9.0ms)[0m  [1m[35mALTER TABLE `animals` CHANGE `tank` `tank_id` int(11) NOT NULL[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171203223317')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 03:29:01', '2017-12-04 03:29:01')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.6ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to RenameForeignKeyColumnsInTreatmentLog (20171204034226)
  [1m[35m (12.8ms)[0m  [1m[35mALTER TABLE `treatment_logs` CHANGE `animal` `animal_id` int(11) DEFAULT NULL[0m
  [1m[35m (7.1ms)[0m  [1m[35mALTER TABLE `treatment_logs` CHANGE `employee` `employee_id` int(11) DEFAULT NULL[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171204034226')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 04:33:42', '2017-12-04 04:33:42')[0m
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (26.4ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.6ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (9.0ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (9.4ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (7.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (7.7ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.7ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (9.8ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) NOT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.8ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (8.5ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (12.3ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date != NULL AND (SELECT COUNT(*) FROM events where New.employee_id = managing_employee) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (11.5ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (14.1ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.1ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.4ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.8ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END;
[0m
  [1m[35m (0.7ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.8ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.1ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event OR eID is NULL) AND 
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (13.3ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event = New.event);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member NOT IN (SELECT member_id from members) THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event NOT IN (SELECT event_id from events) THEN 
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuests THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
[0m
  [1m[35m (4.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 04:45:26', '2017-12-04 04:45:26')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (22.9ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (11.8ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (8.7ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (6.9ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (8.6ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.2ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.9ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (8.3ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) NOT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (10.2ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (9.6ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (9.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.4ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (11.1ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date != NULL AND (SELECT COUNT(*) FROM events where New.employee_id = managing_employee) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (13.4ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (12.1ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (11.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.3ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event OR eID is NULL) AND 
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (12.4ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (17.1ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event = New.event);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member NOT IN (SELECT member_id from members) THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event NOT IN (SELECT event_id from events) THEN 
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (10.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (15.7ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AnimalChangeTankToTankId (20171203223317)
  [1m[35m (9.1ms)[0m  [1m[35mALTER TABLE `animals` CHANGE `tank` `tank_id` int(11) NOT NULL[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171203223317')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to RenameForeignKeyColumnsInTreatmentLog (20171204034226)
  [1m[35m (9.6ms)[0m  [1m[35mALTER TABLE `treatment_logs` CHANGE `animal` `animal_id` int(11) DEFAULT NULL[0m
  [1m[35m (8.9ms)[0m  [1m[35mALTER TABLE `treatment_logs` CHANGE `employee` `employee_id` int(11) DEFAULT NULL[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171204034226')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.6ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 04:45:35', '2017-12-04 04:45:35')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to RenameEmployeeAndTankInFeedingLogToAddId (20171204051335)
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (41.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.9ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (8.2ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (9.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (10.8ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (12.0ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.0ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (8.9ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) NOT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (12.7ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (14.5ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (11.3ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.9ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.6ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (11.8ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date != NULL AND (SELECT COUNT(*) FROM events where New.employee_id = managing_employee) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (12.2ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (12.8ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (12.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.3ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event OR eID is NULL) AND 
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (15.7ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (14.5ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event = New.event);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member NOT IN (SELECT member_id from members) THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event NOT IN (SELECT event_id from events) THEN 
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (13.7ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (13.3ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AnimalChangeTankToTankId (20171203223317)
  [1m[35m (6.7ms)[0m  [1m[35mALTER TABLE `animals` CHANGE `tank` `tank_id` int(11) NOT NULL[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171203223317')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to RenameForeignKeyColumnsInTreatmentLog (20171204034226)
  [1m[35m (7.2ms)[0m  [1m[35mALTER TABLE `treatment_logs` CHANGE `animal` `animal_id` int(11) DEFAULT NULL[0m
  [1m[35m (6.4ms)[0m  [1m[35mALTER TABLE `treatment_logs` CHANGE `employee` `employee_id` int(11) DEFAULT NULL[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171204034226')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to RenameEmployeeAndTankInFeedingLogToAddId (20171204051335)
  [1m[35m (7.1ms)[0m  [1m[35mALTER TABLE `feeding_logs` CHANGE `tank` `tank_id` int(11) DEFAULT NULL[0m
  [1m[35m (6.8ms)[0m  [1m[35mALTER TABLE `feeding_logs` CHANGE `employee` `employee_id` int(11) NOT NULL[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171204051335')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 05:15:14', '2017-12-04 05:15:14')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-04 00:17:48 -0500
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (0.7ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (1840.7ms)
Completed 200 OK in 2100ms (Views: 2082.2ms | ActiveRecord: 1.7ms)


Started GET "/feeding_logs/new" for 127.0.0.1 at 2017-12-04 00:17:59 -0500
Processing by FeedingLogsController#new as HTML
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEmployee Load (0.7ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered feeding_logs/_form.html.erb (65.7ms)
  Rendered feeding_logs/new.html.erb within layouts/application (68.2ms)
Completed 200 OK in 91ms (Views: 85.2ms | ActiveRecord: 2.9ms)


Started POST "/feeding_logs" for 127.0.0.1 at 2017-12-04 00:18:24 -0500
Processing by FeedingLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"6qySpaGjpiCrVsCL9EEdYxxGU7nZr9blUdgbTPFKoB/RmEX7FZFgj3vApHOP1SGbHt/ehVGCy+nJodhB3bqnkg==", "feeding_log"=>{"feeding_id"=>"555", "time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"4", "time(4i)"=>"05", "time(5i)"=>"17", "food"=>"filet mignon", "quantity"=>"4", "employee_id"=>"4", "tank_id"=>"7"}, "commit"=>"Create Feeding log"}
Completed 500 Internal Server Error in 7ms (ActiveRecord: 0.0ms)


  
NameError (uninitialized constant FeedingLog::EmployeeId):
  
app/controllers/feeding_logs_controller.rb:27:in `create'
Started POST "/feeding_logs" for 127.0.0.1 at 2017-12-04 00:22:47 -0500
Processing by FeedingLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Z+b5zNytWmTmkC5uz0CL2EI22eXmlO5FuA2Kr3dye/CJwvOXBo6MU58lQU2nFoclhJzlSBSfjtyzJLGoXuanmQ==", "feeding_log"=>{"feeding_id"=>"888", "time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"4", "time(4i)"=>"05", "time(5i)"=>"09", "food"=>"fish", "quantity"=>"99", "employee_id"=>"4", "tank_id"=>"4"}, "commit"=>"Create Feeding log"}
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEmployee Load (0.3ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 4 LIMIT 1[0m
  [1m[36mTank Load (0.2ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 4 LIMIT 1[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `feeding_logs` (`feeding_id`, `time`, `food`, `quantity`, `employee_id`, `tank_id`) VALUES (888, '2017-12-04 05:09:00', 'fish', 99.0, 4, 4)[0m
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/feeding_logs/888
Completed 302 Found in 71ms (ActiveRecord: 5.8ms)


Started GET "/feeding_logs/888" for 127.0.0.1 at 2017-12-04 00:22:47 -0500
Processing by FeedingLogsController#show as HTML
  Parameters: {"id"=>"888"}
  [1m[36mFeedingLog Load (0.3ms)[0m  [1m[34mSELECT  `feeding_logs`.* FROM `feeding_logs` WHERE `feeding_logs`.`feeding_id` = 888 LIMIT 1[0m
  Rendering feeding_logs/show.html.erb within layouts/application
  Rendered feeding_logs/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 32ms (Views: 28.2ms | ActiveRecord: 0.3ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-04 00:22:52 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (0.6ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (105.7ms)
Completed 200 OK in 139ms (Views: 136.3ms | ActiveRecord: 0.6ms)


Started GET "/feeding_logs/new" for 127.0.0.1 at 2017-12-04 00:22:57 -0500
Processing by FeedingLogsController#new as HTML
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (0.3ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered feeding_logs/_form.html.erb (8.9ms)
  Rendered feeding_logs/new.html.erb within layouts/application (10.7ms)
Completed 200 OK in 54ms (Views: 50.4ms | ActiveRecord: 0.7ms)


Started POST "/feeding_logs" for 127.0.0.1 at 2017-12-04 00:23:08 -0500
Processing by FeedingLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"ZBMgiPcY0RwJVpAym6Fu7y+VGiiubOduU80zgxIB7O5fJ/fWQyoXs9nA9MrgNVIXLQyXFCZB+mLLtPCOPvHrYw==", "feeding_log"=>{"feeding_id"=>"3333", "time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"4", "time(4i)"=>"05", "time(5i)"=>"22", "food"=>"filet mignon", "quantity"=>"3", "employee_id"=>"1", "tank_id"=>"1"}, "commit"=>"Create Feeding log"}
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEmployee Load (0.3ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[36mTank Load (0.2ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `feeding_logs` (`feeding_id`, `time`, `food`, `quantity`, `employee_id`, `tank_id`) VALUES (3333, '2017-12-04 05:22:00', 'filet mignon', 3.0, 1, 1)[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/feeding_logs/3333
Completed 302 Found in 22ms (ActiveRecord: 1.2ms)


Started GET "/feeding_logs/3333" for 127.0.0.1 at 2017-12-04 00:23:08 -0500
Processing by FeedingLogsController#show as HTML
  Parameters: {"id"=>"3333"}
  [1m[36mFeedingLog Load (0.3ms)[0m  [1m[34mSELECT  `feeding_logs`.* FROM `feeding_logs` WHERE `feeding_logs`.`feeding_id` = 3333 LIMIT 1[0m
  Rendering feeding_logs/show.html.erb within layouts/application
  Rendered feeding_logs/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 23ms (Views: 20.8ms | ActiveRecord: 0.3ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-04 00:23:12 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (0.9ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (192.1ms)
Completed 200 OK in 229ms (Views: 226.1ms | ActiveRecord: 0.9ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-04 00:23:37 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (44.0ms)
Completed 200 OK in 68ms (Views: 63.2ms | ActiveRecord: 1.1ms)


  [1m[35m (2.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to RenameForeignKeysInEventRegistration (20171204061132)
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to RenameForeignKeysInEventRegistration (20171204061132)
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to RenameForeignKeysInEventRegistration (20171204061132)
  [1m[35m (10.2ms)[0m  [1m[35mALTER TABLE `event_registrations` CHANGE `member` `member_id` int(11) NOT NULL[0m
  [1m[35m (7.1ms)[0m  [1m[35mALTER TABLE `event_registrations` CHANGE `event` `event_id` int(11) NOT NULL[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171204061132')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/event_registrations" for 127.0.0.1 at 2017-12-04 01:16:37 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (0.8ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (14.9ms)
Completed 200 OK in 281ms (Views: 269.3ms | ActiveRecord: 1.8ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-04 01:16:41 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[35m (8.9ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mMember Load (1.0ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (0.8ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (75.8ms)
  Rendered event_registrations/new.html.erb within layouts/application (77.7ms)
Completed 200 OK in 101ms (Views: 79.0ms | ActiveRecord: 20.2ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-04 01:16:46 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"gnMREmQEu5IU2PNki/eR7iVetvbVSJlNcPHOGoUI6FRXDDL9oNuYHHgBHb3jBDBXK/xiuG+7gs4DKUiyNpG5MA==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-04 01:16:42 -0500", "member_id"=>"27", "event_id"=>"5", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.3ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-04 06:16:42', 27, 5, 1)[0m
  [1m[35m (0.1ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (0.4ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (0.4ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (8.2ms)
  Rendered event_registrations/new.html.erb within layouts/application (10.0ms)
Completed 200 OK in 38ms (Views: 32.5ms | ActiveRecord: 2.3ms)


  [1m[35m (2.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (46.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (10.2ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (9.5ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (8.3ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (7.8ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.3ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.9ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (7.0ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) NOT NULL,
        tank int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.4ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee int(11) DEFAULT NULL,
        animal int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (6.5ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (8.4ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member int(11) NOT NULL,
        event int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event),
        KEY memberRegistering (member),
        CONSTRAINT fk_event_registration FOREIGN KEY (event) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (13.3ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date != NULL AND (SELECT COUNT(*) FROM events where New.employee_id = managing_employee) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (11.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.1ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.1ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (11.2ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (12.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.3ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.2ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event OR eID is NULL) AND
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (12.8ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event = New.event);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (2.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 06:29:41', '2017-12-04 06:29:41')[0m
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.7ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (23.3ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (9.3ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (8.9ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (9.0ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.0ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (6.9ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (8.4ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.3ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.4ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (7.4ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (12.8ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date != NULL AND (SELECT COUNT(*) FROM events where New.employee_id = managing_employee) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (12.5ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (11.2ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (13.7ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.3ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.2ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event OR eID is NULL) AND
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (11.4ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (1.2ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event = New.event);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 06:31:24', '2017-12-04 06:31:24')[0m
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (24.4ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.4ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (8.0ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (10.8ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (8.6ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.7ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.9ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (8.0ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.4ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.0ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (12.2ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date != NULL AND (SELECT COUNT(*) FROM events where New.employee_id = managing_employee) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (11.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (12.5ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.4ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.8ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.2ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event OR eID is NULL) AND
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (11.1ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (12.3ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event = New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (11.7ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (10.8ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 06:31:28', '2017-12-04 06:31:28')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:42:06 -0500
Processing by TanksController#index as HTML
Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:42:16 -0500
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (17.8ms)
Completed 200 OK in 67ms (Views: 48.5ms | ActiveRecord: 1.1ms)


Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (11.2ms)
Completed 200 OK in 37ms (Views: 31.9ms | ActiveRecord: 0.3ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-04 01:42:21 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (0.6ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (33.8ms)
  Rendered tanks/new.html.erb within layouts/application (36.8ms)
Completed 200 OK in 97ms (Views: 81.4ms | ActiveRecord: 11.9ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-04 01:42:41 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (0.4ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (5.6ms)
  Rendered tanks/new.html.erb within layouts/application (7.3ms)
Completed 200 OK in 31ms (Views: 28.9ms | ActiveRecord: 0.4ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-04 01:43:20 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"5FNhztrbz0iBdLD9qESMM9K2y/SonOp6evTh9LIxzzgKd2uVAPgZf/jB397AEoDOFBz3WVqXiuNx3drzm6UTUQ==", "tank"=>{"tank_id"=>"", "name"=>"Great Lakes", "description"=>"The fish of the great lakes", "volume"=>"500", "temperature"=>"55", "year_built"=>"2011", "habitat_id"=>"2"}, "water_type"=>"fresh", "commit"=>"Create Tank"}
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 2 LIMIT 1[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES ('Great Lakes', 'The fish of the great lakes', 500.0, 55.0, 2011, 2)[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/15
Completed 302 Found in 16ms (ActiveRecord: 1.1ms)


Started GET "/tanks/15" for 127.0.0.1 at 2017-12-04 01:43:20 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 26ms (Views: 23.1ms | ActiveRecord: 0.3ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:43:25 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (6.0ms)
Completed 200 OK in 53ms (Views: 51.1ms | ActiveRecord: 0.3ms)


Started GET "/tanks/15/edit" for 127.0.0.1 at 2017-12-04 01:43:27 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (6.3ms)
  Rendered tanks/edit.html.erb within layouts/application (8.5ms)
Completed 200 OK in 55ms (Views: 51.5ms | ActiveRecord: 0.7ms)


Started PATCH "/tanks/15" for 127.0.0.1 at 2017-12-04 01:43:30 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"hFyfDni83rNirC7o2rYxtmWCsnBAgHoi2w8X+wXg5QajU2WsTRK6fjd8kGVzlfd/BOD1j2FbLzFQXCvCns1pRQ==", "tank"=>{"tank_id"=>"15", "name"=>"Great Lakes", "description"=>"The fish of the great lakes", "volume"=>"500.0", "temperature"=>"55.0", "year_built"=>"2011", "habitat_id"=>"2"}, "water_type"=>"salt", "commit"=>"Update Tank", "id"=>"15"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 2 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/15
Completed 302 Found in 5ms (ActiveRecord: 0.8ms)


Started GET "/tanks/15" for 127.0.0.1 at 2017-12-04 01:43:30 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 24ms (Views: 20.8ms | ActiveRecord: 0.4ms)


Started GET "/tanks/15/edit" for 127.0.0.1 at 2017-12-04 01:43:40 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (4.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (12.0ms)
  Rendered tanks/edit.html.erb within layouts/application (15.2ms)
Completed 200 OK in 69ms (Views: 59.7ms | ActiveRecord: 4.8ms)


Started PATCH "/tanks/15" for 127.0.0.1 at 2017-12-04 01:43:43 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"3QLLQjTJmyyhfwHQ0xuGeS1yLhtQ5uc1YTA/irKwxzv6DTHgAWf/4fSvv116OECwTBBp5HE9sibqYwOzKZ1LeA==", "tank"=>{"tank_id"=>"15", "name"=>"Great Lakes", "description"=>"The fish of the great lakes", "volume"=>"500.0", "temperature"=>"55.0", "year_built"=>"2011", "habitat_id"=>"2"}, "water_type"=>"salt", "commit"=>"Update Tank", "id"=>"15"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.2ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 2 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/15
Completed 302 Found in 4ms (ActiveRecord: 0.8ms)


Started GET "/tanks/15" for 127.0.0.1 at 2017-12-04 01:43:43 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (0.9ms)
Completed 200 OK in 25ms (Views: 21.1ms | ActiveRecord: 0.4ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:43:45 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (5.5ms)
Completed 200 OK in 54ms (Views: 51.7ms | ActiveRecord: 0.3ms)


Started GET "/tanks/11/edit" for 127.0.0.1 at 2017-12-04 01:44:05 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"11"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (4.6ms)
  Rendered tanks/edit.html.erb within layouts/application (7.3ms)
Completed 200 OK in 45ms (Views: 41.7ms | ActiveRecord: 0.6ms)


Started PATCH "/tanks/11" for 127.0.0.1 at 2017-12-04 01:44:08 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"/6NP7CW2md5PVtvZUYmdBTA1EggHALoV8OVwSA3iVSZEtXn7CSiJ0HsZ2rj41qhFJo2ChpaLbJgd5FvCjymtvA==", "tank"=>{"tank_id"=>"11", "name"=>"Carribean Shallows", "description"=>"Closer to the surface, Carribean coral reefs are home to slow moving turtles and quick barracudas.", "volume"=>"10000.0", "temperature"=>"75.0", "year_built"=>"2016", "habitat_id"=>"3"}, "water_type"=>"salt", "commit"=>"Update Tank", "id"=>"11"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 3 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/11
Completed 302 Found in 4ms (ActiveRecord: 0.8ms)


Started GET "/tanks/11" for 127.0.0.1 at 2017-12-04 01:44:08 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"11"}
  [1m[36mTank Load (0.2ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 23ms (Views: 21.4ms | ActiveRecord: 0.2ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:44:11 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (5.9ms)
Completed 200 OK in 66ms (Views: 63.7ms | ActiveRecord: 0.4ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-04 01:44:15 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.9ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (8.2ms)
  Rendered tanks/edit.html.erb within layouts/application (10.4ms)
Completed 200 OK in 60ms (Views: 56.2ms | ActiveRecord: 1.2ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-04 01:44:18 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"YhFPFJ/R+wnl9BphWiBvG3pug+AfNSlB8aIeroX156PjYRfR5R0kWhrWdaWfh2gQbRAlYvGBHlod+2pVBA8NPg==", "tank"=>{"tank_id"=>"1", "name"=>"River", "description"=>"Meet the menacing inhabitants of the Amazon River!", "volume"=>"2000.0", "temperature"=>"76.0", "year_built"=>"2015", "habitat_id"=>"1"}, "water_type"=>"salt", "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.2ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/1
Completed 302 Found in 4ms (ActiveRecord: 0.7ms)


Started GET "/tanks/1" for 127.0.0.1 at 2017-12-04 01:44:18 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 25ms (Views: 22.7ms | ActiveRecord: 0.3ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:44:21 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (6.0ms)
Completed 200 OK in 55ms (Views: 52.7ms | ActiveRecord: 0.3ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-04 01:44:23 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (4.6ms)
  Rendered tanks/edit.html.erb within layouts/application (7.3ms)
Completed 200 OK in 52ms (Views: 49.5ms | ActiveRecord: 0.6ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:44:27 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (6.9ms)
Completed 200 OK in 63ms (Views: 60.7ms | ActiveRecord: 0.4ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-04 01:44:29 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (8.1ms)
  Rendered tanks/edit.html.erb within layouts/application (11.3ms)
Completed 200 OK in 61ms (Views: 56.1ms | ActiveRecord: 0.8ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-04 01:44:30 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"iZSES8CWLAu3n7nrQ+BDRI0xXQqZVqEVvneMIcTMcq4I5NyOulrzWEi91i+GR0RPmk/7iHfilg5SLvjaRTaYMw==", "tank"=>{"tank_id"=>"1", "name"=>"River", "description"=>"Meet the menacing inhabitants of the Amazon River!", "volume"=>"2000.0", "temperature"=>"76.0", "year_built"=>"2015", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.2ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/1
Completed 302 Found in 4ms (ActiveRecord: 0.7ms)


Started GET "/tanks/1" for 127.0.0.1 at 2017-12-04 01:44:30 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (0.2ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (1.3ms)
Completed 200 OK in 24ms (Views: 22.0ms | ActiveRecord: 0.2ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:44:33 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (8.1ms)
Completed 200 OK in 63ms (Views: 60.3ms | ActiveRecord: 0.3ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:47:04 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (7.4ms)
Completed 200 OK in 38ms (Views: 36.5ms | ActiveRecord: 0.3ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-04 01:47:09 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (0.2ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (1.6ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (11.3ms)
  Rendered tanks/edit.html.erb within layouts/application (14.5ms)
Completed 200 OK in 81ms (Views: 75.5ms | ActiveRecord: 1.8ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-04 01:47:11 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"1bxZvgRpoI2fwuyyU7UBLqFeu8CQSfTZPt5XiRk48ZtUzAF7fqV/3mDgg3aWEgYltiAdQn79w8LShyNymMIbBg==", "tank"=>{"tank_id"=>"1", "name"=>"River", "description"=>"Meet the menacing inhabitants of the Amazon River!", "water_type"=>"salt", "volume"=>"2000.0", "temperature"=>"76.0", "year_built"=>"2015", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.2ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (0.3ms)[0m  [1m[33mUPDATE `tanks` SET `water_type` = 'salt' WHERE `tanks`.`tank_id` = 1[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/1
Completed 302 Found in 6ms (ActiveRecord: 1.3ms)


Started GET "/tanks/1" for 127.0.0.1 at 2017-12-04 01:47:11 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (0.2ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (0.9ms)
Completed 200 OK in 26ms (Views: 23.2ms | ActiveRecord: 0.2ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:47:13 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (12.6ms)
Completed 200 OK in 61ms (Views: 57.3ms | ActiveRecord: 0.3ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-04 01:47:15 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (0.4ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (6.5ms)
  Rendered tanks/new.html.erb within layouts/application (9.2ms)
Completed 200 OK in 55ms (Views: 52.4ms | ActiveRecord: 0.4ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-04 01:47:25 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"K73mk5IXRKMJR+3JlerdNb7epJO2FqXajWkQUjVccsAhldx6hSyMwxJQSofl39k7h64Cr2+jOgcc3GrONEVMjw==", "tank"=>{"tank_id"=>"", "name"=>"fskalfj", "description"=>"asfasfsa", "water_type"=>"fresh", "volume"=>"33", "temperature"=>"3", "year_built"=>"3", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES ('fskalfj', 'asfasfsa', 'fresh', 33.0, 3.0, 3, 1)[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/16
Completed 302 Found in 7ms (ActiveRecord: 1.3ms)


Started GET "/tanks/16" for 127.0.0.1 at 2017-12-04 01:47:25 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"16"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 16 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (1.2ms)
Completed 200 OK in 34ms (Views: 30.6ms | ActiveRecord: 0.3ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:47:27 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (7.2ms)
Completed 200 OK in 70ms (Views: 68.0ms | ActiveRecord: 0.4ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-04 01:47:30 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (0.4ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (6.0ms)
  Rendered tanks/new.html.erb within layouts/application (7.9ms)
Completed 200 OK in 57ms (Views: 54.0ms | ActiveRecord: 0.4ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-04 01:47:38 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"PGQsPW+nDCViYN0FfelT5Ws9RcSdJw6W3Rn5F4TCU+Y2TBbUeJzERXl3eksN3FfrUk3j+ESSkUtMrIOLhdttqQ==", "tank"=>{"tank_id"=>"", "name"=>"fdsaf", "description"=>"safsaf", "water_type"=>"salt", "volume"=>"3", "temperature"=>"5", "year_built"=>"5", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES ('fdsaf', 'safsaf', 'salt', 3.0, 5.0, 5, 1)[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/17
Completed 302 Found in 4ms (ActiveRecord: 0.9ms)


Started GET "/tanks/17" for 127.0.0.1 at 2017-12-04 01:47:38 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"17"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 17 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (0.7ms)
Completed 200 OK in 23ms (Views: 19.9ms | ActiveRecord: 0.3ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:47:41 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (7.5ms)
Completed 200 OK in 57ms (Views: 54.5ms | ActiveRecord: 0.4ms)


Started GET "/tanks/17/edit" for 127.0.0.1 at 2017-12-04 01:47:43 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"17"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 17 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.2ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (5.0ms)
  Rendered tanks/edit.html.erb within layouts/application (7.6ms)
Completed 200 OK in 49ms (Views: 46.8ms | ActiveRecord: 0.5ms)


Started PATCH "/tanks/17" for 127.0.0.1 at 2017-12-04 01:47:46 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"kv4us9V1FERyFaJmBa2S3FKGEvnE+dN7+J+NeaPU+K+ey/1LR+zzI1hBgIWGz81eZm6dVJx1VrwJQuh/pLFCCQ==", "tank"=>{"tank_id"=>"17", "name"=>"fdsaf", "description"=>"safsaf", "water_type"=>"fresh", "volume"=>"3.0", "temperature"=>"5.0", "year_built"=>"5", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"17"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 17 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.2ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (0.3ms)[0m  [1m[33mUPDATE `tanks` SET `water_type` = 'fresh' WHERE `tanks`.`tank_id` = 17[0m
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/17
Completed 302 Found in 6ms (ActiveRecord: 1.8ms)


Started GET "/tanks/17" for 127.0.0.1 at 2017-12-04 01:47:46 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"17"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 17 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (1.2ms)
Completed 200 OK in 38ms (Views: 35.1ms | ActiveRecord: 0.3ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:47:48 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (6.1ms)
Completed 200 OK in 57ms (Views: 54.5ms | ActiveRecord: 0.3ms)


Started GET "/tanks/16/edit" for 127.0.0.1 at 2017-12-04 01:47:50 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"16"}
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 16 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.8ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (8.7ms)
  Rendered tanks/edit.html.erb within layouts/application (11.5ms)
Completed 200 OK in 76ms (Views: 72.4ms | ActiveRecord: 1.2ms)


Started PATCH "/tanks/16" for 127.0.0.1 at 2017-12-04 01:47:51 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"8p9U1a9ErB0EkE0GYyZLwH5HbmFnRST3Dep5/1NyJ+kd2bvUGPRNHyVXtmRfTAUdcuiaqxQ7DzER2EjbRyYbYg==", "tank"=>{"tank_id"=>"16", "name"=>"fskalfj", "description"=>"asfasfsa", "water_type"=>"fresh", "volume"=>"33.0", "temperature"=>"3.0", "year_built"=>"3", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"16"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 16 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.2ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/16
Completed 302 Found in 5ms (ActiveRecord: 0.8ms)


Started GET "/tanks/16" for 127.0.0.1 at 2017-12-04 01:47:51 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"16"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 16 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 25ms (Views: 21.5ms | ActiveRecord: 0.3ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:47:53 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (6.3ms)
Completed 200 OK in 51ms (Views: 49.0ms | ActiveRecord: 0.3ms)


Started GET "/tanks/15/edit" for 127.0.0.1 at 2017-12-04 01:47:57 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.4ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (6.0ms)
  Rendered tanks/edit.html.erb within layouts/application (9.1ms)
Completed 200 OK in 69ms (Views: 64.8ms | ActiveRecord: 0.8ms)


Started PATCH "/tanks/15" for 127.0.0.1 at 2017-12-04 01:48:00 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"eUgjzvmO0mv5254DSWsmwwiYycnCem2hCbT1oDY6hbteR9lszCC2pqwLII7gSOAKafqONuOhOLKC58mZrRcJ+A==", "tank"=>{"tank_id"=>"15", "name"=>"Great Lakes", "description"=>"The fish of the great lakes", "water_type"=>"salt", "volume"=>"500.0", "temperature"=>"55.0", "year_built"=>"2011", "habitat_id"=>"2"}, "commit"=>"Update Tank", "id"=>"15"}
  [1m[36mTank Load (0.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 2 LIMIT 1[0m
  [1m[35mSQL (0.2ms)[0m  [1m[33mUPDATE `tanks` SET `water_type` = 'salt' WHERE `tanks`.`tank_id` = 15[0m
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/15
Completed 302 Found in 6ms (ActiveRecord: 1.9ms)


Started GET "/tanks/15" for 127.0.0.1 at 2017-12-04 01:48:00 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (0.7ms)
Completed 200 OK in 22ms (Views: 19.1ms | ActiveRecord: 0.3ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:48:02 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (7.0ms)
Completed 200 OK in 61ms (Views: 59.0ms | ActiveRecord: 0.5ms)


Started GET "/tanks/16/edit" for 127.0.0.1 at 2017-12-04 01:48:03 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"16"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 16 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.7ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (7.2ms)
  Rendered tanks/edit.html.erb within layouts/application (9.2ms)
Completed 200 OK in 58ms (Views: 53.9ms | ActiveRecord: 1.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:48:06 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (6.6ms)
Completed 200 OK in 36ms (Views: 33.6ms | ActiveRecord: 0.4ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-04 01:48:09 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (2.1ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (9.6ms)
  Rendered tanks/edit.html.erb within layouts/application (12.2ms)
Completed 200 OK in 72ms (Views: 66.4ms | ActiveRecord: 2.4ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:48:13 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.9ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (7.4ms)
Completed 200 OK in 32ms (Views: 29.6ms | ActiveRecord: 0.9ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-04 01:48:19 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (0.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (6.4ms)
  Rendered tanks/edit.html.erb within layouts/application (8.9ms)
Completed 200 OK in 60ms (Views: 55.5ms | ActiveRecord: 0.8ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:48:23 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (9.3ms)
Completed 200 OK in 40ms (Views: 37.4ms | ActiveRecord: 0.4ms)


  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (27.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.1ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (9.4ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (8.0ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (7.9ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (9.9ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.4ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (11.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (15.4ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.3ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (8.4ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.7ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (12.4ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date != NULL AND (SELECT COUNT(*) FROM events where New.employee_id = managing_employee) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (11.7ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (11.1ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (12.1ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.4ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.2ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event = eventNo);
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event OR eID is NULL) AND
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (14.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event = New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (0.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (11.3ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (12.2ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 06:48:57', '2017-12-04 06:48:57')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (24.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.1ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.2ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.3ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (9.0ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (9.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (11.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.5ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (8.3ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (12.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (6.6ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.3ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (9.4ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (10.9ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date != NULL AND (SELECT COUNT(*) FROM events where New.employee_id = managing_employee) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (11.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (11.8ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.3ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.7ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.2ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event_id = eventNo);
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event_id = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.6ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event OR eID is NULL) AND
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (12.6ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (13.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event = New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.8ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (10.7ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (13.3ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 06:51:05', '2017-12-04 06:51:05')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (17.6ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.6ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.2ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.2ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (7.9ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (8.8ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (8.0ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (6.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.2ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (7.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.6ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (9.0ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.4ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (11.2ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date != NULL AND (SELECT COUNT(*) FROM events where New.employee_id = managing_employee) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (10.4ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (11.4ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (11.2ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.3ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.2ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guestCount + 1) FROM eventRegistrations where event_id = eventNo);
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM eventRegistrations;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM eventRegistrations
          WHERE member = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM EventRegistrations WHERE event_id = eventNo AND memNo = member;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM eventregistrations
          where (regCode = registrationCode OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guestCount OR guests IS NULL);
      END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event = New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (11.2ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 06:52:12', '2017-12-04 06:52:12')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (24.9ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.7ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (0.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (10.3ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (7.6ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (9.4ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (7.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (8.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (8.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.4ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (11.6ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date != NULL AND (SELECT COUNT(*) FROM events where New.employee_id = managing_employee) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (10.7ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (0.4ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (12.3ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (11.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM EVENTS where title = new.title AND event_date = new.event_date) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That event is already scheduled on that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF New.event_date < CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  END IF;
  END;

[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (0.3ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (13.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (10.4ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (0.3ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (0.2ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (0.3ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (10.6ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 06:56:27', '2017-12-04 06:56:27')[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/tanks/new" for 127.0.0.1 at 2017-12-04 01:56:42 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (11.3ms)
  Rendered tanks/new.html.erb within layouts/application (13.2ms)
Completed 200 OK in 65ms (Views: 40.6ms | ActiveRecord: 3.2ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-04 01:56:48 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (0.4ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (36.3ms)
Completed 200 OK in 61ms (Views: 56.3ms | ActiveRecord: 1.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:56:58 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (4.3ms)
Completed 200 OK in 25ms (Views: 23.3ms | ActiveRecord: 0.3ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-04 01:57:01 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (0.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (6.0ms)
  Rendered tanks/new.html.erb within layouts/application (9.0ms)
Completed 200 OK in 57ms (Views: 54.4ms | ActiveRecord: 0.5ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-04 01:57:18 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"TzlwHkaQ8+khDpfnNTZRf7Fn+voi0UShaiSRYca001BFEUr3Uas7iToZMKlFA1VxiBdcxvtk23z7kev9x63tHw==", "tank"=>{"tank_id"=>"", "name"=>"Ocean", "description"=>"seaseasea", "water_type"=>"salt", "volume"=>"9", "temperature"=>"9", "year_built"=>"1999", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (0.8ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES ('Ocean', 'seaseasea', 'salt', 9.0, 9.0, 1999, 1)[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/15
Completed 302 Found in 8ms (ActiveRecord: 1.5ms)


Started GET "/tanks/15" for 127.0.0.1 at 2017-12-04 01:57:18 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (0.8ms)
Completed 200 OK in 32ms (Views: 29.1ms | ActiveRecord: 0.3ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:57:21 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (7.0ms)
Completed 200 OK in 81ms (Views: 77.2ms | ActiveRecord: 0.5ms)


Started GET "/tanks/15/edit" for 127.0.0.1 at 2017-12-04 01:57:28 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.3ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (6.1ms)
  Rendered tanks/edit.html.erb within layouts/application (8.9ms)
Completed 200 OK in 54ms (Views: 50.3ms | ActiveRecord: 0.6ms)


Started PATCH "/tanks/15" for 127.0.0.1 at 2017-12-04 01:57:30 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"BaGNaLauuUxPLhnNZt0dWBJKb0oQT+LNuEkAasrZIusirnfKgwDdgRr+p0DP/tuRcygotTGUt94zGjxTUfSuqA==", "tank"=>{"tank_id"=>"15", "name"=>"Ocean", "description"=>"seaseasea", "water_type"=>"fresh", "volume"=>"9.0", "temperature"=>"9.0", "year_built"=>"1999", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"15"}
  [1m[36mTank Load (0.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.2ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (0.3ms)[0m  [1m[33mUPDATE `tanks` SET `water_type` = 'fresh' WHERE `tanks`.`tank_id` = 15[0m
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/15
Completed 302 Found in 6ms (ActiveRecord: 1.8ms)


Started GET "/tanks/15" for 127.0.0.1 at 2017-12-04 01:57:30 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (0.2ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (1.0ms)
Completed 200 OK in 24ms (Views: 22.0ms | ActiveRecord: 0.2ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-04 01:57:35 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (0.4ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (8.1ms)
Completed 200 OK in 76ms (Views: 74.2ms | ActiveRecord: 0.4ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-04 01:57:45 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (0.8ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (12.4ms)
Completed 200 OK in 42ms (Views: 36.6ms | ActiveRecord: 1.5ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-04 01:57:49 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (4.2ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (59.8ms)
  Rendered event_registrations/new.html.erb within layouts/application (63.4ms)
Completed 200 OK in 98ms (Views: 73.2ms | ActiveRecord: 20.1ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-04 01:57:56 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"j42lad1GRqwHGVbvFQ5HeUO9i9IhBZQsbA27IX13L2ta8oaGGZllImvAuDZ9/ebATR9fnJv2j68f1T2Jzu5+Dw==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-04 01:57:49 -0500", "member_id"=>"22", "event_id"=>"11", "guest_count"=>"2"}, "commit"=>"Create Event registration"}
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.5ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-04 06:57:49', 22, 11, 2)[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/19
Completed 302 Found in 7ms (ActiveRecord: 3.0ms)


Started GET "/event_registrations/19" for 127.0.0.1 at 2017-12-04 01:57:56 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"19"}
  [1m[36mEventRegistration Load (0.8ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 19 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (1.0ms)
Completed 200 OK in 43ms (Views: 37.4ms | ActiveRecord: 0.8ms)


Started GET "/event_registrations/19/edit" for 127.0.0.1 at 2017-12-04 01:57:59 -0500
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"19"}
  [1m[36mEventRegistration Load (0.4ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 19 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (0.3ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (0.3ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (7.0ms)
  Rendered event_registrations/edit.html.erb within layouts/application (9.4ms)
Completed 200 OK in 52ms (Views: 47.0ms | ActiveRecord: 1.0ms)


Started PATCH "/event_registrations/19" for 127.0.0.1 at 2017-12-04 01:58:03 -0500
Processing by EventRegistrationsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"4jkr+95uaAJf76wYxerHVq+7frQGBtoPbEaOCrzCh5A/0W2WK1L6rfeKu2tU6NNItLrYY04KSAI/5/V4cP4B5Q==", "event_registration"=>{"registration_code"=>"19", "time"=>"2017-12-04 01:57:59 -0500", "member_id"=>"22", "event_id"=>"11", "guest_count"=>"122"}, "commit"=>"Update Event registration", "id"=>"19"}
  [1m[36mEventRegistration Load (0.4ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 19 LIMIT 1[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[33mUPDATE `event_registrations` SET `time` = '2017-12-04 06:57:59', `guest_count` = 122 WHERE `event_registrations`.`registration_code` = 19[0m
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/19
Completed 302 Found in 5ms (ActiveRecord: 1.2ms)


Started GET "/event_registrations/19" for 127.0.0.1 at 2017-12-04 01:58:03 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"19"}
  [1m[36mEventRegistration Load (0.3ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 19 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (1.0ms)
Completed 200 OK in 32ms (Views: 29.5ms | ActiveRecord: 0.3ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-04 01:58:05 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (0.4ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (9.9ms)
Completed 200 OK in 69ms (Views: 65.8ms | ActiveRecord: 0.4ms)


Started GET "/event_registrations/1/edit" for 127.0.0.1 at 2017-12-04 01:58:13 -0500
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEventRegistration Load (0.3ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (0.4ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (0.3ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (7.6ms)
  Rendered event_registrations/edit.html.erb within layouts/application (10.8ms)
Completed 200 OK in 65ms (Views: 60.9ms | ActiveRecord: 1.0ms)


Started PATCH "/event_registrations/1" for 127.0.0.1 at 2017-12-04 01:58:19 -0500
Processing by EventRegistrationsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"9OJTV+AAj2tLZr9m1K6RzLla4JruzgGQ075UYeSEtaSvLM85tQx32A8sAEScjIZAjwsWtiTMFZohnkYnn5CUcQ==", "event_registration"=>{"registration_code"=>"1", "time"=>"2017-12-04 01:58:13 -0500", "member_id"=>"9", "event_id"=>"2", "guest_count"=>"3"}, "commit"=>"Update Event registration", "id"=>"1"}
  [1m[36mEventRegistration Load (0.3ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[33mUPDATE `event_registrations` SET `time` = '2017-12-04 06:58:13', `member_id` = 9, `event_id` = 2 WHERE `event_registrations`.`registration_code` = 1[0m
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/1
Completed 302 Found in 5ms (ActiveRecord: 1.6ms)


Started GET "/event_registrations/1" for 127.0.0.1 at 2017-12-04 01:58:19 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEventRegistration Load (0.3ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (1.1ms)
Completed 200 OK in 38ms (Views: 34.5ms | ActiveRecord: 0.3ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-04 01:58:22 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (0.3ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (7.0ms)
Completed 200 OK in 53ms (Views: 51.2ms | ActiveRecord: 0.3ms)


Started GET "/members" for 127.0.0.1 at 2017-12-04 16:55:01 -0500
  
Mysql2::Error (Access denied for user 'root'@'localhost' (using password: NO)):
  
mysql2-0.4.10-x86 (mingw32) lib/mysql2/client.rb:89:in `connect'
mysql2-0.4.10-x86 (mingw32) lib/mysql2/client.rb:89:in `initialize'
activerecord (5.1.4) lib/active_record/connection_adapters/mysql2_adapter.rb:21:in `new'
activerecord (5.1.4) lib/active_record/connection_adapters/mysql2_adapter.rb:21:in `mysql2_connection'
activerecord (5.1.4) lib/active_record/connection_adapters/abstract/connection_pool.rb:759:in `new_connection'
activerecord (5.1.4) lib/active_record/connection_adapters/abstract/connection_pool.rb:803:in `checkout_new_connection'
activerecord (5.1.4) lib/active_record/connection_adapters/abstract/connection_pool.rb:782:in `try_to_checkout_new_connection'
activerecord (5.1.4) lib/active_record/connection_adapters/abstract/connection_pool.rb:743:in `acquire_connection'
activerecord (5.1.4) lib/active_record/connection_adapters/abstract/connection_pool.rb:500:in `checkout'
activerecord (5.1.4) lib/active_record/connection_adapters/abstract/connection_pool.rb:374:in `connection'
activerecord (5.1.4) lib/active_record/connection_adapters/abstract/connection_pool.rb:931:in `retrieve_connection'
activerecord (5.1.4) lib/active_record/connection_handling.rb:116:in `retrieve_connection'
activerecord (5.1.4) lib/active_record/connection_handling.rb:88:in `connection'
activerecord (5.1.4) lib/active_record/migration.rb:562:in `connection'
activerecord (5.1.4) lib/active_record/migration.rb:553:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:26:in `block in call'
activesupport (5.1.4) lib/active_support/callbacks.rb:97:in `run_callbacks'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:24:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:59:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
  [1m[35m (27.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (328.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (66.9ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (58.8ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (97.8ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (60.0ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (90.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (89.2ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (74.9ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (80.9ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (69.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (61.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (76.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (0.9ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (13.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (29.4ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (29.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (10.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (49.6ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (42.7ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (3.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (7.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.9ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (69.1ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (50.1ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (28.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (29.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (31.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (16.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (40.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (29.1ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (8.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 21:58:28', '2017-12-04 21:58:28')[0m
  [1m[35m (3.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/members" for 127.0.0.1 at 2017-12-04 16:59:56 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (26.0ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (456.5ms)
Completed 200 OK in 4389ms (Views: 4108.9ms | ActiveRecord: 89.1ms)


Started GET "/members/1/edit" for 127.0.0.1 at 2017-12-04 17:14:16 -0500
Processing by MembersController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (30.1ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mMember Load (8.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 1 LIMIT 1[0m
  Rendering members/edit.html.erb within layouts/application
  Rendered members/_form.html.erb (96.1ms)
  Rendered members/edit.html.erb within layouts/application (259.2ms)
Completed 200 OK in 1679ms (Views: 1420.5ms | ActiveRecord: 38.1ms)


Started PATCH "/members/1" for 127.0.0.1 at 2017-12-04 17:14:21 -0500
Processing by MembersController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"6iBA275EuhHzcIBGYWpADzxv90vHeYr1oXFHO/TbITuyzhKhGWcjn4ElmdHsce62CQtgd6fATNP7/Dvz1Tcw6A==", "member"=>{"member_id"=>"1", "first_name"=>"", "last_name"=>"Zora", "date_joined"=>"2017-12-04", "expiration_date"=>"2019-06-04 17:14:18 -0400", "fee"=>"400.0"}, "commit"=>"Update Member", "id"=>"1"}
  [1m[36mMember Load (1.5ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[33mUPDATE `members` SET `first_name` = '', `date_joined` = '2017-12-04', `expiration_date` = '2019-06-04' WHERE `members`.`member_id` = 1[0m
  [1m[35m (2.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/members/1
Completed 302 Found in 44ms (ActiveRecord: 9.5ms)


Started GET "/members/1" for 127.0.0.1 at 2017-12-04 17:14:21 -0500
Processing by MembersController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mMember Load (0.5ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 1 LIMIT 1[0m
  Rendering members/show.html.erb within layouts/application
  Rendered members/show.html.erb within layouts/application (1.0ms)
Completed 200 OK in 991ms (Views: 779.7ms | ActiveRecord: 0.5ms)


Started GET "/members" for 127.0.0.1 at 2017-12-04 17:14:25 -0500
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (2.0ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (92.1ms)
Completed 200 OK in 1323ms (Views: 1188.5ms | ActiveRecord: 2.0ms)


  [1m[35m (28.1ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (296.7ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (75.7ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (59.9ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (57.6ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (87.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (110.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (79.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (90.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (90.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (63.2ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (57.2ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (92.0ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.6ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (5.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (3.5ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (32.6ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (29.5ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (3.9ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (36.6ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (39.8ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (3.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (32.6ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  END IF;
  END;
[0m
  [1m[35m (31.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.8ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (69.4ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (71.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (28.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (29.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (30.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (26.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (7.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 22:19:56', '2017-12-04 22:19:56')[0m
  [1m[35m (3.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/members" for 127.0.0.1 at 2017-12-04 17:23:50 -0500
  [1m[35m (29.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (3.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (29.5ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (212.8ms)
Completed 200 OK in 3972ms (Views: 3413.2ms | ActiveRecord: 32.0ms)


Started GET "/members/15/edit" for 127.0.0.1 at 2017-12-04 17:25:01 -0500
Processing by MembersController#edit as HTML
  Parameters: {"id"=>"15"}
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mMember Load (11.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 15 LIMIT 1[0m
  Rendering members/edit.html.erb within layouts/application
  Rendered members/_form.html.erb (114.3ms)
  Rendered members/edit.html.erb within layouts/application (243.1ms)
Completed 200 OK in 1336ms (Views: 985.7ms | ActiveRecord: 12.5ms)


Started PATCH "/members/15" for 127.0.0.1 at 2017-12-04 17:25:07 -0500
Processing by MembersController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"NUjIswKnfjPOD1O9ecjPEN+G4+H2CrGWFbWrKrkAX+X/BN2HbmYACZlYIWUBFQYxOCsBYQQ/0zI5iH/6PfR50A==", "member"=>{"member_id"=>"15", "first_name"=>"Oscar", "last_name"=>"Lamberg", "date_joined"=>"2017-12-04", "expiration_date"=>"2019-06-04 17:25:02 -0400", "fee"=>"300"}, "commit"=>"Update Member", "id"=>"15"}
  [1m[36mMember Load (2.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 15 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (13.0ms)[0m  [1m[33mUPDATE `members` SET `date_joined` = '2017-12-04', `expiration_date` = '2019-06-04', `fee` = 300.0 WHERE `members`.`member_id` = 15[0m
  [1m[35m (22.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/members/15
Completed 302 Found in 177ms (ActiveRecord: 38.5ms)


Started GET "/members/15" for 127.0.0.1 at 2017-12-04 17:25:08 -0500
Processing by MembersController#show as HTML
  Parameters: {"id"=>"15"}
  [1m[36mMember Load (2.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 15 LIMIT 1[0m
  Rendering members/show.html.erb within layouts/application
  Rendered members/show.html.erb within layouts/application (2.0ms)
Completed 200 OK in 1209ms (Views: 911.3ms | ActiveRecord: 2.0ms)


Started GET "/members" for 127.0.0.1 at 2017-12-04 17:25:13 -0500
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (2.0ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (103.1ms)
Completed 200 OK in 1567ms (Views: 1401.1ms | ActiveRecord: 2.0ms)


Started GET "/members/new" for 127.0.0.1 at 2017-12-04 17:25:16 -0500
Processing by MembersController#new as HTML
  Rendering members/new.html.erb within layouts/application
  Rendered members/_form.html.erb (19.6ms)
  Rendered members/new.html.erb within layouts/application (228.8ms)
Completed 200 OK in 1553ms (Views: 1247.2ms | ActiveRecord: 0.0ms)


Started POST "/members" for 127.0.0.1 at 2017-12-04 17:25:19 -0500
Processing by MembersController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"5L7PqoMXOsT5oWGavRPtFp8KMc+4d/hNeppuRZuUL+fl9CCMM7P9RJfm8RH+qdFLd+ozUtW+P9mxUvYUxHmNRQ==", "member"=>{"member_id"=>"", "first_name"=>"", "last_name"=>"", "date_joined"=>"2017-12-04", "expiration_date"=>"2019-06-04 17:25:17 -0400", "fee"=>"100"}, "commit"=>"Create Member"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `members` (`first_name`, `last_name`, `date_joined`, `expiration_date`, `fee`) VALUES ('', '', '2017-12-04', '2019-06-04', 100.0)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering members/new.html.erb within layouts/application
  Rendered members/_form.html.erb (9.5ms)
  Rendered members/new.html.erb within layouts/application (273.2ms)
Completed 200 OK in 2528ms (Views: 2498.2ms | ActiveRecord: 5.0ms)


Started POST "/members" for 127.0.0.1 at 2017-12-04 17:25:26 -0500
Processing by MembersController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"5YP+Gri1mzNrR8npGnehqSXQZQY6+X6fVRNGM61aThTZETqIOyCMUYlLQAS7x7xYaCWriAfUmFxqKTcadjAl1A==", "member"=>{"member_id"=>"", "first_name"=>"a", "last_name"=>"", "date_joined"=>"2017-12-04", "expiration_date"=>"2019-06-04 17:25:21 -0400", "fee"=>"100"}, "commit"=>"Create Member"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `members` (`first_name`, `last_name`, `date_joined`, `expiration_date`, `fee`) VALUES ('a', '', '2017-12-04', '2019-06-04', 100.0)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering members/new.html.erb within layouts/application
  Rendered members/_form.html.erb (20.0ms)
  Rendered members/new.html.erb within layouts/application (223.1ms)
Completed 200 OK in 1323ms (Views: 1294.7ms | ActiveRecord: 6.0ms)


Started POST "/members" for 127.0.0.1 at 2017-12-04 17:25:35 -0500
Processing by MembersController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"6Vr040T73K+0QYiJ4Z/InVdFn3C2SsEuMp4VMq3q2VrVyDBxx27LzVZNAWRAL9VsGrBR/otnJ+0NpGQbdoCymg==", "member"=>{"member_id"=>"", "first_name"=>"a", "last_name"=>"b", "date_joined"=>"2017-12-04", "expiration_date"=>"2019-06-04 17:25:27 -0400", "fee"=>"100"}, "commit"=>"Create Member"}
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[32mINSERT INTO `members` (`first_name`, `last_name`, `date_joined`, `expiration_date`, `fee`) VALUES ('a', 'b', '2017-12-04', '2019-06-04', 100.0)[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/members/27
Completed 302 Found in 275ms (ActiveRecord: 10.0ms)


Started GET "/members/27" for 127.0.0.1 at 2017-12-04 17:25:35 -0500
Processing by MembersController#show as HTML
  Parameters: {"id"=>"27"}
  [1m[36mMember Load (8.5ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 27 LIMIT 1[0m
  Rendering members/show.html.erb within layouts/application
  Rendered members/show.html.erb within layouts/application (1.0ms)
Completed 200 OK in 1382ms (Views: 1091.3ms | ActiveRecord: 8.5ms)


Started GET "/members" for 127.0.0.1 at 2017-12-04 17:25:40 -0500
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (0.5ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (27.5ms)
Completed 200 OK in 771ms (Views: 633.4ms | ActiveRecord: 0.5ms)


  [1m[35m (27.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (313.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (52.7ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (42.2ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (84.4ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (74.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (81.8ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (83.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (92.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (97.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (76.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (73.1ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (116.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (15.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (6.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (20.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.1ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (6.9ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (39.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (39.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (8.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.1ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (4.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (31.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (33.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit'
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (26.9ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 22:45:10', '2017-12-04 22:45:10')[0m
  [1m[35m (18.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (26.7ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (295.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (70.0ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (43.8ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (59.5ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (64.0ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (106.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (74.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (89.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (103.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (82.6ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (70.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (97.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (4.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (10.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (10.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (10.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (18.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (13.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (9.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (10.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (8.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (21.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (12.5ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (7.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (12.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (35.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (32.5ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (7.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (38.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (34.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (4.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (1.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (26.5ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (35.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (25.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (20.2ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.6ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (2.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (5.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 22:46:26', '2017-12-04 22:46:26')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (27.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (330.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (76.4ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (54.3ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (112.4ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (70.7ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (91.0ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (70.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (74.8ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (71.0ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (53.9ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (55.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (82.2ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (34.1ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (29.1ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (12.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (32.3ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (34.8ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.9ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.7ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (10.6ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (1.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (61.8ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (64.1ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (14.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (8.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (23.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (28.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (46.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (12.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (18.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (12.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (12.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (50.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (56.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (31.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (11.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (11.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (33.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (32.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (9.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (7.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (16.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 22:57:55', '2017-12-04 22:57:55')[0m
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (26.6ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (318.6ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (77.9ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (60.0ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (97.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (69.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (69.5ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (88.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (74.4ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (68.2ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (55.4ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (55.7ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (79.5ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (42.9ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (29.4ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.1ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (43.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (38.5ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (1.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (14.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (40.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (52.1ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (6.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (19.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (45.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (32.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (12.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (11.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (22.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (49.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (49.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (11.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (12.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (3.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (7.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (11.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (17.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.5ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 23:01:27', '2017-12-04 23:01:27')[0m
  [1m[35m (22.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (16.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (328.7ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (52.4ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (62.9ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (79.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (91.8ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (100.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (60.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (76.2ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (58.8ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (62.3ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (62.9ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (92.3ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (16.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (43.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (56.1ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (4.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (52.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (41.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (7.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (4.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (11.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (18.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (31.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (33.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (9.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (10.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (9.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (9.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (12.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (11.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (6.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (18.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (11.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (14.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (15.5ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (32.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (41.3ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (56.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (10.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (40.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (4.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (26.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (5.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (4.5ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (26.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (33.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (2.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (8.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 23:03:46', '2017-12-04 23:03:46')[0m
  [1m[35m (2.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (28.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (379.3ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (12.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (23.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (16.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (10.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (12.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (60.5ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (75.1ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (8.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (92.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (73.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (94.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (89.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (63.0ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (135.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (57.0ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (65.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (62.0ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (9.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (0.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (10.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (37.8ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (28.4ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (24.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (30.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (9.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (15.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (26.5ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (32.6ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (22.2ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (29.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (5.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 23:06:26', '2017-12-04 23:06:26')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (28.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (3.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (349.3ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (30.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (29.3ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (30.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (29.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (29.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (62.1ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (55.3ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (57.3ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (71.9ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (88.5ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (90.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (84.4ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (78.2ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (91.8ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (74.2ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (68.6ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.9ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (10.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (8.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (27.9ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (31.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (30.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (31.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (28.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (28.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (29.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (30.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (17.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (29.5ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (38.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (45.1ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (4.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (6.5ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (65.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (49.1ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (10.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (3.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.1ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (4.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (39.5ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (38.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (1.9ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (45.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (32.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (3.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (7.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 23:09:02', '2017-12-04 23:09:02')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (25.2ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (361.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (15.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (89.1ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (68.5ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (15.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (56.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (90.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (89.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (57.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (64.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (63.2ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (51.5ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (61.1ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (82.7ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (7.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new employee
    -- ------------------------------------------
    CREATE PROCEDURE addEmployee(
    fName varchar(45), lname varchar(45), salary double)

      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      -- DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


        INSERT INTO EMPLOYEES (firstName, lastName, hiredDate, salary) VALUES (fName, lName, CURDATE(), salary);
        SELECT ('new employee "', fName, ' ', lName, '" added.') AS 'result';

      END;
        IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Employee "', fName, ' ', lName, '" was not added.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all employees
    -- ------------------------------------------
    CREATE PROCEDURE viewEmployees()
      BEGIN

      SELECT * FROM employees
        ORDER BY lastName desc;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by name
    -- -------------------------------------

    CREATE PROCEDURE viewEmployeeRecord(fName varchar(45), lName varchar(45))
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE firstName = fName
          AND lastName = lName);

      SELECT * FROM employees
        WHERE firstName = fName
          AND lastName = lName;

        IF notFound = 0 THEN
          SELECT CONCAT('Employee ', fName, ' ', lName, ' not found.') AS 'result';
        END IF;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -------------------------------------
    -- filter employee by salary range
    -- -------------------------------------
    CREATE PROCEDURE viewEmployeesBySalary(low double, high double)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM employees
        WHERE salary >= low
          AND salary <= high);

      SELECT * FROM employees
        WHERE salary >= low
          AND salary <= high
            ORDER BY salary desc;

        IF notFound = 0 THEN
          SELECT CONCAT('No employees with salaries in the given range.') AS 'result';
        END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee salary
    -- ------------------------------------------

    CREATE PROCEDURE updateSalary(ID int, newSalary double)
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET salary = newSalary WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s Salary updated to ', newSalary) as 'result';
      END IF;
    END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- update employee firstName
    -- ------------------------------------------

    CREATE PROCEDURE updateFirstName(ID int, newFName varchar(45))
      BEGIN
      DECLARE employeeExist INT DEFAULT 0;
      SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

      UPDATE employees
      SET firstName = newfName WHERE employeeID = ID;

      IF employeeExist = 0 THEN
        SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, '''s first name updated to ', newFName) as 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update employee lastName
    -- ------------------------------------------

    CREATE PROCEDURE updateLastName(ID int, newLName varchar(45))
    BEGIN
    DECLARE employeeExist INT DEFAULT 0;
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE ID = employeeID);

    UPDATE employees
    SET lastName = newLName WHERE employeeID = ID;

    IF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', ID, ' does not exist') as 'result';
    ELSEIF employeeExist = 1 THEN
      SELECT CONCAT('Employee ', ID, '''s last name updated to ', newLName) as 'result';
    END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- fire employee by ID
    -- ------------------------------------------

    CREATE PROCEDURE fireEmployee(id int)
    BEGIN
    UPDATE employees
    SET fired_date = CURDATE() WHERE employee_id = id;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (33.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (36.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (3.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (33.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (38.6ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (26.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (26.5ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (29.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (30.4ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (28.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (28.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (28.1ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (30.8ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (37.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.8ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (36.7ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (31.3ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (3.7ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (9.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-04 23:13:54', '2017-12-04 23:13:54')[0m
  [1m[35m (10.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/event_registrations" for 127.0.0.1 at 2017-12-04 18:15:02 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (7.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (99.1ms)
Completed 200 OK in 2419ms (Views: 2157.5ms | ActiveRecord: 13.0ms)


Started GET "/event_registrations/18/edit" for 127.0.0.1 at 2017-12-04 18:16:03 -0500
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"18"}
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEventRegistration Load (9.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 18 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (24.0ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (10.0ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (631.1ms)
  Rendered event_registrations/edit.html.erb within layouts/application (810.3ms)
Completed 200 OK in 2054ms (Views: 1810.3ms | ActiveRecord: 54.5ms)


Started PATCH "/event_registrations/18" for 127.0.0.1 at 2017-12-04 18:16:09 -0500
Processing by EventRegistrationsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"it0RqYJOP+zMsi6WH/S6paZpA8KZmMwxpiYQzRDJcEuZS+5LKkJskqPtgTSyUVnE5v1RDslU9yuOoANkCY7OOQ==", "event_registration"=>{"registration_code"=>"18", "time"=>"2017-12-04 18:16:04 -0500", "member_id"=>"22", "event_id"=>"11", "guest_count"=>"2"}, "commit"=>"Update Event registration", "id"=>"18"}
  [1m[36mEventRegistration Load (2.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 18 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[33mUPDATE `event_registrations` SET `time` = '2017-12-04 23:16:04', `member_id` = 22 WHERE `event_registrations`.`registration_code` = 18[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (24.0ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (334.8ms)
  Rendered event_registrations/edit.html.erb within layouts/application (530.4ms)
Completed 200 OK in 1358ms (Views: 1300.6ms | ActiveRecord: 34.0ms)


Started PATCH "/event_registrations/18" for 127.0.0.1 at 2017-12-04 18:16:19 -0500
Processing by EventRegistrationsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"v0ahxN3nZo2Hqdas+tSQjgMYhp2XUIOolEsYFzm/ifKD1GVWXnJx72WlX0FbZI1/Tu1IE6p9ZWurcWk+4tXiMg==", "event_registration"=>{"registration_code"=>"18", "time"=>"2017-12-04 18:16:10 -0500", "member_id"=>"17", "event_id"=>"8", "guest_count"=>"2"}, "commit"=>"Update Event registration", "id"=>"18"}
  [1m[36mEventRegistration Load (30.6ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 18 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[33mUPDATE `event_registrations` SET `time` = '2017-12-04 23:16:10', `member_id` = 17, `event_id` = 8 WHERE `event_registrations`.`registration_code` = 18[0m
  [1m[35m (0.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (2.0ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (3.0ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (40.0ms)
  Rendered event_registrations/edit.html.erb within layouts/application (183.2ms)
Completed 200 OK in 1504ms (Views: 1415.7ms | ActiveRecord: 38.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-04 18:16:25 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (30.7ms)
Completed 200 OK in 908ms (Views: 744.2ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-04 18:16:36 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (13.0ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (9.0ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (187.2ms)
  Rendered event_registrations/new.html.erb within layouts/application (377.1ms)
Completed 200 OK in 1344ms (Views: 1159.0ms | ActiveRecord: 22.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-04 18:16:50 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Xr7Dp5KHCFmTlU4PL2+fYmeVdqYLB5Vj0IiXIc//AoKHhaDD1jJW5WsbL+6S3UkJeThiOLGWl9xrQ3OsT8IN7Q==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-04 18:16:37 -0500", "member_id"=>"1", "event_id"=>"1", "guest_count"=>"10"}, "commit"=>"Create Event registration"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (15.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-04 23:16:37', 1, 1, 10)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (1.0ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (26.0ms)
  Rendered event_registrations/new.html.erb within layouts/application (164.2ms)
Completed 200 OK in 1133ms (Views: 1093.7ms | ActiveRecord: 18.5ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-04 18:16:56 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"lhSypDcRkpR88/7iFUkhuWR0I563hH5Z6SSoPkiVPh2qhnY2tISF9p7/dw+0+TxIKYHtEIqpmJrWHtkXk/9V3Q==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-04 18:16:51 -0500", "member_id"=>"1", "event_id"=>"1", "guest_count"=>"2"}, "commit"=>"Create Event registration"}
  [1m[35m (30.9ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (29.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-04 23:16:51', 1, 1, 2)[0m
  [1m[35m (30.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/19
Completed 302 Found in 220ms (ActiveRecord: 90.0ms)


Started GET "/event_registrations/19" for 127.0.0.1 at 2017-12-04 18:16:57 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"19"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 19 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 822ms (Views: 674.8ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-04 18:17:03 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (31.1ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (222.2ms)
Completed 200 OK in 1291ms (Views: 1107.8ms | ActiveRecord: 31.1ms)


Started GET "/events" for 127.0.0.1 at 2017-12-04 18:17:08 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (0.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (50.0ms)
Completed 200 OK in 1456ms (Views: 994.4ms | ActiveRecord: 0.5ms)


Started GET "/members" for 127.0.0.1 at 2017-12-04 18:17:19 -0500
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (1.5ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (35.5ms)
Completed 200 OK in 1125ms (Views: 861.5ms | ActiveRecord: 1.5ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-04 18:17:28 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (32.0ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (85.4ms)
  Rendered event_registrations/new.html.erb within layouts/application (222.0ms)
Completed 200 OK in 1745ms (Views: 1421.2ms | ActiveRecord: 33.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-04 18:17:35 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"8Ac+szgXrPIyc1F1UMvICLrXHrAJlLEFyecmwsfza2UpPF3XfKLyTsr9MJTteR5jpHoKLrMFs7pyLMJPR85kCg==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-04 18:17:30 -0500", "member_id"=>"20", "event_id"=>"1", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (4.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (27.5ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-04 23:17:30', 20, 1, 1)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (24.0ms)[0m  [1m[34mSELECT `members`.* FROM `members` ORDER BY last_name[0m
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT `events`.* FROM `events` ORDER BY title[0m
  Rendered event_registrations/_form.html.erb (234.5ms)
  Rendered event_registrations/new.html.erb within layouts/application (425.0ms)
Completed 200 OK in 1735ms (Views: 1540.9ms | ActiveRecord: 57.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-04 18:17:43 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (32.6ms)
Completed 200 OK in 1069ms (Views: 851.9ms | ActiveRecord: 1.5ms)


Started GET "/members" for 127.0.0.1 at 2017-12-04 18:20:27 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (7.0ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (90.1ms)
Completed 200 OK in 2931ms (Views: 2660.6ms | ActiveRecord: 12.0ms)


Started GET "/members/18/edit" for 127.0.0.1 at 2017-12-04 18:21:42 -0500
Processing by MembersController#edit as HTML
  Parameters: {"id"=>"18"}
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mMember Load (10.5ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 18 LIMIT 1[0m
  Rendering members/edit.html.erb within layouts/application
  Rendered members/_form.html.erb (468.7ms)
  Rendered members/edit.html.erb within layouts/application (585.6ms)
Completed 200 OK in 1601ms (Views: 1364.1ms | ActiveRecord: 12.0ms)


Started PATCH "/members/18" for 127.0.0.1 at 2017-12-04 18:21:47 -0500
Processing by MembersController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"UC37RxreZqvD7Q+oPLcaWsFRbtRUtkz8lLsyn0Gq6oJ0YJ3T/8M/FdpT8waPHm1JprD4t5n0XFx69So9BUIr6A==", "member"=>{"member_id"=>"18", "first_name"=>"Regine", "last_name"=>"Icer", "date_joined"=>"2017-12-04", "expiration_date"=>"2019-06-04 18:21:43 -0400", "fee"=>"100"}, "commit"=>"Update Member", "id"=>"18"}
  [1m[36mMember Load (2.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 18 LIMIT 1[0m
  [1m[35m (11.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[33mUPDATE `members` SET `date_joined` = '2017-12-04', `expiration_date` = '2019-06-04', `fee` = 100.0 WHERE `members`.`member_id` = 18[0m
  [1m[35m (20.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/members/18
Completed 302 Found in 243ms (ActiveRecord: 35.0ms)


Started GET "/members/18" for 127.0.0.1 at 2017-12-04 18:21:47 -0500
Processing by MembersController#show as HTML
  Parameters: {"id"=>"18"}
  [1m[36mMember Load (1.5ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 18 LIMIT 1[0m
  Rendering members/show.html.erb within layouts/application
  Rendered members/show.html.erb within layouts/application (2.0ms)
Completed 200 OK in 1133ms (Views: 911.8ms | ActiveRecord: 1.5ms)


Started GET "/members" for 127.0.0.1 at 2017-12-04 18:21:51 -0500
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (30.6ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (238.7ms)
Completed 200 OK in 1551ms (Views: 1037.0ms | ActiveRecord: 30.6ms)


Started DELETE "/members/17" for 127.0.0.1 at 2017-12-04 18:22:02 -0500
Processing by MembersController#destroy as HTML
  Parameters: {"authenticity_token"=>"2ojypGoqS4OtLevq/N7zft1GVIuqXcuJXuaUIzmPd0fmGjY26b9c4U8hYgddbu6PkLOaBZdwLUph3OUK4uUchw==", "id"=>"17"}
  [1m[36mMember Load (2.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 17 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (16.0ms)[0m  [1m[31mDELETE FROM `members` WHERE `members`.`member_id` = 17[0m
  [1m[35m (9.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/members
Completed 302 Found in 199ms (ActiveRecord: 28.0ms)


Started GET "/members" for 127.0.0.1 at 2017-12-04 18:22:02 -0500
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (1.0ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (30.0ms)
Completed 200 OK in 1024ms (Views: 678.6ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-04 18:22:10 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (8.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (69.8ms)
Completed 200 OK in 1247ms (Views: 937.8ms | ActiveRecord: 17.0ms)


Started DELETE "/members/11" for 127.0.0.1 at 2017-12-04 18:22:22 -0500
Processing by MembersController#destroy as HTML
  Parameters: {"authenticity_token"=>"TWL8eDdwbyhQKFecPzaDmlt93hc2jKnHKOLqlva5uURx8DjqtOV4SrIk3nGehp5rFogQmQuhTwQX2Ju/LdPShA==", "id"=>"11"}
  [1m[36mMember Load (2.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 11 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[31mDELETE FROM `members` WHERE `members`.`member_id` = 11[0m
  [1m[35m (25.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/members
Completed 302 Found in 59ms (ActiveRecord: 30.5ms)


Started GET "/members" for 127.0.0.1 at 2017-12-04 18:22:22 -0500
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (31.0ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (303.7ms)
Completed 200 OK in 1618ms (Views: 1294.9ms | ActiveRecord: 31.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-04 18:22:26 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (19.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (220.5ms)
Completed 200 OK in 1866ms (Views: 1592.8ms | ActiveRecord: 19.5ms)


  [1m[35m (23.9ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.3ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (4.4ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (403.4ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (92.9ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (60.0ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (30.7ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (29.4ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (46.9ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (69.4ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (90.7ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (71.7ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (92.0ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (79.7ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (62.5ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (45.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (74.6ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (32.5ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (58.1ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (69.1ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (18.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL;
END;


[0m
  [1m[35m (30.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (16.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (2.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-05 12:56:24', '2017-12-05 12:56:24')[0m
  [1m[35m (4.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (27.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (386.3ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (18.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (3.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (99.0ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (81.1ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (30.1ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (30.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (102.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (84.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (92.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (131.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (78.9ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (104.2ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (66.0ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (68.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (69.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (66.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (90.1ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (14.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL;
END;


[0m
  [1m[35m (15.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (32.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (14.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (16.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (34.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (16.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (11.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (10.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (31.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (18.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (66.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (37.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (11.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (13.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (12.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (22.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (35.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (42.5ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (27.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (39.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (7.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-05 12:57:01', '2017-12-05 12:57:01')[0m
  [1m[35m (9.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/employees" for 127.0.0.1 at 2017-12-05 08:02:09 -0500
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (23.5ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (439.3ms)
Completed 200 OK in 3653ms (Views: 3337.0ms | ActiveRecord: 105.6ms)


Started DELETE "/employees/2" for 127.0.0.1 at 2017-12-05 08:03:17 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"TxHufFtddI5j+fZvUF4HYgXavVT6RBfyXSNhmUf7MFVzgyru2Mhj7IH1f4Lx7hqTSC9z2sdp8TFiGRCwnJFblQ==", "id"=>"2"}
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEmployee Load (9.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (26.0ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-05' WHERE `employees`.`employee_id` = 2[0m
  [1m[35m (29.3ms)[0m  [1m[31mROLLBACK[0m
  Rendering employees/edit.html.erb within layouts/application
  Rendered employees/_form.html.erb (303.7ms)
  Rendered employees/edit.html.erb within layouts/application (615.4ms)
Completed 200 OK in 2357ms (Views: 2161.5ms | ActiveRecord: 67.3ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-05 08:03:33 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (30.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (182.6ms)
Completed 200 OK in 1240ms (Views: 1037.9ms | ActiveRecord: 30.0ms)


Started DELETE "/employees/1" for 127.0.0.1 at 2017-12-05 08:03:40 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"kISDkPpISgAFL6hbYrcrgVKqbCTwZMPHlWTjb0bA+2WsFkcCed1dYucjIbbDBzZwH1+iqs1JJQSqXpJGnaqQpQ==", "id"=>"1"}
  [1m[36mEmployee Load (30.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35m (19.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (28.0ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-05' WHERE `employees`.`employee_id` = 1[0m
  [1m[35m (29.0ms)[0m  [1m[35mCOMMIT[0m
  Rendering employees/edit.html.erb within layouts/application
  Rendered employees/_form.html.erb (9.0ms)
  Rendered employees/edit.html.erb within layouts/application (157.2ms)
Completed 200 OK in 1201ms (Views: 903.6ms | ActiveRecord: 106.1ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-05 08:03:45 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (38.5ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (171.5ms)
Completed 200 OK in 1260ms (Views: 962.0ms | ActiveRecord: 38.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-05 08:04:14 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (15.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (128.7ms)
Completed 200 OK in 1496ms (Views: 1220.2ms | ActiveRecord: 25.5ms)


Started GET "/events/new" for 127.0.0.1 at 2017-12-05 08:04:30 -0500
Processing by EventsController#new as HTML
  Rendering events/new.html.erb within layouts/application
  [1m[36mEmployee Load (15.5ms)[0m  [1m[35mcall current_employees()[0m
  Rendered events/_form.html.erb (177.1ms)
  Rendered events/new.html.erb within layouts/application (580.4ms)
Completed 200 OK in 1871ms (Views: 1715.2ms | ActiveRecord: 15.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-05 08:04:47 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (11.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (128.1ms)
Completed 200 OK in 1622ms (Views: 1458.5ms | ActiveRecord: 11.0ms)


  [1m[35m (26.9ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (386.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.1ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (96.0ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (85.6ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (15.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (29.9ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (81.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (83.6ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (91.8ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (63.5ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (92.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (95.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (90.3ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (59.9ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (85.5ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (43.4ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (38.4ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (30.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (30.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (28.6ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (17.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (69.1ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (50.1ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (29.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (29.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (8.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (37.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (50.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (39.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (45.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (2.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (11.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 11:45:11', '2017-12-06 11:45:11')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/employees" for 127.0.0.1 at 2017-12-06 06:48:17 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (7.5ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (227.4ms)
Completed 200 OK in 3415ms (Views: 2984.1ms | ActiveRecord: 35.5ms)


Started GET "/feedinglogs" for 127.0.0.1 at 2017-12-06 06:49:06 -0500
Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-06 06:49:06 -0500
  
ActionController::RoutingError (No route matches [GET] "/feedinglogs"):
  
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:63:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Processing by FeedingLogsController#index as HTML
Started DELETE "/employees/1" for 127.0.0.1 at 2017-12-06 06:49:47 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"+v+DURgitqOl9CqqwYf9UlLNEIIX3Y7q9a+UygzCBgLGbUfDm7ehwUf4o0dgN+CjHzjeDCrwaCnKleXj16htwg==", "id"=>"1"}
  [1m[35m (42.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEmployee Load (278.9ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[35m (3.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35mSQL (15.0ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-06' WHERE `employees`.`employee_id` = 1[0m
  [1m[36mFeedingLog Load (10.0ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
  Rendering employees/edit.html.erb within layouts/application
  Rendered employees/_form.html.erb (484.3ms)
  Rendered employees/edit.html.erb within layouts/application (952.2ms)
  Rendered feeding_logs/index.html.erb within layouts/application (2416.5ms)
Completed 200 OK in 3175ms (Views: 2493.7ms | ActiveRecord: 349.0ms)


Completed 200 OK in 3398ms (Views: 3115.9ms | ActiveRecord: 45.5ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 06:49:55 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (31.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (179.2ms)
Completed 200 OK in 1466ms (Views: 1177.4ms | ActiveRecord: 31.0ms)


Started DELETE "/employees/2" for 127.0.0.1 at 2017-12-06 06:50:00 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"uDpv9T2x79teuRCaPSfgKmKL1mpigm+XB+xqnOhYy+mEqKtnviT4uby1mXecl/3bL34Y5F+viVQ41hu1MzKgKQ==", "id"=>"2"}
  [1m[36mEmployee Load (3.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (14.5ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-06' WHERE `employees`.`employee_id` = 2[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering employees/show.html.erb within layouts/application
  Rendered employees/show.html.erb within layouts/application (2.0ms)
Completed 200 OK in 1452ms (Views: 1409.6ms | ActiveRecord: 19.5ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 06:50:12 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (7.1ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (37.2ms)
Completed 200 OK in 1102ms (Views: 908.6ms | ActiveRecord: 7.1ms)


Started DELETE "/employees/2" for 127.0.0.1 at 2017-12-06 06:50:23 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"ihXlmJ/xJj3PoFGxnds2QuB594XP3Dzs1UixMF5GBlO2hyEKHGQxXy2s2Fw8ayuzrYw5C/Lx2i/qcsAZhSxtkw==", "id"=>"2"}
  [1m[36mEmployee Load (2.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-06' WHERE `employees`.`employee_id` = 2[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering employees/show.html.erb within layouts/application
  Rendered employees/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1248ms (Views: 1213.4ms | ActiveRecord: 8.0ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 06:50:41 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (30.5ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (172.4ms)
Completed 200 OK in 1392ms (Views: 1153.8ms | ActiveRecord: 30.5ms)


Started GET "/feeding_logs/new" for 127.0.0.1 at 2017-12-06 06:50:51 -0500
Processing by FeedingLogsController#new as HTML
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (29.1ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (29.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (544.1ms)
  Rendered feeding_logs/new.html.erb within layouts/application (707.3ms)
Completed 200 OK in 1605ms (Views: 1366.7ms | ActiveRecord: 79.1ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 06:51:03 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (22.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (352.3ms)
Completed 200 OK in 1606ms (Views: 1322.7ms | ActiveRecord: 28.0ms)


Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-06 06:51:09 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  Rendered treatment_logs/_form.html.erb (1375.5ms)
  Rendered treatment_logs/new.html.erb within layouts/application (1502.1ms)
Completed 500 Internal Server Error in 2085ms (ActiveRecord: 0.0ms)


  
ActionView::Template::Error (undefined local variable or method `values' for #<#<Class:0x70178d0>:0xb9c6070>):
    14:   <%= form.label :treatment_id %>
    15: 
    16: 
    17:   <%= form.hidden_field :time, values => DateTime.now %>
    18: 
    19:   <div class="field">
    20:     <%= form.label :medicine %>
  
app/views/treatment_logs/_form.html.erb:17:in `block in _app_views_treatment_logs__form_html_erb__775908458_97331376'
app/views/treatment_logs/_form.html.erb:1:in `_app_views_treatment_logs__form_html_erb__775908458_97331376'
app/views/treatment_logs/new.html.erb:3:in `_app_views_treatment_logs_new_html_erb__768752875_97399620'
Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:00:27 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (17.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (5.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (47.0ms)
Completed 200 OK in 2395ms (Views: 2210.9ms | ActiveRecord: 9.0ms)


Started DELETE "/employees/2" for 127.0.0.1 at 2017-12-06 07:01:33 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"HvCa/CqNTqnvzFCE/A8aORGtJy/0OqjsAZ9yJsxeyc4iYl5uqRhZyw3A2WldvwfIXFjpockXTi8+pQMPFzSiDg==", "id"=>"2"}
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEmployee Load (7.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (11.0ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-06' WHERE `employees`.`employee_id` = 2[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering employees/show.html.erb within layouts/application
  Rendered employees/show.html.erb within layouts/application (4.0ms)
Completed 200 OK in 788ms (Views: 715.3ms | ActiveRecord: 21.1ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:01:48 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (31.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (183.2ms)
Completed 200 OK in 1276ms (Views: 1122.8ms | ActiveRecord: 31.0ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:03:00 -0500
  [1m[35m (24.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (26.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (444.1ms)
Completed 200 OK in 3608ms (Views: 3259.9ms | ActiveRecord: 114.2ms)


Started DELETE "/employees/2" for 127.0.0.1 at 2017-12-06 07:04:38 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"PJIV6vnj8XxSvcGHTLsVVuJVFx9ywtJ8YNaTMAPV72IAANF4enbmHrCxSGrtCwinr6DZkU/vNL9f7OIZ2L+Eog==", "id"=>"2"}
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEmployee Load (15.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (13.0ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-06' WHERE `employees`.`employee_id` = 2[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering employees/index.html.erb within layouts/application
  Rendered employees/index.html.erb within layouts/application (171.1ms)
Completed 500 Internal Server Error in 751ms (ActiveRecord: 32.0ms)


  
ActionView::Template::Error (undefined method `each' for nil:NilClass):
    16:   </thead>
    17: 
    18:   <tbody>
    19:     <% @employees.each do |employee| %>
    20:       <tr>
    21:         <td><%= employee.employee_id %></td>
    22:         <td><%= employee.first_name %></td>
  
app/views/employees/index.html.erb:19:in `_app_views_employees_index_html_erb__325777629_94776360'
app/controllers/employees_controller.rb:80:in `block (2 levels) in destroy'
app/controllers/employees_controller.rb:69:in `destroy'
Started DELETE "/employees/2" for 127.0.0.1 at 2017-12-06 07:10:44 -0500
  [1m[35m (31.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/controllers/employees_controller.rb:72: syntax error, unexpected tLABEL, expecting '='
...irect_to_employees_url, notice: 'employee fired.'}
...                               ^
C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/controllers/employees_controller.rb:75: syntax error, unexpected tLABEL, expecting '='
...direct_to_employes_url, notice: 'firing unsuccessful'}
...                               ^
C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/controllers/employees_controller.rb:80: syntax error, unexpected tLABEL, expecting '='
...irect_to_employees_url, notice: e.message.split('Mysql2::Err...
...                               ^):
  
app/controllers/employees_controller.rb:72: syntax error, unexpected tLABEL, expecting '='
app/controllers/employees_controller.rb:75: syntax error, unexpected tLABEL, expecting '='
app/controllers/employees_controller.rb:80: syntax error, unexpected tLABEL, expecting '='
Started DELETE "/employees/2" for 127.0.0.1 at 2017-12-06 07:13:06 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"PJIV6vnj8XxSvcGHTLsVVuJVFx9ywtJ8YNaTMAPV72IAANF4enbmHrCxSGrtCwinr6DZkU/vNL9f7OIZ2L+Eog==", "id"=>"2"}
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (12.0ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-06' WHERE `employees`.`employee_id` = 2[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
Redirected to http://localhost:3000/employees
Completed 302 Found in 219ms (ActiveRecord: 30.5ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:14:01 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (8.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (101.6ms)
Completed 200 OK in 3815ms (Views: 3492.3ms | ActiveRecord: 8.0ms)


Started DELETE "/employees/1" for 127.0.0.1 at 2017-12-06 07:14:28 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"bAAvbk8E23WVatwe5Y4L1NO/RwqRhcSGWP8v5AVIqHtQkuv8zJHMF3dmVfNEPhYlnkqJhKyoIkVnxV7N3iLDuw==", "id"=>"1"}
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35m (2.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/employees
Completed 302 Found in 19ms (ActiveRecord: 4.0ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:14:28 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (2.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (53.4ms)
Completed 200 OK in 1683ms (Views: 1526.6ms | ActiveRecord: 2.0ms)


Started DELETE "/employees/1" for 127.0.0.1 at 2017-12-06 07:14:38 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"zMxbYG4k9aKeOXBFAY8PCcsYFc0DszhuAfuYFPBsOlfwXp/y7bHiwHw1+aigPxL4hu3bQz6e3q0+wek9KwZRlw==", "id"=>"1"}
  [1m[36mEmployee Load (1.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/employees
Completed 302 Found in 22ms (ActiveRecord: 3.5ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:14:38 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (17.7ms)
Completed 200 OK in 1304ms (Views: 1135.3ms | ActiveRecord: 1.0ms)


Started DELETE "/employees/3" for 127.0.0.1 at 2017-12-06 07:14:46 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"kqbzzpFwTEoqtyItvd3PwJhcHva8UkHZDRmslPVDxYKuNDdcEuVbKMi7q8AcbdIx1anQeIF/pxoyI929LimuQg==", "id"=>"3"}
  [1m[36mEmployee Load (1.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 3 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-06' WHERE `employees`.`employee_id` = 3[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
Redirected to http://localhost:3000/employees
Completed 302 Found in 33ms (ActiveRecord: 7.5ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:14:46 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (29.5ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (159.6ms)
Completed 200 OK in 1409ms (Views: 1193.8ms | ActiveRecord: 29.5ms)


Started DELETE "/employees/1" for 127.0.0.1 at 2017-12-06 07:17:46 -0500
  [1m[35m (4.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"mxab3dQbSV9jNIH+Y7En9vWkWOYLO7qUXCbVai1VtwynhF9PV45ePYE4CBPCAToHuFGWaDYWXFdjHKRD9j/czA==", "id"=>"1"}
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/employees
Completed 302 Found in 105ms (ActiveRecord: 10.0ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:18:39 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (26.5ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (175.7ms)
Completed 200 OK in 3083ms (Views: 2862.6ms | ActiveRecord: 26.5ms)


Started DELETE "/employees/2" for 127.0.0.1 at 2017-12-06 07:18:52 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"KhsOuqs0DgwD3LSI38E30Ff3jrghug4Sy+M6tjD4aikWicooKKEZbuHQPWV+cSohGgJANhyX6NH02Uuf65IB6Q==", "id"=>"2"}
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[35m (27.9ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (25.0ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-06' WHERE `employees`.`employee_id` = 2[0m
  [1m[35m (29.0ms)[0m  [1m[31mROLLBACK[0m
Redirected to http://localhost:3000/employees
Completed 302 Found in 236ms (ActiveRecord: 83.0ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:18:52 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (30.5ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (104.5ms)
Completed 200 OK in 1266ms (Views: 978.7ms | ActiveRecord: 30.5ms)


Started DELETE "/employees/1" for 127.0.0.1 at 2017-12-06 07:18:59 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"vbWbQVs9GxPZtaILlogeyEEyqQ72bHi4Ls3TpGOgyT+BJ1/T2KgMcTu5K+Y3OAM5DMdngMtBnnsR96KNuMqi/w==", "id"=>"1"}
  [1m[36mEmployee Load (30.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35m (20.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (28.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/employees
Completed 302 Found in 267ms (ActiveRecord: 78.1ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:18:59 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (17.5ms)
Completed 200 OK in 987ms (Views: 811.2ms | ActiveRecord: 1.0ms)


Started DELETE "/employees/9" for 127.0.0.1 at 2017-12-06 07:19:04 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"egrAJnTj6E/sMspOl8U8qdDmIeDS8Gm1C60p1fvgPkhGmAS093b/LQ4+Q6M2dSFYnRPvbu/dj3Y0l1j8IIpViA==", "id"=>"9"}
  [1m[36mEmployee Load (0.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 9 LIMIT 1[0m
  [1m[35m (9.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.5ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-06' WHERE `employees`.`employee_id` = 9[0m
  [1m[35m (23.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/employees
Completed 302 Found in 131ms (ActiveRecord: 37.0ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-06 07:19:05 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (22.4ms)
Completed 200 OK in 654ms (Views: 570.4ms | ActiveRecord: 1.0ms)


Started GET "/events" for 127.0.0.1 at 2017-12-06 07:19:14 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (21.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (449.1ms)
Completed 200 OK in 1981ms (Views: 1597.1ms | ActiveRecord: 79.6ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-06 07:19:23 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (9.5ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (1733.5ms)
Completed 200 OK in 3290ms (Views: 2957.2ms | ActiveRecord: 17.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 07:19:30 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (30.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (510.6ms)
Completed 200 OK in 2382ms (Views: 2028.8ms | ActiveRecord: 68.5ms)


Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-06 07:19:40 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  Rendered treatment_logs/_form.html.erb (1108.9ms)
  Rendered treatment_logs/new.html.erb within layouts/application (1232.5ms)
Completed 500 Internal Server Error in 1955ms (ActiveRecord: 0.0ms)


  
ActionView::Template::Error (undefined local variable or method `values' for #<#<Class:0xba78660>:0xab9d710>):
    14:   <%= form.label :treatment_id %>
    15: 
    16: 
    17:   <%= form.hidden_field :time, values => DateTime.now %>
    18: 
    19:   <div class="field">
    20:     <%= form.label :medicine %>
  
app/views/treatment_logs/_form.html.erb:17:in `block in _app_views_treatment_logs__form_html_erb___798546823_59341032'
app/views/treatment_logs/_form.html.erb:1:in `_app_views_treatment_logs__form_html_erb___798546823_59341032'
app/views/treatment_logs/new.html.erb:3:in `_app_views_treatment_logs_new_html_erb__677169625_89977416'
Started GET "/feeding_logs/new" for 127.0.0.1 at 2017-12-06 07:20:07 -0500
Processing by FeedingLogsController#new as HTML
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (2015.5ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (27.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (6560.9ms)
  Rendered feeding_logs/new.html.erb within layouts/application (6991.0ms)
Completed 200 OK in 14683ms (Views: 12250.7ms | ActiveRecord: 2046.5ms)


Started GET "/events/new" for 127.0.0.1 at 2017-12-06 07:20:30 -0500
Processing by EventsController#new as HTML
  Rendering events/new.html.erb within layouts/application
  [1m[36mEmployee Load (2.0ms)[0m  [1m[35mcall current_employees()[0m
  Rendered events/_form.html.erb (69.8ms)
  Rendered events/new.html.erb within layouts/application (211.8ms)
Completed 200 OK in 1112ms (Views: 947.2ms | ActiveRecord: 2.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 07:24:12 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (28.5ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (162.4ms)
Completed 200 OK in 4100ms (Views: 3347.7ms | ActiveRecord: 32.0ms)


Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-06 07:25:37 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  Rendered treatment_logs/_form.html.erb (1082.6ms)
  Rendered treatment_logs/new.html.erb within layouts/application (1262.7ms)
Completed 500 Internal Server Error in 2759ms (ActiveRecord: 0.0ms)


  
ActionView::Template::Error (undefined local variable or method `value' for #<#<Class:0x3e6c7c0>:0xb73d500>):
    14:   <%= form.label :treatment_id %>
    15: 
    16: 
    17:   <%= form.hidden_field :time, value => DateTime.now %>
    18: 
    19:   <div class="field">
    20:     <%= form.label :medicine %>
  
app/views/treatment_logs/_form.html.erb:17:in `block in _app_views_treatment_logs__form_html_erb__627355232_97958460'
app/views/treatment_logs/_form.html.erb:1:in `_app_views_treatment_logs__form_html_erb__627355232_97958460'
app/views/treatment_logs/new.html.erb:3:in `_app_views_treatment_logs_new_html_erb__548535578_96071040'
Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-06 07:28:02 -0500
  [1m[35m (23.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (11.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (7.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (724.0ms)
  Rendered treatment_logs/new.html.erb within layouts/application (1268.4ms)
Completed 200 OK in 3571ms (Views: 3224.4ms | ActiveRecord: 41.0ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-06 07:30:27 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"R9AjZ/4Mj566dSW4KEArBNrVZPoPMTyr0xs/GAsGkEN7Quf1fZmY/Fh5rFWJ8Db1lyCqdDIc2mjsIU4x0Gz7gw==", "treatment_log"=>{"time"=>"2017-12-06T12:28:07+00:00", "medicine"=>"Test", "quantity"=>"asdfb", "employee_id"=>"2", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (8.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (8.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[35mSQL (11.0ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `quantity`, `employee_id`, `animal_id`) VALUES ('2017-12-06 12:28:07', 'Test', 0.0, 2, 1)[0m
  [1m[35m (6.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/treatment_logs/53
Completed 302 Found in 265ms (ActiveRecord: 36.6ms)


Started GET "/treatment_logs/53" for 127.0.0.1 at 2017-12-06 07:30:28 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"53"}
  [1m[36mTreatmentLog Load (2.0ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 53 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1450ms (Views: 1243.7ms | ActiveRecord: 2.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 07:31:14 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (1.5ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (92.7ms)
Completed 200 OK in 1457ms (Views: 1316.7ms | ActiveRecord: 1.5ms)


Started GET "/events/new" for 127.0.0.1 at 2017-12-06 07:36:38 -0500
  [1m[35m (24.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#new as HTML
  Rendering events/new.html.erb within layouts/application
  [1m[36mEmployee Load (2.5ms)[0m  [1m[35mcall current_employees()[0m
  Rendered events/_form.html.erb (295.2ms)
  Rendered events/new.html.erb within layouts/application (502.8ms)
Completed 200 OK in 3642ms (Views: 3254.8ms | ActiveRecord: 34.5ms)


Started POST "/events" for 127.0.0.1 at 2017-12-06 07:38:44 -0500
Processing by EventsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"XgpGE8BqfuWZxYi93L1/Ou/Ca2V8WZc6qex920Hv7rFimIKBQ/9ph3vJAVB9DWLLojel60F0cfmW1gzymoWFcQ==", "event"=>{"event_id"=>"", "title"=>"", "price"=>"", "managing_employee"=>"2", "max_guests_per_person"=>"", "max_attending"=>"", "event_date(1i)"=>"2017", "event_date(2i)"=>"12", "event_date(3i)"=>"6", "event_date(4i)"=>"12", "event_date(5i)"=>"36"}, "commit"=>"Create Event"}
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (30.5ms)[0m  [1m[32mINSERT INTO `events` (`title`, `managing_employee`, `event_date`) VALUES ('', 2, '2017-12-06 12:36:00')[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/new.html.erb within layouts/application
  [1m[36mEmployee Load (24.8ms)[0m  [1m[35mcall current_employees()[0m
  Rendered events/_form.html.erb (165.2ms)
  Rendered events/new.html.erb within layouts/application (370.2ms)
Completed 200 OK in 1612ms (Views: 1522.7ms | ActiveRecord: 59.3ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-06 08:19:45 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (26.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (25.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (680.2ms)
Completed 200 OK in 4139ms (Views: 3816.5ms | ActiveRecord: 32.5ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-12-06 08:23:00 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  Rendered animals/_form.html.erb (5.0ms)
  Rendered animals/new.html.erb within layouts/application (400.3ms)
Completed 500 Internal Server Error in 1811ms (ActiveRecord: 0.0ms)


  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/views/animals/_form.html.erb:33: syntax error, unexpected '=', expecting =>
...:animal_birth_date, :end_year = Date.today.year );@output_bu...
...                               ^):
  
app/views/animals/_form.html.erb:33: syntax error, unexpected '=', expecting =>
app/views/animals/new.html.erb:3:in `_app_views_animals_new_html_erb___567767278_91418628'
Started GET "/animals" for 127.0.0.1 at 2017-12-06 08:27:29 -0500
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (27.8ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (8.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (406.8ms)
Completed 200 OK in 3913ms (Views: 3614.0ms | ActiveRecord: 15.5ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-12-06 08:29:10 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  Rendered animals/_form.html.erb (4.0ms)
  Rendered animals/new.html.erb within layouts/application (190.6ms)
Completed 500 Internal Server Error in 758ms (ActiveRecord: 0.0ms)


  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/views/animals/_form.html.erb:33: syntax error, unexpected '=', expecting =>
...:animal_birth_date, :end_year = Date.today.year );@output_bu...
...                               ^):
  
app/views/animals/_form.html.erb:33: syntax error, unexpected '=', expecting =>
app/views/animals/new.html.erb:3:in `_app_views_animals_new_html_erb___850840455_58778496'
Started GET "/animals" for 127.0.0.1 at 2017-12-06 08:30:50 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (29.1ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (476.6ms)
Completed 200 OK in 3192ms (Views: 2978.1ms | ActiveRecord: 59.1ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-12-06 08:32:18 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mTank Load (2.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (257.6ms)
  Rendered animals/new.html.erb within layouts/application (456.2ms)
Completed 200 OK in 1381ms (Views: 1237.1ms | ActiveRecord: 11.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 08:32:30 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (19.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (201.0ms)
Completed 200 OK in 2059ms (Views: 1470.3ms | ActiveRecord: 21.5ms)


Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-06 08:32:59 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (1.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (7.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (75.6ms)
  Rendered treatment_logs/new.html.erb within layouts/application (199.1ms)
Completed 200 OK in 840ms (Views: 640.7ms | ActiveRecord: 10.0ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-06 08:33:13 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"CwXIDreXsiyGbiUmLjUCcc3rZJlBR7MfyXLmx/ECtwn9KAkbfBzrsj+pzP0/M83xVL40jixmcvZK6p4ug/Sg6Q==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"06", "time(5i)"=>"23", "medicine"=>"", "quantity"=>"", "employee_id"=>"2", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (2.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[35mSQL (2.5ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `employee_id`, `animal_id`) VALUES ('2017-12-01 06:23:00', '', 2, 1)[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 209ms (ActiveRecord: 8.5ms)


  
ActiveRecord::NotNullViolation (Mysql2::Error: Field 'quantity' doesn't have a default value: INSERT INTO `treatment_logs` (`time`, `medicine`, `employee_id`, `animal_id`) VALUES ('2017-12-01 06:23:00', '', 2, 1)):
  
app/controllers/treatment_logs_controller.rb:30:in `block in create'
app/controllers/treatment_logs_controller.rb:29:in `create'
Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 08:33:58 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (29.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (179.5ms)
Completed 200 OK in 1657ms (Views: 1261.9ms | ActiveRecord: 29.0ms)


Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-06 08:34:02 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (1.5ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (2.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (63.9ms)
  Rendered treatment_logs/new.html.erb within layouts/application (277.0ms)
Completed 200 OK in 1338ms (Views: 1179.0ms | ActiveRecord: 3.5ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-06 08:34:09 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"PLnVY6NfeVEGAoTgOZ2e75bTGPDMs/7ZUvOvMhNRrBDKlBR2aNQgz7/FbTsom1FvD4ZI56GSPzDRa9fbYae78A==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"13", "time(5i)"=>"34", "medicine"=>"a", "quantity"=>"2", "employee_id"=>"2", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (32.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (31.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (6.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[35mSQL (26.0ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `quantity`, `employee_id`, `animal_id`) VALUES ('2017-12-01 13:34:00', 'a', 2.0, 2, 1)[0m
  [1m[35m (35.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/treatment_logs/54
Completed 302 Found in 428ms (ActiveRecord: 130.6ms)


Started GET "/treatment_logs/54" for 127.0.0.1 at 2017-12-06 08:34:09 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"54"}
  [1m[36mTreatmentLog Load (1.5ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 54 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (4.0ms)
Completed 200 OK in 909ms (Views: 738.3ms | ActiveRecord: 1.5ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 08:34:13 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (1.5ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (53.0ms)
Completed 200 OK in 934ms (Views: 721.3ms | ActiveRecord: 1.5ms)


Started GET "/feeding_logs/new" for 127.0.0.1 at 2017-12-06 08:36:27 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (26.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by FeedingLogsController#new as HTML
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (2.5ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (10.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (1040.3ms)
  Rendered feeding_logs/new.html.erb within layouts/application (1262.2ms)
Completed 200 OK in 3582ms (Views: 3255.0ms | ActiveRecord: 35.5ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-06 09:02:26 -0500
Started GET "/bitatsha" for 127.0.0.1 at 2017-12-06 09:02:28 -0500
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (12.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
ActionController::RoutingError (No route matches [GET] "/bitatsha"):
  
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:63:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
Processing by TanksController#index as HTML
Started GET "/habitats" for 127.0.0.1 at 2017-12-06 09:02:58 -0500
Processing by HabitatsController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (43.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendering habitats/index.html.erb within layouts/application
  Rendered tanks/index.html.erb within layouts/application (185.1ms)
  [1m[35m (24.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mHabitat Load (30.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats`[0m
  Rendered habitats/index.html.erb within layouts/application (219.7ms)
Completed 200 OK in 1246ms (Views: 980.0ms | ActiveRecord: 89.1ms)


Completed 200 OK in 1341ms (Views: 1139.2ms | ActiveRecord: 121.6ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-06 09:04:18 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  Rendered tanks/_form.html.erb (4.5ms)
  Rendered tanks/new.html.erb within layouts/application (229.1ms)
Completed 500 Internal Server Error in 1777ms (ActiveRecord: 0.0ms)


  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/views/tanks/_form.html.erb:44: syntax error, unexpected =>
...en_field :year_built, value: => 2017 );@output_buffer.safe_a...
...                               ^):
  
app/views/tanks/_form.html.erb:44: syntax error, unexpected =>
app/views/tanks/new.html.erb:3:in `_app_views_tanks_new_html_erb___478625392_102546324'
Started GET "/habitats/new" for 127.0.0.1 at 2017-12-06 09:04:24 -0500
Processing by HabitatsController#new as HTML
  Rendering habitats/new.html.erb within layouts/application
  Rendered habitats/_form.html.erb (3.0ms)
  Rendered habitats/new.html.erb within layouts/application (3045.6ms)
Completed 500 Internal Server Error in 14767ms (ActiveRecord: 0.0ms)


  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/views/habitats/_form.html.erb:27: syntax error, unexpected =>
...en_field :year_added, value: => 2017 );@output_buffer.safe_a...
...                               ^):
  
app/views/habitats/_form.html.erb:27: syntax error, unexpected =>
app/views/habitats/new.html.erb:3:in `_app_views_habitats_new_html_erb__139314829_105996048'
Started GET "/tanks" for 127.0.0.1 at 2017-12-06 09:07:10 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (28.6ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (38.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (574.4ms)
Completed 200 OK in 3551ms (Views: 3147.8ms | ActiveRecord: 113.1ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-06 09:18:03 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mTank Load (8.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (50.5ms)
Completed 200 OK in 1011ms (Views: 816.8ms | ActiveRecord: 9.0ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-06 09:18:08 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (4.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (342.5ms)
  Rendered tanks/new.html.erb within layouts/application (604.8ms)
Completed 200 OK in 1759ms (Views: 1459.4ms | ActiveRecord: 8.3ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-06 09:18:22 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"qGbU/XxpvN+Na9S2gr1VZQma3djkio8h84a4rVGF7A+vLa6PEtjwvQWeTQtMrRV/iTNM7jNZATvqHFSzSrEdjg==", "tank"=>{"tank_id"=>"", "name"=>"test", "description"=>"desc", "water_type"=>"fresh", "volume"=>"200", "temperature"=>"78", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (11.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (6.5ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES ('test', 'desc', 'fresh', 200.0, 78.0, 2017, 1)[0m
  [1m[35m (24.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/15
Completed 302 Found in 394ms (ActiveRecord: 42.5ms)


Started GET "/tanks/15" for 127.0.0.1 at 2017-12-06 09:18:22 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (4.0ms)
Completed 200 OK in 979ms (Views: 704.7ms | ActiveRecord: 1.5ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-06 09:18:26 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (8.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (202.4ms)
Completed 200 OK in 1262ms (Views: 1029.1ms | ActiveRecord: 8.0ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-06 09:19:00 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (1.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (57.0ms)
  Rendered tanks/new.html.erb within layouts/application (435.8ms)
Completed 200 OK in 1849ms (Views: 1719.9ms | ActiveRecord: 1.5ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-06 09:19:08 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (200.2ms)
Completed 200 OK in 2184ms (Views: 1796.8ms | ActiveRecord: 1.0ms)


Started GET "/habitats" for 127.0.0.1 at 2017-12-06 09:19:13 -0500
Processing by HabitatsController#index as HTML
  Rendering habitats/index.html.erb within layouts/application
  [1m[36mHabitat Load (1.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats`[0m
  Rendered habitats/index.html.erb within layouts/application (100.1ms)
Completed 200 OK in 1617ms (Views: 1285.4ms | ActiveRecord: 1.5ms)


Started GET "/habitats/new" for 127.0.0.1 at 2017-12-06 09:19:17 -0500
Processing by HabitatsController#new as HTML
  Rendering habitats/new.html.erb within layouts/application
  Rendered habitats/_form.html.erb (20.0ms)
  Rendered habitats/new.html.erb within layouts/application (256.1ms)
Completed 200 OK in 1530ms (Views: 1385.4ms | ActiveRecord: 0.0ms)


Started POST "/habitats" for 127.0.0.1 at 2017-12-06 09:19:23 -0500
Processing by HabitatsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"bWsNKrQhZncHTCiLxm4zGD+5suqsSH+0ffYFNRenNpObSzsr6sL1AzwpgqeTBjBr682KcOLLCoglllrRA+REDw==", "habitat"=>{"habitat_id"=>"", "name"=>"Test", "description"=>"Test1", "year_added"=>"2017"}, "commit"=>"Create Habitat"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.0ms)[0m  [1m[32mINSERT INTO `habitats` (`name`, `description`, `year_added`) VALUES ('Test', 'Test1', 2017)[0m
  [1m[35m (10.3ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/habitats/5
Completed 302 Found in 120ms (ActiveRecord: 18.3ms)


Started GET "/habitats/5" for 127.0.0.1 at 2017-12-06 09:19:23 -0500
Processing by HabitatsController#show as HTML
  Parameters: {"id"=>"5"}
  [1m[36mHabitat Load (28.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 5 LIMIT 1[0m
  Rendering habitats/show.html.erb within layouts/application
  Rendered habitats/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1048ms (Views: 780.3ms | ActiveRecord: 28.0ms)


Started GET "/habitats" for 127.0.0.1 at 2017-12-06 09:19:28 -0500
Processing by HabitatsController#index as HTML
  Rendering habitats/index.html.erb within layouts/application
  [1m[36mHabitat Load (1.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats`[0m
  Rendered habitats/index.html.erb within layouts/application (16.5ms)
Completed 200 OK in 959ms (Views: 762.9ms | ActiveRecord: 1.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 09:28:58 -0500
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (1.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (2003.9ms)
Completed 200 OK in 3897ms (Views: 3713.7ms | ActiveRecord: 4.0ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-06 09:29:32 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mFeedingLog Load (11.0ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (438.8ms)
Completed 200 OK in 983ms (Views: 821.2ms | ActiveRecord: 30.0ms)


Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-06 09:29:45 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (6.5ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (6.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (345.3ms)
  Rendered treatment_logs/new.html.erb within layouts/application (524.4ms)
Completed 200 OK in 1658ms (Views: 1425.7ms | ActiveRecord: 18.0ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-06 09:29:57 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"IjqxluxicyUObLR8Yo/16a5Dh9cGKloZwp5id/e9voHUF3CDJ+kqu7erXadziTppNxbXwGsLm/BBBhqehUupYQ==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"14", "time(5i)"=>"29", "medicine"=>"a", "quantity"=>"b", "employee_id"=>"7", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (2.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (2.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 7 LIMIT 1[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `quantity`, `employee_id`, `animal_id`) VALUES ('2017-12-01 14:29:00', 'a', 0.0, 7, 1)[0m
  [1m[35m (8.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/treatment_logs/55
Completed 302 Found in 224ms (ActiveRecord: 15.5ms)


Started GET "/treatment_logs/55" for 127.0.0.1 at 2017-12-06 09:29:57 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"55"}
  [1m[36mTreatmentLog Load (2.0ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 55 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1655ms (Views: 1374.9ms | ActiveRecord: 2.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 09:30:03 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (32.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (403.6ms)
Completed 200 OK in 1497ms (Views: 1259.9ms | ActiveRecord: 32.0ms)


Started GET "/feeding_logs/new" for 127.0.0.1 at 2017-12-06 09:30:22 -0500
Processing by FeedingLogsController#new as HTML
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (25.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (25.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (472.4ms)
  Rendered feeding_logs/new.html.erb within layouts/application (717.4ms)
Completed 200 OK in 1877ms (Views: 1596.9ms | ActiveRecord: 79.6ms)


Started POST "/feeding_logs" for 127.0.0.1 at 2017-12-06 09:30:30 -0500
Processing by FeedingLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"KFiX2cIPzLQdG0XsA5tLuXRRCHXUSboxYC/6eJsDld+Q/WMTPsFh5TZYhDDaXv9RCAiCEP9iagYLlo6702ggjQ==", "feeding_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"14", "time(5i)"=>"30", "food"=>"a", "quantity"=>"10", "employee_id"=>"2", "tank_id"=>"11"}, "commit"=>"Create Feeding log"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEmployee Load (2.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 2 LIMIT 1[0m
  [1m[36mTank Load (8.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `feeding_logs` (`time`, `food`, `quantity`, `employee_id`, `tank_id`) VALUES ('2017-12-01 14:30:00', 'a', 10.0, 2, 11)[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/feeding_logs/393
Completed 302 Found in 69ms (ActiveRecord: 16.0ms)


Started GET "/feeding_logs/393" for 127.0.0.1 at 2017-12-06 09:30:30 -0500
Processing by FeedingLogsController#show as HTML
  Parameters: {"id"=>"393"}
  [1m[36mFeedingLog Load (1.0ms)[0m  [1m[34mSELECT  `feeding_logs`.* FROM `feeding_logs` WHERE `feeding_logs`.`feeding_id` = 393 LIMIT 1[0m
  Rendering feeding_logs/show.html.erb within layouts/application
  Rendered feeding_logs/show.html.erb within layouts/application (4.0ms)
Completed 200 OK in 1335ms (Views: 1132.4ms | ActiveRecord: 1.0ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-06 09:30:33 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (31.0ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (668.6ms)
Completed 200 OK in 2269ms (Views: 1719.3ms | ActiveRecord: 31.0ms)


  [1m[35m (26.6ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (5.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (347.7ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (73.7ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (57.5ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (7.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (79.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (76.9ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (89.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (85.7ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (75.9ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (91.4ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (69.7ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (56.0ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (86.4ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.9ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.6ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (29.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (36.6ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (3.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.9ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (30.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (31.9ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE even_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (3.6ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (5.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (27.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (27.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (13.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (39.5ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (60.1ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (29.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (14.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (9.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (7.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (10.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (16.5ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (34.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (6.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (12.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (48.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (45.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (11.5ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date IS NOT NULL ORDER BY last_name asc;
END;
[0m
  [1m[35m (15.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (9.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (13.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (11.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (18.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (9.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (32.5ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 15:12:09', '2017-12-06 15:12:09')[0m
  [1m[35m (11.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/members" for 127.0.0.1 at 2017-12-06 10:13:31 -0500
Started GET "/events" for 127.0.0.1 at 2017-12-06 10:13:33 -0500
  [1m[35m (37.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (37.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (12.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
Processing by MembersController#index as HTML
  Rendering events/index.html.erb within layouts/application
  Rendering members/index.html.erb within layouts/application
  [1m[36mEvent Load (27.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  [1m[36mMember Load (24.5ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered events/index.html.erb within layouts/application (347.0ms)
  Rendered members/index.html.erb within layouts/application (408.3ms)
Completed 500 Internal Server Error in 4654ms (ActiveRecord: 63.1ms)


  
ActionView::Template::Error (can't add a new key into hash during iteration):
     5:     <%= csrf_meta_tags %>
     6: 
     7:     <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>
     8:     <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
     9:   </head>
    10: 
    11:   <body>
  
app/views/layouts/application.html.erb:8:in `_app_views_layouts_application_html_erb__600049919_25826244'
Completed 200 OK in 5863ms (Views: 5334.4ms | ActiveRecord: 64.6ms)


Started GET "/events" for 127.0.0.1 at 2017-12-06 10:17:40 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (26.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (498.5ms)
Completed 200 OK in 3564ms (Views: 3276.4ms | ActiveRecord: 96.1ms)


Started GET "/members" for 127.0.0.1 at 2017-12-06 10:18:47 -0500
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[35m (31.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mMember Load (29.0ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (489.1ms)
Completed 200 OK in 1474ms (Views: 1178.1ms | ActiveRecord: 75.1ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 10:18:59 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (31.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (110.4ms)
Completed 200 OK in 1398ms (Views: 1019.3ms | ActiveRecord: 34.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 10:19:35 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (8.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (5.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (381.0ms)
  Rendered event_registrations/new.html.erb within layouts/application (582.0ms)
Completed 500 Internal Server Error in 1304ms (ActiveRecord: 13.0ms)


  
ActionView::Template::Error (Mysql2::Error: Unknown column 'even_date' in 'where clause': call upcoming_events()):
    22: 
    23:     <div class="field">
    24:       <%= form.label :event_id %>
    25:       <%= form.collection_select(:event_id, Event.find_by_sql('call upcoming_events()'), :event_id, :title) %>
    26:     </div>
    27: 
    28:   <div class="field">
  
app/views/event_registrations/_form.html.erb:25:in `block in _app_views_event_registrations__form_html_erb__273934033_98217312'
app/views/event_registrations/_form.html.erb:1:in `_app_views_event_registrations__form_html_erb__273934033_98217312'
app/views/event_registrations/new.html.erb:3:in `_app_views_event_registrations_new_html_erb__23192386_96342096'
  [1m[35m (26.8ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (309.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (65.7ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (68.0ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (99.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (126.6ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (98.7ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (78.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (64.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (71.3ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (67.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (68.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (89.5ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (32.4ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (41.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (10.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (34.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (35.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (3.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (24.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (22.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (12.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (10.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (8.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (6.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (25.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (11.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (3.5ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (15.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (23.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (9.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (14.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (47.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (60.5ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (10.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (19.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (12.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (6.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (13.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (9.5ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (10.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (10.5ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (21.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (41.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (37.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date IS NOT NULL ORDER BY last_name asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (7.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 15:22:15', '2017-12-06 15:22:15')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events" for 127.0.0.1 at 2017-12-06 10:31:24 -0500
  [1m[35m (0.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (4.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (10.0ms)
Completed 200 OK in 509ms (Views: 455.3ms | ActiveRecord: 5.0ms)


Started GET "/events" for 127.0.0.1 at 2017-12-06 10:33:12 -0500
  [1m[35m (8.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (6.5ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (51.5ms)
Completed 200 OK in 1570ms (Views: 1430.8ms | ActiveRecord: 11.5ms)


Started GET "/event_registrations/" for 127.0.0.1 at 2017-12-06 10:34:08 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[35m (30.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEventRegistration Load (9.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (268.2ms)
Completed 200 OK in 1748ms (Views: 1164.8ms | ActiveRecord: 99.1ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 10:34:14 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (6.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (18.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (320.2ms)
  Rendered event_registrations/new.html.erb within layouts/application (491.8ms)
Completed 200 OK in 1384ms (Views: 1215.1ms | ActiveRecord: 27.5ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 10:34:55 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"53bBTF8Ie2cgfdEfAawUklnlbH+VtC9hJSRGlWdB+9Q+TaIoG70l29jzsP68HsL5R0h44S8lLd6e76IY53z0uw==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 10:34:15 -0500", "member_id"=>"2", "event_id"=>"1", "guest_count"=>"0"}, "commit"=>"Create Event registration"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (22.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 15:34:15', 2, 1, 0)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (1.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (23.5ms)
  Rendered event_registrations/new.html.erb within layouts/application (122.1ms)
Completed 200 OK in 711ms (Views: 622.0ms | ActiveRecord: 26.5ms)


  [1m[35m (25.8ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (306.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (3.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (31.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (9.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (75.6ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (60.5ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (10.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (68.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (82.6ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (88.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (88.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (81.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (94.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (85.6ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (79.1ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (120.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (5.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (26.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (14.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (11.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (20.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (14.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (10.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (9.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (6.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (31.5ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (28.5ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (26.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (25.6ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (1.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (33.1ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (22.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.7ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (21.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (21.6ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (9.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (4.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 15:39:53', '2017-12-06 15:39:53')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 10:41:40 -0500
  [1m[35m (33.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (17.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (17.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (189.1ms)
Completed 200 OK in 2427ms (Views: 1620.7ms | ActiveRecord: 67.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 10:43:10 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mMember Load (8.5ms)[0m  [1m[35mcall current_members()[0m
  Rendered event_registrations/_form.html.erb (143.1ms)
  Rendered event_registrations/new.html.erb within layouts/application (249.7ms)
Completed 500 Internal Server Error in 673ms (ActiveRecord: 13.5ms)


  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/models/event.rb:5: syntax error, unexpected end-of-input, expecting keyword_end):
  
app/models/event.rb:5: syntax error, unexpected end-of-input, expecting keyword_end
app/views/event_registrations/_form.html.erb:25:in `block in _app_views_event_registrations__form_html_erb___20578168_59743560'
app/views/event_registrations/_form.html.erb:1:in `_app_views_event_registrations__form_html_erb___20578168_59743560'
app/views/event_registrations/new.html.erb:3:in `_app_views_event_registrations_new_html_erb___173051440_59858664'
Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 10:45:18 -0500
  [1m[35m (22.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (25.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (555.8ms)
Completed 200 OK in 3762ms (Views: 3438.5ms | ActiveRecord: 99.1ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 10:46:29 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[35m (20.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mMember Load (32.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (12.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (737.7ms)
  Rendered event_registrations/new.html.erb within layouts/application (932.4ms)
Completed 200 OK in 2027ms (Views: 1779.3ms | ActiveRecord: 101.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 10:46:47 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"8xU6dSSiANbjA4CIzfIeqoI7CnC3PMEasbDN/EPjhiQqLlkRYBdeahuN4WlwQMjBnJYe7g2tw6UKeylxw96JSw==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 10:46:30 -0500", "member_id"=>"26", "event_id"=>"1", "guest_count"=>"9"}, "commit"=>"Create Event registration"}
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (27.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 15:46:30', 26, 1, 9)[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (1.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (79.6ms)
  Rendered event_registrations/new.html.erb within layouts/application (368.8ms)
Completed 200 OK in 2252ms (Views: 2189.7ms | ActiveRecord: 33.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 10:46:57 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"oAXJCOmIbyE/nAT5KDUCcNTZ5YPCVBAbOz5Fo6cimIiclw2aah14Q92QjRSJhR+BmSwrDf959tgEBDSKfEjzSA==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 10:46:48 -0500", "member_id"=>"26", "event_id"=>"1", "guest_count"=>"4"}, "commit"=>"Create Event registration"}
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (6.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 15:46:48', 26, 1, 4)[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/19
Completed 302 Found in 53ms (ActiveRecord: 12.0ms)


Started GET "/event_registrations/19" for 127.0.0.1 at 2017-12-06 10:47:01 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"19"}
  [1m[36mEventRegistration Load (3.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 19 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (3.5ms)
Completed 200 OK in 2316ms (Views: 1649.7ms | ActiveRecord: 3.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 10:47:06 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (28.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (275.4ms)
Completed 200 OK in 1369ms (Views: 975.7ms | ActiveRecord: 28.5ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 10:47:11 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (29.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (15.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (319.2ms)
  Rendered event_registrations/new.html.erb within layouts/application (571.4ms)
Completed 200 OK in 1747ms (Views: 1454.9ms | ActiveRecord: 44.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 10:47:16 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"0A0SaED4UR34gTdReIxkwpEtWPIGTL2RfYf3PskN56gJNnEMBE0PoQAPVrDFPrKpj4BMbLzdvy7GTBOzSTDoxw==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 10:47:12 -0500", "member_id"=>"26", "event_id"=>"1", "guest_count"=>"4"}, "commit"=>"Create Event registration"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (27.5ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 15:47:12', 26, 1, 4)[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/20
Completed 302 Found in 286ms (ActiveRecord: 33.0ms)


Started GET "/event_registrations/20" for 127.0.0.1 at 2017-12-06 10:47:17 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"20"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (2.0ms)
Completed 200 OK in 938ms (Views: 672.9ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 10:47:19 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (315.3ms)
Completed 200 OK in 2035ms (Views: 1855.8ms | ActiveRecord: 1.5ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 10:47:23 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (1.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (2.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (329.2ms)
  Rendered event_registrations/new.html.erb within layouts/application (690.0ms)
Completed 200 OK in 2435ms (Views: 2099.9ms | ActiveRecord: 3.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 10:47:28 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"9cLoMcF4KbfTKR0hYDqXCX1MI+sF5cP8gDhw8Y7vNM8s+YtVhc13CyunfMDdiEFiY+E3db90wUM785R8DtI7oA==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 10:47:25 -0500", "member_id"=>"26", "event_id"=>"1", "guest_count"=>"4"}, "commit"=>"Create Event registration"}
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (6.5ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 15:47:25', 26, 1, 4)[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/21
Completed 302 Found in 36ms (ActiveRecord: 11.5ms)


Started GET "/event_registrations/21" for 127.0.0.1 at 2017-12-06 10:47:28 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"21"}
  [1m[36mEventRegistration Load (2.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 21 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 2374ms (Views: 1536.7ms | ActiveRecord: 2.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 10:47:33 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (10.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (141.4ms)
Completed 200 OK in 1539ms (Views: 1365.0ms | ActiveRecord: 10.5ms)


Started GET "/events/new" for 127.0.0.1 at 2017-12-06 10:47:40 -0500
Processing by EventsController#new as HTML
  Rendering events/new.html.erb within layouts/application
  [1m[36mEmployee Load (30.0ms)[0m  [1m[35mcall current_employees()[0m
  Rendered events/_form.html.erb (532.9ms)
  Rendered events/new.html.erb within layouts/application (706.6ms)
Completed 200 OK in 1629ms (Views: 1428.4ms | ActiveRecord: 69.0ms)


Started POST "/events" for 127.0.0.1 at 2017-12-06 10:47:54 -0500
Processing by EventsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"+xgIaOb3aiByn+OQ2l17dnhE2R0RIKy4FmTj0SujEKfTA6jMeTSZsJm39pdZLpkVNvle4WgyObXYSBrj/ty0Eg==", "event"=>{"event_id"=>"", "title"=>"Test", "price"=>"2", "managing_employee"=>"1", "max_guests_per_person"=>"1", "max_attending"=>"4", "event_date(1i)"=>"2017", "event_date(2i)"=>"12", "event_date(3i)"=>"6", "event_date(4i)"=>"15", "event_date(5i)"=>"47"}, "commit"=>"Create Event"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (24.5ms)[0m  [1m[32mINSERT INTO `events` (`title`, `price`, `managing_employee`, `max_guests_per_person`, `max_attending`, `event_date`) VALUES ('Test', 2.0, 1, 1, 4, '2017-12-06 15:47:00')[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering events/new.html.erb within layouts/application
  [1m[36mEmployee Load (13.5ms)[0m  [1m[35mcall current_employees()[0m
  Rendered events/_form.html.erb (83.6ms)
  Rendered events/new.html.erb within layouts/application (344.2ms)
Completed 200 OK in 1768ms (Views: 1711.8ms | ActiveRecord: 40.0ms)


Started POST "/events" for 127.0.0.1 at 2017-12-06 10:48:02 -0500
Processing by EventsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"arrN01hZNbn8IpjBZdmkIdxG6AuC6SBDbhDbluRfyGVWKAlB28wi2x4uESzEabnQkbMmhb/ExoBRKqq/PzWjpQ==", "event"=>{"event_id"=>"", "title"=>"Test", "price"=>"2", "managing_employee"=>"1", "max_guests_per_person"=>"1", "max_attending"=>"4", "event_date(1i)"=>"2018", "event_date(2i)"=>"12", "event_date(3i)"=>"6", "event_date(4i)"=>"15", "event_date(5i)"=>"47"}, "commit"=>"Create Event"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (18.5ms)[0m  [1m[32mINSERT INTO `events` (`title`, `price`, `managing_employee`, `max_guests_per_person`, `max_attending`, `event_date`) VALUES ('Test', 2.0, 1, 1, 4, '2018-12-06 15:47:00')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/events/12
Completed 302 Found in 95ms (ActiveRecord: 22.5ms)


Started GET "/events/12" for 127.0.0.1 at 2017-12-06 10:48:02 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"12"}
  [1m[36mEvent Load (1.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 12 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (3.8ms)
Completed 200 OK in 1475ms (Views: 1271.2ms | ActiveRecord: 1.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-06 10:48:06 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (102.6ms)
Completed 200 OK in 1784ms (Views: 1569.2ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 10:48:13 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (2.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (23.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (132.1ms)
  Rendered event_registrations/new.html.erb within layouts/application (269.5ms)
Completed 200 OK in 1461ms (Views: 1164.3ms | ActiveRecord: 25.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 10:48:25 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Qp2qyyynFiJu8jD7UhY8BCia5TULWTh60a78fgdSmZKbpsmvaBJInpZ8URrvpOpvNjfxq7HIOsVqZRjzh2+W/Q==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 10:48:14 -0500", "member_id"=>"26", "event_id"=>"12", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 15:48:14', 26, 12, 1)[0m
  [1m[35m (10.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/22
Completed 302 Found in 41ms (ActiveRecord: 15.5ms)


Started GET "/event_registrations/22" for 127.0.0.1 at 2017-12-06 10:48:26 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"22"}
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 22 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (3.5ms)
Completed 200 OK in 1587ms (Views: 1344.9ms | ActiveRecord: 1.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 10:48:29 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (20.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (59.0ms)
Completed 200 OK in 621ms (Views: 463.3ms | ActiveRecord: 20.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 10:48:31 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (30.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (66.0ms)
  Rendered event_registrations/new.html.erb within layouts/application (279.2ms)
Completed 200 OK in 1336ms (Views: 1043.4ms | ActiveRecord: 32.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 10:48:40 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"xp+5vp1wfZao/kK1zLiBDxLYxGg3g7Nx2Y7utvHVIuYfpNra2cUjKlBwI1RxCldkDHXQ9o0Ssc5iRQo7cegtiQ==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 10:48:32 -0500", "member_id"=>"26", "event_id"=>"12", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (6.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 15:48:32', 26, 12, 1)[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/23
Completed 302 Found in 38ms (ActiveRecord: 11.0ms)


Started GET "/event_registrations/23" for 127.0.0.1 at 2017-12-06 10:48:40 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"23"}
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 23 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (3.5ms)
Completed 200 OK in 1087ms (Views: 874.2ms | ActiveRecord: 1.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 10:48:43 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (30.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (117.1ms)
Completed 200 OK in 699ms (Views: 533.5ms | ActiveRecord: 30.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 10:48:44 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (29.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (13.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (158.6ms)
  Rendered event_registrations/new.html.erb within layouts/application (476.8ms)
Completed 200 OK in 2022ms (Views: 1689.9ms | ActiveRecord: 42.5ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 10:48:49 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"LC/BnphzcG0XQVfbN2kh7mgdFIs8xvXI4mgoIa8WC8D1FKL63MYu0e/PNjqK2/eFdrAAFYZX93dZo8ysLysErw==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 10:48:46 -0500", "member_id"=>"26", "event_id"=>"1", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.5ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 15:48:46', 26, 1, 1)[0m
  [1m[35m (9.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/24
Completed 302 Found in 283ms (ActiveRecord: 17.5ms)


Started GET "/event_registrations/24" for 127.0.0.1 at 2017-12-06 10:48:49 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"24"}
  [1m[36mEventRegistration Load (10.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 24 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (1.5ms)
Completed 200 OK in 531ms (Views: 360.9ms | ActiveRecord: 10.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 10:48:52 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (10.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (80.1ms)
Completed 200 OK in 1564ms (Views: 1393.9ms | ActiveRecord: 10.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 10:48:55 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (0.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (0.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (10.0ms)
  Rendered event_registrations/new.html.erb within layouts/application (63.5ms)
Completed 200 OK in 411ms (Views: 322.6ms | ActiveRecord: 1.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 10:49:01 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"n0WVK1yVgifMl0vUWxThNfaTXZoF3pM+7rx7idMrzwFGfvZPGCDcmzQZKjXmpjde6D5JBL9PkYFVd58EUxbAbg==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 10:48:56 -0500", "member_id"=>"26", "event_id"=>"12", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 15:48:56', 26, 12, 1)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (26.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (30.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (251.7ms)
  Rendered event_registrations/new.html.erb within layouts/application (443.8ms)
Completed 200 OK in 1463ms (Views: 1245.8ms | ActiveRecord: 62.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 10:49:09 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (41.2ms)
Completed 200 OK in 1172ms (Views: 1040.2ms | ActiveRecord: 1.5ms)


  [1m[35m (30.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (5.4ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (353.9ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (70.5ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (49.6ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (7.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (80.6ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (70.3ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (90.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (68.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (88.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (82.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (85.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (67.8ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (55.5ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (33.9ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (38.3ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (41.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (37.2ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (9.8ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (4.5ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (9.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (30.6ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (32.8ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (30.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (29.5ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (27.7ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (27.5ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (29.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (46.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (61.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (4.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (7.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 15:53:50', '2017-12-06 15:53:50')[0m
  [1m[35m (10.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (27.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (366.9ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (16.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (9.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (65.7ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (84.1ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (29.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (30.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (87.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`)
      );
[0m
  [1m[35m (134.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (61.0ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (68.0ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id)
      );
[0m
  [1m[35m (83.5ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (111.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (71.6ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE
      );
[0m
  [1m[35m (67.2ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (91.3ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (9.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employeeID OR eID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( hired = hiredDate OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (46.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (42.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (19.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (12.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (19.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (20.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (17.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (13.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (10.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET title = newTitle WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (9.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);

    UPDATE events
    SET description = newDescription WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (11.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = eventID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = eventID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (31.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE eventID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (26.5ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = eventID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (43.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (49.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (21.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (20.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (19.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (11.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tankID varchar(45), employeeID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO FeedingLogs (time, food, quantity, employee, tank) VALUES (NOW(), foodGiven, quantityGiven, employeeID, tankID);
    SELECT CONCAT('feeding logged for tank ', tankID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = tank);

    SELECT * FROM feedingLogs
      WHERE ID = tank
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where ID = employee);

    SELECT * FROM feedingLogs
      WHERE ID = employee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feedingLogs where DATE(time) = feedingDate);

    SELECT * FROM feedingLogs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feedinglogs
      where (fID = feedingID OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee OR fEmployee IS NULL) AND
      (tID = tank OR tID is NULL);
  END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (25.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (20.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (4.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (13.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (19.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (5.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (10.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (19.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (9.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (16.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (27.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (27.5ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (36.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (9.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (29.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (34.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (6.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 15:58:18', '2017-12-06 15:58:18')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:01:45 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (28.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (174.6ms)
Completed 200 OK in 1229ms (Views: 1084.1ms | ActiveRecord: 31.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 11:02:20 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mMember Load (5.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (10.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (319.2ms)
  Rendered event_registrations/new.html.erb within layouts/application (453.8ms)
Completed 200 OK in 1182ms (Views: 1031.2ms | ActiveRecord: 23.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 11:02:24 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"hw1XWVBrZ5dvGM2RlzYoxV6TsHJ7mM0SujY3XsGhAAVeNjQ9FN45K5eWrHAqhP6uQD6k7MEJz60B/dPTQZwPag==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 11:02:21 -0500", "member_id"=>"26", "event_id"=>"1", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.5ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 16:02:21', 26, 1, 1)[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/19
Completed 302 Found in 31ms (ActiveRecord: 12.5ms)


Started GET "/event_registrations/19" for 127.0.0.1 at 2017-12-06 11:02:24 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"19"}
  [1m[36mEventRegistration Load (0.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 19 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (1.5ms)
Completed 200 OK in 350ms (Views: 280.4ms | ActiveRecord: 0.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:02:28 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (9.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (173.1ms)
Completed 200 OK in 1821ms (Views: 1540.4ms | ActiveRecord: 9.5ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 11:02:34 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (31.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (26.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (307.7ms)
  Rendered event_registrations/new.html.erb within layouts/application (666.0ms)
Completed 200 OK in 2365ms (Views: 2136.1ms | ActiveRecord: 57.5ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 11:02:39 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"kQazZfZgVQ8Cm43NI7ZckToS06xxFVvzC3On5+9EyaVIPdABstULs/oV7CyeBIr6JL/HMsuEWUywuENqb3nGyg==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 11:02:35 -0500", "member_id"=>"26", "event_id"=>"1", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (34.5ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 16:02:35', 26, 1, 1)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (24.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (23.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (257.2ms)
  Rendered event_registrations/new.html.erb within layouts/application (517.5ms)
Completed 200 OK in 1653ms (Views: 1541.6ms | ActiveRecord: 84.6ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:02:45 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (2.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (21.8ms)
Completed 200 OK in 1007ms (Views: 716.7ms | ActiveRecord: 2.0ms)


Started GET "/events/new" for 127.0.0.1 at 2017-12-06 11:02:48 -0500
Processing by EventsController#new as HTML
  Rendering events/new.html.erb within layouts/application
  [1m[36mEmployee Load (8.0ms)[0m  [1m[35mcall current_employees()[0m
  Rendered events/_form.html.erb (317.7ms)
  Rendered events/new.html.erb within layouts/application (558.4ms)
Completed 200 OK in 2802ms (Views: 2225.5ms | ActiveRecord: 12.0ms)


Started POST "/events" for 127.0.0.1 at 2017-12-06 11:03:08 -0500
Processing by EventsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"nDkMzR5nTe5JOmTec5q3r+L3flFwPtz3mL8EvC23Mua0IqxpgaS+fqIScdnw6VXMrEr5rQksSfpWk/2O+MiWUw==", "event"=>{"event_id"=>"", "title"=>"Test", "price"=>"2", "managing_employee"=>"1", "max_guests_per_person"=>"4", "max_attending"=>"5", "event_date(1i)"=>"2018", "event_date(2i)"=>"12", "event_date(3i)"=>"6", "event_date(4i)"=>"16", "event_date(5i)"=>"02"}, "commit"=>"Create Event"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (24.0ms)[0m  [1m[32mINSERT INTO `events` (`title`, `price`, `managing_employee`, `max_guests_per_person`, `max_attending`, `event_date`) VALUES ('Test', 2.0, 1, 4, 5, '2018-12-06 16:02:00')[0m
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/events/12
Completed 302 Found in 118ms (ActiveRecord: 30.0ms)


Started GET "/events/12" for 127.0.0.1 at 2017-12-06 11:03:08 -0500
Processing by EventsController#show as HTML
  Parameters: {"id"=>"12"}
  [1m[36mEvent Load (2.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 12 LIMIT 1[0m
  Rendering events/show.html.erb within layouts/application
  Rendered events/show.html.erb within layouts/application (4.5ms)
Completed 200 OK in 1764ms (Views: 1559.1ms | ActiveRecord: 2.5ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 11:03:15 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (30.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (95.9ms)
  Rendered event_registrations/new.html.erb within layouts/application (328.1ms)
Completed 200 OK in 1313ms (Views: 1106.3ms | ActiveRecord: 31.5ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 11:03:23 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"0A6V+638/8OAm/cA9kiEuqwnjKk2P+tfpowuGI+4XFIJNfaf6Umhf3gVluFL+lLRsoqYN4yu6eAdR8qVD4VTPQ==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 11:03:16 -0500", "member_id"=>"26", "event_id"=>"12", "guest_count"=>"4"}, "commit"=>"Create Event registration"}
  [1m[35m (30.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (29.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 16:03:16', 26, 12, 4)[0m
  [1m[35m (12.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/20
Completed 302 Found in 205ms (ActiveRecord: 71.6ms)


Started GET "/event_registrations/20" for 127.0.0.1 at 2017-12-06 11:03:23 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"20"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (4.5ms)
Completed 200 OK in 1275ms (Views: 1083.0ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:03:26 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (0.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (423.8ms)
Completed 200 OK in 1522ms (Views: 1373.0ms | ActiveRecord: 0.5ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 11:03:29 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (3.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (38.0ms)
  Rendered event_registrations/new.html.erb within layouts/application (219.2ms)
Completed 200 OK in 1214ms (Views: 984.3ms | ActiveRecord: 4.5ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 11:03:39 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"QuU3AGRsml4BiEv3cucY/GJEfu9dO7dso9fGuBMGw26b3lRkINnE4vkGKhbPVc6XfOlqceeqtdMYHCI1kzvMAQ==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 11:03:30 -0500", "member_id"=>"25", "event_id"=>"1", "guest_count"=>"2"}, "commit"=>"Create Event registration"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (12.5ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 16:03:30', 25, 1, 2)[0m
  [1m[35m (17.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/21
Completed 302 Found in 123ms (ActiveRecord: 30.5ms)


Started GET "/event_registrations/21" for 127.0.0.1 at 2017-12-06 11:03:40 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"21"}
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 21 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (3.5ms)
Completed 200 OK in 696ms (Views: 411.9ms | ActiveRecord: 1.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:03:51 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (32.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (146.0ms)
Completed 200 OK in 1077ms (Views: 881.6ms | ActiveRecord: 32.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 11:03:54 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (1.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (74.1ms)
  Rendered event_registrations/new.html.erb within layouts/application (342.7ms)
Completed 200 OK in 1539ms (Views: 1277.1ms | ActiveRecord: 2.5ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 11:04:04 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"2vBoKZJDFONJF8QSZI+fs3oxHr6OgsdjNogoN58aQD0DywtN1vZKX7GZpfPZPUnYZJwKIDQTxdyNQ8y6HydPUg==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 11:03:55 -0500", "member_id"=>"25", "event_id"=>"12", "guest_count"=>"2"}, "commit"=>"Create Event registration"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 16:03:55', 25, 12, 2)[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (25.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (26.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (375.3ms)
  Rendered event_registrations/new.html.erb within layouts/application (606.0ms)
Completed 200 OK in 1677ms (Views: 1592.9ms | ActiveRecord: 58.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:04:07 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (90.1ms)
Completed 200 OK in 2109ms (Views: 1776.4ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations/20/edit" for 127.0.0.1 at 2017-12-06 11:04:15 -0500
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"20"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (30.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (12.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (141.6ms)
  Rendered event_registrations/edit.html.erb within layouts/application (310.7ms)
Completed 200 OK in 1594ms (Views: 1330.3ms | ActiveRecord: 43.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:04:23 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (30.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (128.2ms)
Completed 200 OK in 1724ms (Views: 1499.7ms | ActiveRecord: 30.0ms)


Started GET "/event_registrations/20/edit" for 127.0.0.1 at 2017-12-06 11:04:33 -0500
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"20"}
  [1m[36mEventRegistration Load (30.2ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (2.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (95.6ms)
  Rendered event_registrations/edit.html.erb within layouts/application (899.6ms)
Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:04:36 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (30.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
Completed 200 OK in 4035ms (Views: 3712.2ms | ActiveRecord: 33.7ms)


  Rendered event_registrations/index.html.erb within layouts/application (257.4ms)
Completed 200 OK in 1722ms (Views: 1382.1ms | ActiveRecord: 30.5ms)


Started DELETE "/event_registrations/21" for 127.0.0.1 at 2017-12-06 11:04:49 -0500
Processing by EventRegistrationsController#destroy as HTML
  Parameters: {"authenticity_token"=>"s0a6qt9gjF1WfqKPar+V6/i4cpNNUy082qDMLHhoPnKP1H44XPWbP7RyK2LLD4gatU28HXB+y//lmr0FowJVsg==", "id"=>"21"}
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 21 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.5ms)[0m  [1m[31mDELETE FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 21[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations
Completed 302 Found in 98ms (ActiveRecord: 12.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:04:49 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (21.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (103.6ms)
Completed 200 OK in 1652ms (Views: 1160.5ms | ActiveRecord: 21.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 11:04:59 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (2.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (13.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (132.6ms)
  Rendered event_registrations/new.html.erb within layouts/application (386.8ms)
Completed 200 OK in 2049ms (Views: 1861.8ms | ActiveRecord: 15.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:05:03 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (0.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
Started GET "/event_registrations/20/edit" for 127.0.0.1 at 2017-12-06 11:05:05 -0500
  Rendered event_registrations/index.html.erb within layouts/application (269.7ms)
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"20"}
  [1m[36mEventRegistration Load (6.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (3.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (4.5ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (38.5ms)
  Rendered event_registrations/edit.html.erb within layouts/application (109.1ms)
Completed 200 OK in 2612ms (Views: 2131.6ms | ActiveRecord: 0.5ms)


Completed 200 OK in 669ms (Views: 504.3ms | ActiveRecord: 14.0ms)


Started PATCH "/event_registrations/20" for 127.0.0.1 at 2017-12-06 11:05:12 -0500
Processing by EventRegistrationsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"4eKhWrYjjgFi8857bwprwqN1LxIQC0YyxC6ugPcRJ1tyQPDrFfE2bubQJzkmw/LJQp6cSRd5QF2g92kIxGByHA==", "event_registration"=>{"registration_code"=>"20", "time"=>"2017-12-06 11:05:05 -0500", "member_id"=>"26", "event_id"=>"12", "guest_count"=>"2"}, "commit"=>"Update Event registration", "id"=>"20"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[33mUPDATE `event_registrations` SET `time` = '2017-12-06 16:05:05', `guest_count` = 2 WHERE `event_registrations`.`registration_code` = 20[0m
  [1m[35m (8.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/20
Completed 302 Found in 32ms (ActiveRecord: 11.0ms)


Started GET "/event_registrations/20" for 127.0.0.1 at 2017-12-06 11:05:12 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"20"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (3.5ms)
Completed 200 OK in 1052ms (Views: 934.2ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:05:15 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (14.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (287.7ms)
Completed 200 OK in 2192ms (Views: 1984.2ms | ActiveRecord: 14.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-06 11:05:22 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (30.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (24.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (378.8ms)
  Rendered event_registrations/new.html.erb within layouts/application (591.8ms)
Completed 200 OK in 2252ms (Views: 2040.2ms | ActiveRecord: 54.5ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-06 11:05:32 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"fTDTZOvw0Q/mtBNcnatoyQY5lGwn2rYS/iH0kSjqAcikC7AAr0WPsx46cr0gGb6iGJSA8p1LtK1F6hAcqNcOpw==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-06 11:05:23 -0500", "member_id"=>"25", "event_id"=>"12", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.5ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-06 16:05:23', 25, 12, 1)[0m
  [1m[35m (8.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/22
Completed 302 Found in 34ms (ActiveRecord: 12.5ms)


Started GET "/event_registrations/22" for 127.0.0.1 at 2017-12-06 11:05:32 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"22"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 22 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (2.0ms)
Completed 200 OK in 638ms (Views: 517.9ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:05:34 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (2.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (686.0ms)
Completed 200 OK in 2350ms (Views: 2115.3ms | ActiveRecord: 2.0ms)


Started GET "/event_registrations/20/edit" for 127.0.0.1 at 2017-12-06 11:05:38 -0500
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"20"}
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (0.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (11.8ms)
  Rendered event_registrations/edit.html.erb within layouts/application (69.9ms)
Completed 200 OK in 780ms (Views: 677.7ms | ActiveRecord: 3.0ms)


Started PATCH "/event_registrations/20" for 127.0.0.1 at 2017-12-06 11:05:42 -0500
Processing by EventRegistrationsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"cYPZTVr/vtIuSPwcAu3Ughl1sK9ddhDecxM4u1/5AqPiIYj8+S0GvaprFV5LJE2J+J4D9FoEFrEXyv8zbIhX5A==", "event_registration"=>{"registration_code"=>"20", "time"=>"2017-12-06 11:05:39 -0500", "member_id"=>"26", "event_id"=>"12", "guest_count"=>"3"}, "commit"=>"Update Event registration", "id"=>"20"}
  [1m[36mEventRegistration Load (10.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  [1m[35m (8.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (27.0ms)[0m  [1m[33mUPDATE `event_registrations` SET `time` = '2017-12-06 16:05:39', `guest_count` = 3 WHERE `event_registrations`.`registration_code` = 20[0m
  [1m[35m (29.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/20
Completed 302 Found in 294ms (ActiveRecord: 74.5ms)


Started GET "/event_registrations/20" for 127.0.0.1 at 2017-12-06 11:05:43 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"20"}
  [1m[36mEventRegistration Load (30.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1880ms (Views: 1439.3ms | ActiveRecord: 30.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:05:48 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (30.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (132.6ms)
Completed 200 OK in 1040ms (Views: 878.6ms | ActiveRecord: 30.0ms)


Started GET "/event_registrations/20/edit" for 127.0.0.1 at 2017-12-06 11:05:51 -0500
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"20"}
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (61.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (584.9ms)
  Rendered event_registrations/edit.html.erb within layouts/application (939.7ms)
Completed 200 OK in 2600ms (Views: 2204.3ms | ActiveRecord: 63.5ms)


Started PATCH "/event_registrations/20" for 127.0.0.1 at 2017-12-06 11:05:57 -0500
Processing by EventRegistrationsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"lz9DDHoa3KfZ4m/9dMFGTx2yUlNPtCAp7qq3zuCw5goEnRK92chkyF3Bhr89CN9E/FnhCEjGJkaKc3BG08GzTQ==", "event_registration"=>{"registration_code"=>"20", "time"=>"2017-12-06 11:05:53 -0500", "member_id"=>"26", "event_id"=>"12", "guest_count"=>"5"}, "commit"=>"Update Event registration", "id"=>"20"}
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.5ms)[0m  [1m[33mUPDATE `event_registrations` SET `time` = '2017-12-06 16:05:53', `guest_count` = 5 WHERE `event_registrations`.`registration_code` = 20[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (5.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (9.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (95.1ms)
  Rendered event_registrations/edit.html.erb within layouts/application (366.8ms)
Completed 200 OK in 2330ms (Views: 2244.6ms | ActiveRecord: 21.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-06 11:06:04 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (135.6ms)
Completed 200 OK in 1986ms (Views: 1480.4ms | ActiveRecord: 1.0ms)


  [1m[35m (24.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (305.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (16.7ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (70.7ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (63.6ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
        PRIMARY KEY (`habitat_id`), 
	CONSTRAINT valid_hyear CHECK (year_added <= YEAR(CURDATE())
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (26.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (105.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (10.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (76.3ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (45.4ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (9.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (57.4ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (100.8ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (98.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (83.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (77.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (100.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (82.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (62.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (65.9ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELESIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (26.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.4ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 17:23:06', '2017-12-06 17:23:06')[0m
  [1m[35m (3.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (25.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (286.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (71.7ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (59.3ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (83.5ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (80.6ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (90.3ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (79.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (96.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (89.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (82.6ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (68.0ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (113.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (16.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (47.5ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (48.0ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (38.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (38.5ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (6.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (7.5ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (41.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (52.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (26.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.6ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 17:34:31', '2017-12-06 17:34:31')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (26.9ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (358.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (59.4ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (82.9ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (30.6ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (29.8ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (64.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (77.7ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (68.0ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (62.7ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (80.4ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (65.3ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (64.3ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (63.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (89.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (41.0ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (29.4ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (12.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (29.2ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (36.6ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (9.7ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (4.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.9ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (32.2ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (60.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (29.3ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (21.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (30.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (9.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (21.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (17.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (24.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELESIF New.quantity = NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000;
      SET MESSAGE_TEXT = 'Must input a valid quantity';
  ELSEIF New.temp    
  END IF;

end;
[0m
  [1m[35m (14.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (25.1ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 17:39:39', '2017-12-06 17:39:39')[0m
  [1m[35m (11.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (25.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (311.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (70.0ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (57.9ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (84.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (89.6ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (89.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (71.5ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (121.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (72.3ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (69.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (88.7ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (100.2ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.7ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (32.6ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (31.2ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.8ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (5.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (35.8ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (44.2ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.9ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (29.9ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (31.9ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELESIF New.quantity = NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000';
      SET MESSAGE_TEXT = 'Must input a valid quantity';
  ELSEIF New.temp    
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (6.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (2.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (3.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 17:42:08', '2017-12-06 17:42:08')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (7.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (287.8ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (4.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (4.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (60.5ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (60.9ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (74.2ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (72.0ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (68.7ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (77.0ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (109.0ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (90.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (90.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (72.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (83.0ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (43.9ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (27.5ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (18.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (39.1ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (35.6ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (38.7ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (36.5ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (3.8ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELESIF New.quantity = NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';
  ELSEIF New.temp    
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.5ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 17:48:25', '2017-12-06 17:48:25')[0m
  [1m[35m (2.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (25.7ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (315.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.9ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.4ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (69.2ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (59.8ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (6.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (90.7ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (90.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (88.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (72.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (80.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (107.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (97.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (79.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (118.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (11.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (6.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (6.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (9.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (8.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (6.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (11.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (52.0ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (35.0ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (9.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (5.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (56.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (47.5ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (6.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (4.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (9.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (6.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (8.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (13.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (7.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (10.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (38.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (35.5ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';
  ELSEIF New.temp    
  END IF;

end;
[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (4.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (26.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (29.6ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (26.6ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 17:51:10', '2017-12-06 17:51:10')[0m
  [1m[35m (29.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (24.9ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (387.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (52.0ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (66.5ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (31.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (30.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (75.6ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (78.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (108.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (102.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (141.3ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (75.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (95.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (67.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (99.6ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (4.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (34.5ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (44.5ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (12.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (5.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (37.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (28.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (11.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (33.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (35.5ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (7.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (32.5ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (5.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (6.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (27.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (29.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (29.1ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (29.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELESIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 17:55:04', '2017-12-06 17:55:04')[0m
  [1m[35m (3.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (24.7ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (366.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (54.4ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (81.7ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (29.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (9.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (64.5ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (70.0ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (68.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (52.2ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (64.9ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (70.3ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (78.2ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (58.2ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (94.3ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (31.2ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (33.5ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (5.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (34.9ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (32.1ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (10.9ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (4.5ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (66.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (45.5ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (8.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (4.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (9.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (14.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (15.5ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (42.5ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (39.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (28.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (12.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (18.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (17.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (16.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (5.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (35.0ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (44.5ms)[0m  [1m[35mCREATE TRIGGER add_habitat
BEFORE INSERT ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  END IF;
end;
[0m
  [1m[35m (10.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (5.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (8.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (13.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (14.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (7.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (11.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (58.5ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (59.5ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (7.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (11.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (11.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (11.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (9.5ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (13.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (12.5ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (30.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (29.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (4.5ms)[0m  [1m[35mCREATE TRIGGER add_treatment
BEFORE UPDATE ON treatment_logs
  FOR EACH ROW
BEGIN
  IF New.medicine = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a medicine';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity < 0 THEN
    SIGNAL SQLSTATE 'HY000;
      SET MESSAGE_TEXT = 'Must input a valid quantity';
  ELSEIF New.temp    
  END IF;

end;
[0m
  [1m[35m (4.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 17:57:08', '2017-12-06 17:57:08')[0m
  [1m[35m (7.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (26.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (471.3ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (42.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (99.6ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (75.1ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (12.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (68.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (113.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (70.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (72.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (70.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (70.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (73.6ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (105.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (69.4ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (27.8ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (37.1ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (28.3ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (30.9ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (32.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (32.6ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (11.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.6ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (34.0ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (3.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (39.5ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (36.6ms)[0m  [1m[35mCREATE TRIGGER add_habitat
BEFORE INSERT ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  END IF;
end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (36.4ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (55.6ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (30.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (26.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (29.8ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (25.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (27.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (30.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (32.7ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (37.7ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (3.7ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (1.5ms)[0m  [1m[35mCREATE TRIGGER add_treatment
BEFORE UPDATE ON treatment_logs
  FOR EACH ROW
BEGIN
  IF New.medicine = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a medicine';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity < 0 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';
  ELSEIF New.temp    
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.6ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 17:58:58', '2017-12-06 17:58:58')[0m
  [1m[35m (3.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (25.3ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (439.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (2.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (9.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (4.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (85.1ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (79.1ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (14.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (60.5ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (57.5ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (97.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (110.7ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (81.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (86.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (79.6ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (67.0ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (90.6ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (36.5ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (37.5ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (17.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (29.7ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (39.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (9.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (27.1ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (24.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (3.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (19.9ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (1.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (21.3ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (22.9ms)[0m  [1m[35mCREATE TRIGGER add_habitat
BEFORE INSERT ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  END IF;
end;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (3.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (33.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (42.9ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (4.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (39.1ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (35.9ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (65.6ms)[0m  [1m[35mCREATE TRIGGER add_treatment
BEFORE UPDATE ON treatment_logs
  FOR EACH ROW
BEGIN
  IF New.medicine = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a medicine';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity < 0 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';   
  END IF;

end;
[0m
  [1m[35m (27.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (30.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (30.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTanks (20171206162319)
  [1m[35m (15.9ms)[0m  [1m[35m
CREATE TRIGGER update_tank
BEFORE UPDATE ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELESIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  ELSEIF New.volume < Old.volume THEN
    SIGNAL SQLSTATE 'HY000'
    	SET MESSAGE_TEXT = 'Cannot shrink a tank.';
  END IF;

end;

[0m
  [1m[35m (30.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (5.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (7.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.5ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 18:01:55', '2017-12-06 18:01:55')[0m
  [1m[35m (15.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (25.6ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (370.7ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (73.5ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (72.2ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (30.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (29.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (64.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (55.8ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (59.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (60.0ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (78.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (93.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (65.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (73.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (108.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (7.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (4.5ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (8.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (6.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (51.0ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (60.5ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (11.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (9.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (21.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (3.5ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (15.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (34.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (41.5ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (10.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (15.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (7.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (8.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (12.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (15.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (39.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (55.5ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (9.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (17.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (12.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (11.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (10.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (18.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (18.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (11.5ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (45.0ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (17.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (9.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (22.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (10.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (24.4ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (28.9ms)[0m  [1m[35mCREATE TRIGGER add_habitat
BEFORE INSERT ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  END IF;
end;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (1.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (27.2ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (25.5ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (9.6ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (32.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (35.1ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (32.1ms)[0m  [1m[35mCREATE TRIGGER add_treatment
BEFORE UPDATE ON treatment_logs
  FOR EACH ROW
BEGIN
  IF New.medicine = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a medicine';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity < 0 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';   
  END IF;

end;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (4.1ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTanks (20171206162319)
  [1m[35m (1.5ms)[0m  [1m[35m
CREATE TRIGGER update_tank
BEFORE UPDATE ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  ELSEIF New.volume < Old.volume THEN
    SIGNAL SQLSTATE 'HY000'
    	SET MESSAGE_TEXT = 'Cannot shrink a tank.';
  END IF;

end;

[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 18:04:00', '2017-12-06 18:04:00')[0m
  [1m[35m (5.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (24.8ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (395.3ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (90.6ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (79.1ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (30.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (29.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (95.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (84.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (92.6ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (74.6ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (72.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (58.5ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (57.5ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (47.5ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (73.6ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (5.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (7.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (5.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (35.0ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (39.5ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (9.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (33.5ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (43.5ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (15.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (3.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (14.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (11.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (15.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (9.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (42.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (41.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (9.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (8.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (5.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (10.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (12.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (10.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (36.0ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (10.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (9.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (15.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (42.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (12.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (9.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (21.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (27.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (14.5ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (51.5ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (51.0ms)[0m  [1m[35mCREATE TRIGGER add_habitat
BEFORE INSERT ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  END IF;
end;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (8.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (1.5ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (21.5ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (27.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (10.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (29.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (21.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (22.0ms)[0m  [1m[35mCREATE TRIGGER add_treatment
BEFORE UPDATE ON treatment_logs
  FOR EACH ROW
BEGIN
  IF New.medicine = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a medicine';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity < 0 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';   
  END IF;

end;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (9.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTanks (20171206162319)
  [1m[35m (2.0ms)[0m  [1m[35m
CREATE TRIGGER update_tank
BEFORE UPDATE ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  ELSEIF New.volume < Old.volume THEN
    SIGNAL SQLSTATE 'HY000'
    	SET MESSAGE_TEXT = 'Cannot shrink a tank.';
  END IF;

end;

[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 18:07:00', '2017-12-06 18:07:00')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (25.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (366.9ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (59.0ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (72.2ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (29.5ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (29.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (110.6ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (77.3ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (65.4ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (51.7ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (62.9ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (70.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (70.9ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (72.8ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (90.3ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (36.6ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (45.6ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (4.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.4ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (31.2ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (40.6ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (19.6ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (9.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (8.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (28.7ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (49.1ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (55.1ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (9.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (29.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (28.7ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (28.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (30.0ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.8ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (36.2ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (34.4ms)[0m  [1m[35mCREATE TRIGGER add_habitat
BEFORE INSERT ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  END IF;
end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (32.4ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (30.9ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (34.1ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (30.6ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (5.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (37.1ms)[0m  [1m[35mCREATE TRIGGER add_treatment
BEFORE UPDATE ON treatment_logs
  FOR EACH ROW
BEGIN
  IF New.medicine = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a medicine';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity < 0 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';   
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.3ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTanks (20171206162319)
  [1m[35m (39.6ms)[0m  [1m[35m
CREATE TRIGGER update_tank
BEFORE UPDATE ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  ELSEIF New.volume < Old.volume THEN
    SIGNAL SQLSTATE 'HY000'
    	SET MESSAGE_TEXT = 'Cannot shrink a tank.';
  END IF;

end;

[0m
  [1m[35m (32.1ms)[0m  [1m[35m
CREATE TRIGGER add_tank
BEFORE INSERT ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  END IF;

end;

[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171206162319')[0m
  [1m[35m (9.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (6.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 18:07:37', '2017-12-06 18:07:37')[0m
  [1m[35m (9.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events" for 127.0.0.1 at 2017-12-06 13:10:13 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (28.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (176.1ms)
Completed 200 OK in 1539ms (Views: 1408.2ms | ActiveRecord: 31.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-06 13:19:39 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (8.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (518.4ms)
Completed 200 OK in 2588ms (Views: 2312.0ms | ActiveRecord: 14.5ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-12-06 13:20:16 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mTank Load (3.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (171.6ms)
  Rendered animals/new.html.erb within layouts/application (234.2ms)
Completed 200 OK in 518ms (Views: 454.4ms | ActiveRecord: 6.0ms)


Started POST "/animals" for 127.0.0.1 at 2017-12-06 13:20:19 -0500
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"lY6IBptT7mBhrYyyiy0im57ArmR1w5o9hxIpDRww7dEiVAkksTrXK826iSeuimhTqZiexx5/HFTWRxxslBxp5A==", "animal"=>{"animal_id"=>"", "name"=>"", "species"=>"", "tank_id"=>"11", "birth_date(1i)"=>"2017", "birth_date(2i)"=>"12", "birth_date(3i)"=>"6", "birth_date(4i)"=>"18", "birth_date(5i)"=>"20"}, "commit"=>"Create Animal"}
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35mSQL (9.0ms)[0m  [1m[32mINSERT INTO `animals` (`name`, `species`, `tank_id`, `birth_date`) VALUES ('', '', 11, '2017-12-06 18:20:00')[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
Completed 500 Internal Server Error in 858ms (ActiveRecord: 12.0ms)


  
NoMethodError (undefined method `errors' for nil:NilClass):
  
app/controllers/animals_controller.rb:39:in `rescue in block in create'
app/controllers/animals_controller.rb:30:in `block in create'
app/controllers/animals_controller.rb:29:in `create'
Started POST "/animals" for 127.0.0.1 at 2017-12-06 13:21:28 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"lY6IBptT7mBhrYyyiy0im57ArmR1w5o9hxIpDRww7dEiVAkksTrXK826iSeuimhTqZiexx5/HFTWRxxslBxp5A==", "animal"=>{"animal_id"=>"", "name"=>"", "species"=>"", "tank_id"=>"11", "birth_date(1i)"=>"2017", "birth_date(2i)"=>"12", "birth_date(3i)"=>"6", "birth_date(4i)"=>"18", "birth_date(5i)"=>"20"}, "commit"=>"Create Animal"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `animals` (`name`, `species`, `tank_id`, `birth_date`) VALUES ('', '', 11, '2017-12-06 18:20:00')[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/new.html.erb within layouts/application
  [1m[36mTank Load (0.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (295.0ms)
  Rendered animals/new.html.erb within layouts/application (406.1ms)
Completed 200 OK in 1356ms (Views: 1154.7ms | ActiveRecord: 18.0ms)


Started POST "/animals" for 127.0.0.1 at 2017-12-06 13:22:10 -0500
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"S6InNbox68f5buxl1tduxvWq3vPJCnhnurc3TUHuAH13MOOnOaT8pRtiZYh3Z3M3uF8QffQnnqSFjUZkmoRrvQ==", "animal"=>{"animal_id"=>"", "name"=>"", "species"=>"q", "tank_id"=>"11", "birth_date(1i)"=>"2017", "birth_date(2i)"=>"12", "birth_date(3i)"=>"14", "birth_date(4i)"=>"18", "birth_date(5i)"=>"20"}, "commit"=>"Create Animal"}
  [1m[35m (3.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (12.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35mSQL (14.5ms)[0m  [1m[32mINSERT INTO `animals` (`name`, `species`, `tank_id`, `birth_date`) VALUES ('', 'q', 11, '2017-12-14 18:20:00')[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/new.html.erb within layouts/application
  [1m[36mTank Load (3.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (100.6ms)
  Rendered animals/new.html.erb within layouts/application (356.8ms)
Completed 200 OK in 2059ms (Views: 1960.4ms | ActiveRecord: 34.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-06 13:22:18 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (3.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (599.4ms)
Completed 200 OK in 1968ms (Views: 1783.5ms | ActiveRecord: 3.0ms)


Started GET "/animals/1/edit" for 127.0.0.1 at 2017-12-06 13:22:22 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (0.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (12.0ms)
  Rendered animals/edit.html.erb within layouts/application (73.6ms)
Completed 200 OK in 889ms (Views: 602.4ms | ActiveRecord: 2.0ms)


Started PATCH "/animals/1" for 127.0.0.1 at 2017-12-06 13:22:27 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Lvp3HrKINg99PSHj7DehmWKFGhD3lmVQTZcqfKnc5qY7tPfrjVTqJPYYQqANBVf13kvLxG/qHYGRNl+NLVL8Pw==", "animal"=>{"animal_id"=>"1", "name"=>"", "species"=>"Piranh", "tank_id"=>"1", "birth_date(1i)"=>"2010", "birth_date(2i)"=>"1", "birth_date(3i)"=>"18", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"1"}
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
Completed 500 Internal Server Error in 1411ms (ActiveRecord: 1.5ms)


  
NoMethodError (undefined method `strip' for nil:NilClass):
  
app/controllers/animals_controller.rb:59:in `rescue in block in update'
app/controllers/animals_controller.rb:50:in `block in update'
app/controllers/animals_controller.rb:49:in `update'
Started GET "/members" for 127.0.0.1 at 2017-12-06 13:26:07 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (4.0ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (43.5ms)
Completed 200 OK in 978ms (Views: 836.9ms | ActiveRecord: 7.5ms)


Started GET "/members/2/edit" for 127.0.0.1 at 2017-12-06 13:26:49 -0500
Processing by MembersController#edit as HTML
  Parameters: {"id"=>"2"}
  [1m[35m (10.6ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mMember Load (11.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 2 LIMIT 1[0m
  Rendering members/edit.html.erb within layouts/application
  Rendered members/_form.html.erb (325.7ms)
  Rendered members/edit.html.erb within layouts/application (1005.7ms)
Completed 200 OK in 2634ms (Views: 2310.2ms | ActiveRecord: 21.6ms)


Started PATCH "/members/2" for 127.0.0.1 at 2017-12-06 13:26:56 -0500
Processing by MembersController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"OrDlC4nnbLxuIkPySF10pcUNuYg9XVpbWDZ7FismG7rEigbb0m/g/OhQ8d+PUqlIJuC59mocC4nCx9TXwTlimA==", "member"=>{"member_id"=>"2", "first_name"=>"", "last_name"=>"", "date_joined"=>"2017-12-06", "expiration_date"=>"2019-06-06 13:26:51 -0400", "fee"=>"100"}, "commit"=>"Update Member", "id"=>"2"}
  [1m[36mMember Load (1.5ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 2 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[33mUPDATE `members` SET `first_name` = '', `last_name` = '', `date_joined` = '2017-12-06', `expiration_date` = '2019-06-06', `fee` = 100.0 WHERE `members`.`member_id` = 2[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering members/edit.html.erb within layouts/application
  Rendered members/_form.html.erb (9.0ms)
  Rendered members/edit.html.erb within layouts/application (195.1ms)
Completed 200 OK in 1408ms (Views: 1376.0ms | ActiveRecord: 7.0ms)


Started PATCH "/members/2" for 127.0.0.1 at 2017-12-06 13:27:04 -0500
Processing by MembersController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"b6IstqXFZeSaGG3grg4CZO+OkTvPQ74RVJc+LoSMsLVTMOgkJlByhngU5A0Pvh+VontftfJuWNJrrU8HX+bbdQ==", "member"=>{"member_id"=>"2", "first_name"=>"a", "last_name"=>"", "date_joined"=>"2017-12-06", "expiration_date"=>"2019-06-06 13:26:56 -0400", "fee"=>"100"}, "commit"=>"Update Member", "id"=>"2"}
  [1m[36mMember Load (2.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 2 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.5ms)[0m  [1m[33mUPDATE `members` SET `first_name` = 'a', `last_name` = '', `date_joined` = '2017-12-06', `expiration_date` = '2019-06-06', `fee` = 100.0 WHERE `members`.`member_id` = 2[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering members/edit.html.erb within layouts/application
  Rendered members/_form.html.erb (15.5ms)
  Rendered members/edit.html.erb within layouts/application (394.8ms)
Completed 200 OK in 2321ms (Views: 2219.5ms | ActiveRecord: 9.0ms)


Started PATCH "/members/2" for 127.0.0.1 at 2017-12-06 13:27:10 -0500
Processing by MembersController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"VX0PkYp40Vsc+IAciMaOQ6UmRzFNamNdg8+QMU79lKxp78sDCe3GOf70CfEpdpOy6NOJv3BHhZ689eEYlZf/bA==", "member"=>{"member_id"=>"2", "first_name"=>"a", "last_name"=>"b", "date_joined"=>"2017-12-06", "expiration_date"=>"2019-06-06 13:27:06 -0400", "fee"=>"100"}, "commit"=>"Update Member", "id"=>"2"}
  [1m[36mMember Load (1.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 2 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (12.0ms)[0m  [1m[33mUPDATE `members` SET `first_name` = 'a', `last_name` = 'b', `date_joined` = '2017-12-06', `expiration_date` = '2019-06-06', `fee` = 100.0 WHERE `members`.`member_id` = 2[0m
  [1m[35m (39.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/members/2
Completed 302 Found in 199ms (ActiveRecord: 53.5ms)


Started GET "/members/2" for 127.0.0.1 at 2017-12-06 13:27:10 -0500
Processing by MembersController#show as HTML
  Parameters: {"id"=>"2"}
  [1m[36mMember Load (1.0ms)[0m  [1m[34mSELECT  `members`.* FROM `members` WHERE `members`.`member_id` = 2 LIMIT 1[0m
  Rendering members/show.html.erb within layouts/application
  Rendered members/show.html.erb within layouts/application (4.0ms)
Completed 200 OK in 545ms (Views: 433.1ms | ActiveRecord: 1.0ms)


Started GET "/members" for 127.0.0.1 at 2017-12-06 13:27:12 -0500
Processing by MembersController#index as HTML
  Rendering members/index.html.erb within layouts/application
  [1m[36mMember Load (1.0ms)[0m  [1m[34mSELECT `members`.* FROM `members`[0m
  Rendered members/index.html.erb within layouts/application (86.1ms)
Completed 200 OK in 1189ms (Views: 1072.7ms | ActiveRecord: 1.0ms)


Started PATCH "/animals/1" for 127.0.0.1 at 2017-12-06 13:27:23 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Lvp3HrKINg99PSHj7DehmWKFGhD3lmVQTZcqfKnc5qY7tPfrjVTqJPYYQqANBVf13kvLxG/qHYGRNl+NLVL8Pw==", "animal"=>{"animal_id"=>"1", "name"=>"", "species"=>"Piranh", "tank_id"=>"1", "birth_date(1i)"=>"2010", "birth_date(2i)"=>"1", "birth_date(3i)"=>"18", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"1"}
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
Completed 500 Internal Server Error in 857ms (ActiveRecord: 20.0ms)


  
NoMethodError (undefined method `strip' for nil:NilClass):
  
app/controllers/animals_controller.rb:59:in `rescue in block in update'
app/controllers/animals_controller.rb:50:in `block in update'
app/controllers/animals_controller.rb:49:in `update'
Started GET "/animals/" for 127.0.0.1 at 2017-12-06 13:27:59 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (30.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (309.2ms)
Completed 200 OK in 1296ms (Views: 1006.5ms | ActiveRecord: 30.5ms)


Started GET "/animals/1/edit" for 127.0.0.1 at 2017-12-06 13:28:02 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mAnimal Load (10.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (27.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (340.3ms)
  Rendered animals/edit.html.erb within layouts/application (699.0ms)
Completed 200 OK in 2185ms (Views: 1949.3ms | ActiveRecord: 60.5ms)


Started PATCH "/animals/1" for 127.0.0.1 at 2017-12-06 13:28:08 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"nTVLAP3bVBNzBk8RdDzUI4Pq0VgfWvuZnvAGMV4bMxqIe8v1wgeIOPgjLFKVDiJPPyQAjIcmg0hCUXPA2pUpgw==", "animal"=>{"animal_id"=>"1", "name"=>"", "species"=>"Piranha", "tank_id"=>"1", "birth_date(1i)"=>"2012", "birth_date(2i)"=>"1", "birth_date(3i)"=>"18", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"1"}
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
Completed 500 Internal Server Error in 948ms (ActiveRecord: 1.5ms)


  
NoMethodError (undefined method `strip' for nil:NilClass):
  
app/controllers/animals_controller.rb:59:in `rescue in block in update'
app/controllers/animals_controller.rb:50:in `block in update'
app/controllers/animals_controller.rb:49:in `update'
Started GET "/animals" for 127.0.0.1 at 2017-12-06 13:34:21 -0500
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (27.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (290.3ms)
Completed 200 OK in 2766ms (Views: 2600.3ms | ActiveRecord: 34.1ms)


Started GET "/animals/1/edit" for 127.0.0.1 at 2017-12-06 13:35:07 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (9.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (10.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (468.3ms)
  Rendered animals/edit.html.erb within layouts/application (833.1ms)
Completed 200 OK in 2341ms (Views: 2085.6ms | ActiveRecord: 37.5ms)


Started PATCH "/animals/1" for 127.0.0.1 at 2017-12-06 13:35:16 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"F83fvyVSPY/gd0CnLAob2uYqULTmyT73zslrQcA+QusCg19KGo7hpGtSI+TNOO22WuSBYH61RiYSaB6wRLBYcg==", "animal"=>{"animal_id"=>"1", "name"=>"", "species"=>"Piranh", "tank_id"=>"1", "birth_date(1i)"=>"2010", "birth_date(2i)"=>"1", "birth_date(3i)"=>"18", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"1"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (27.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (201.1ms)
  Rendered animals/edit.html.erb within layouts/application (341.7ms)
Completed 200 OK in 2177ms (Views: 953.0ms | ActiveRecord: 28.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-06 13:39:52 -0500
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (18.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (140.6ms)
Completed 200 OK in 1281ms (Views: 1098.0ms | ActiveRecord: 23.0ms)


Started GET "/animals/1/edit" for 127.0.0.1 at 2017-12-06 13:40:55 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (11.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (25.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (548.9ms)
  Rendered animals/edit.html.erb within layouts/application (979.2ms)
Completed 200 OK in 3008ms (Views: 2708.9ms | ActiveRecord: 51.0ms)


Started PATCH "/animals/1" for 127.0.0.1 at 2017-12-06 13:41:02 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"nQk0ylvD4u6spVJfJW2vlW/YTvzngIxiivpXW7F5XleIR7Q/ZB8+xSeAMRzEX1n50xafKH/89LNWWyKqNfdEzg==", "animal"=>{"animal_id"=>"1", "name"=>"", "species"=>"Piranh", "tank_id"=>"1", "birth_date(1i)"=>"2010", "birth_date(2i)"=>"1", "birth_date(3i)"=>"18", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"1"}
  [1m[36mAnimal Load (10.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[35m (6.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35mSQL (3.0ms)[0m  [1m[33mUPDATE `animals` SET `name` = '', `species` = 'Piranh' WHERE `animals`.`animal_id` = 1[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (7.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (37.0ms)
  Rendered animals/edit.html.erb within layouts/application (369.8ms)
Completed 200 OK in 2106ms (Views: 1626.9ms | ActiveRecord: 29.5ms)


Started PATCH "/animals/1" for 127.0.0.1 at 2017-12-06 13:41:19 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"e8syBpwYJ4aTOEWa9Nyrkq/XgQbJzeXFdCcLBeW4L1ZHWfaUH40w5HE0zHdVbLZj4iJPiPTgAwZLHXosPtJElg==", "animal"=>{"animal_id"=>"1", "name"=>"", "species"=>"Piranha", "tank_id"=>"1", "birth_date(1i)"=>"2006", "birth_date(2i)"=>"1", "birth_date(3i)"=>"18", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"1"}
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[35m (4.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (2.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35mSQL (2.5ms)[0m  [1m[33mUPDATE `animals` SET `name` = '', `birth_date` = '2006-01-18 00:00:00' WHERE `animals`.`animal_id` = 1[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (23.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (170.1ms)
  Rendered animals/edit.html.erb within layouts/application (301.7ms)
Completed 200 OK in 970ms (Views: 878.0ms | ActiveRecord: 33.5ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-06 13:41:26 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (4.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (14.0ms)
Completed 200 OK in 413ms (Views: 338.9ms | ActiveRecord: 4.0ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-06 13:41:27 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (9.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (454.9ms)
  Rendered tanks/new.html.erb within layouts/application (736.6ms)
Completed 200 OK in 2346ms (Views: 2056.8ms | ActiveRecord: 14.5ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-06 13:41:32 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"6/YfN5n/+LJUyYpliFGR0DSBLNLjTuf1v/VJlqwaT2rsvWVF90600Nw8E9hGQdHKtCi95DSdae+mb6WIty6+6w==", "tank"=>{"tank_id"=>"", "name"=>"", "description"=>"", "water_type"=>"fresh", "volume"=>"", "temperature"=>"", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (6.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `year_built`, `habitat_id`) VALUES ('', '', 'fresh', 2017, 1)[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (0.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (12.0ms)
  Rendered tanks/new.html.erb within layouts/application (80.1ms)
Completed 200 OK in 439ms (Views: 412.2ms | ActiveRecord: 9.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-06 13:41:35 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"aAiGpP/83spIsXZIPQiJeRxASNAuS0eYXGCxoIeIvgNUmkI2fGnJqKq9/6WcuJSIUbWGXhNmoVtjWsCJXOLVww==", "tank"=>{"tank_id"=>"", "name"=>"a", "description"=>"", "water_type"=>"fresh", "volume"=>"", "temperature"=>"", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (1.5ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (2.5ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `year_built`, `habitat_id`) VALUES ('a', '', 'fresh', 2017, 1)[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (1.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (17.5ms)
  Rendered tanks/new.html.erb within layouts/application (174.6ms)
Completed 200 OK in 1361ms (Views: 1333.2ms | ActiveRecord: 6.5ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-06 13:41:38 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"9tZa2IDTQRxj0KICpjU39y8RC3hEqu7JQXZkpSVtTAnKRJ5KA0ZWfoHcK+8HhSoGYuTF9nmHCAp+TBWM/gcnyQ==", "tank"=>{"tank_id"=>"", "name"=>"a", "description"=>"b", "water_type"=>"fresh", "volume"=>"", "temperature"=>"", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (1.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `year_built`, `habitat_id`) VALUES ('a', 'b', 'fresh', 2017, 1)[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (0.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (10.0ms)
  Rendered tanks/new.html.erb within layouts/application (72.1ms)
Completed 200 OK in 464ms (Views: 373.8ms | ActiveRecord: 4.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-06 13:41:46 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"+sFpE/x5TYS9G1nz9L2ajU1TREiM9Ej4hP/Hjit2gMfGU62Bf+xa5l8X0B5VDYd8AKaKxrHZrju7xban8BzrBw==", "tank"=>{"tank_id"=>"", "name"=>"a", "description"=>"b", "water_type"=>"fresh", "volume"=>"-1", "temperature"=>"-1", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (15.5ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES ('a', 'b', 'fresh', -1.0, -1.0, 2017, 1)[0m
  [1m[35m (8.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (18.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (129.1ms)
  Rendered tanks/new.html.erb within layouts/application (335.2ms)
Completed 200 OK in 1747ms (Views: 1609.0ms | ActiveRecord: 45.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-06 13:41:52 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"D5z/7agq9ZnZVKJWL5zZfTWJA4GvZbAnQVecOqaHgjszDjt/K7/i+ztYK7uOLMSMeHzND5JIVuR+be0Tfe3p+w==", "tank"=>{"tank_id"=>"", "name"=>"a", "description"=>"b", "water_type"=>"fresh", "volume"=>"500", "temperature"=>"-1", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (1.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES ('a', 'b', 'fresh', 500.0, -1.0, 2017, 1)[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (0.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (12.0ms)
  Rendered tanks/new.html.erb within layouts/application (99.6ms)
Completed 200 OK in 668ms (Views: 576.6ms | ActiveRecord: 4.5ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-06 13:41:57 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"3lIlh4lh8p4iZ4bDCeV8lc45H1Mg+xFYGm3G0vcrITXiwOEVCvTl/MBrDy6oVWFkg8zR3R3W95slV7f7LEFK9Q==", "tank"=>{"tank_id"=>"", "name"=>"a", "description"=>"b", "water_type"=>"fresh", "volume"=>"500", "temperature"=>"2", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (19.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (7.5ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES ('a', 'b', 'fresh', 500.0, 2.0, 2017, 1)[0m
  [1m[35m (20.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/15
Completed 302 Found in 202ms (ActiveRecord: 47.0ms)


Started GET "/tanks/15" for 127.0.0.1 at 2017-12-06 13:41:57 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (2.0ms)
Completed 200 OK in 927ms (Views: 825.9ms | ActiveRecord: 1.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-06 13:42:00 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (24.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (93.6ms)
Completed 200 OK in 1778ms (Views: 1517.5ms | ActiveRecord: 24.5ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-06 13:42:04 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (11.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (7.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (19.0ms)
  Rendered tanks/edit.html.erb within layouts/application (165.1ms)
Completed 200 OK in 924ms (Views: 733.4ms | ActiveRecord: 18.5ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-06 13:42:08 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"CDERuqFJTSYQugaS2pkl4+bKQWQeIFA4TuUuWpDvDTofSUXFDDN+uHuA9s6UoRRBQvgby6xSY4LkEqRPnd52hA==", "tank"=>{"tank_id"=>"1", "name"=>"", "description"=>"Meet the menacing inhabitants of the Amazon River!", "water_type"=>"fresh", "volume"=>"2000.0", "temperature"=>"76.0", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (1.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (2.5ms)[0m  [1m[33mUPDATE `tanks` SET `name` = '', `year_built` = 2017 WHERE `tanks`.`tank_id` = 1[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (1.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (16.0ms)
  Rendered tanks/edit.html.erb within layouts/application (162.6ms)
Completed 200 OK in 1280ms (Views: 1233.0ms | ActiveRecord: 7.0ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-06 13:42:15 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"EqBG2wV3kWM23WwXFiUXy/YcM9QrDFao0wg3kWrN9o4uMoJJhuKGAdTR5fq3lQo6u+n9WhYhsGvsMka4saedTg==", "tank"=>{"tank_id"=>"1", "name"=>"a", "description"=>"", "water_type"=>"fresh", "volume"=>"2000.0", "temperature"=>"76.0", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (8.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (7.5ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (2.5ms)[0m  [1m[33mUPDATE `tanks` SET `name` = 'a', `description` = '', `year_built` = 2017 WHERE `tanks`.`tank_id` = 1[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (0.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (18.5ms)
  Rendered tanks/edit.html.erb within layouts/application (193.6ms)
Completed 200 OK in 1760ms (Views: 1555.6ms | ActiveRecord: 21.0ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-06 13:42:24 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"dNI9YSjpKK9YLvXRtSoNVy9MGFugu6DpisKaeZjiUOhIQPnzq3w/zboifDwUmhCmYrnW1Z2WRiq1+OtQQ4g7KA==", "tank"=>{"tank_id"=>"1", "name"=>"a", "description"=>"b", "water_type"=>"fresh", "volume"=>"2", "temperature"=>"76.0", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (31.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (29.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (21.5ms)[0m  [1m[33mUPDATE `tanks` SET `name` = 'a', `description` = 'b', `volume` = 2.0, `year_built` = 2017 WHERE `tanks`.`tank_id` = 1[0m
  [1m[35m (4.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (49.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (135.6ms)
  Rendered tanks/edit.html.erb within layouts/application (429.8ms)
Completed 200 OK in 2293ms (Views: 1686.5ms | ActiveRecord: 138.1ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-06 13:42:34 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"S5K87kWhAIkzjClzqck1MwqGE5wtud1dpuU/4oKv1U93AHh8xjQX69GAoJ4IeSjCR3PdEhCUO56Z307LWcW+jw==", "tank"=>{"tank_id"=>"1", "name"=>"a", "description"=>"b", "water_type"=>"fresh", "volume"=>"500", "temperature"=>"-1", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (4.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (10.5ms)[0m  [1m[33mUPDATE `tanks` SET `name` = 'a', `description` = 'b', `volume` = 500.0, `temperature` = -1.0, `year_built` = 2017 WHERE `tanks`.`tank_id` = 1[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (31.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (120.6ms)
  Rendered tanks/edit.html.erb within layouts/application (372.3ms)
Completed 200 OK in 1714ms (Views: 1562.9ms | ActiveRecord: 49.5ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-06 13:42:39 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Nb8Ps2yV026NgFibvj4sDHnGBf77IpAj7fexzF1LgcoJLcsh7wDEDG+M0XYfjjH9NDPLcMYPduDSzcDlhiHqCg==", "tank"=>{"tank_id"=>"1", "name"=>"a", "description"=>"b", "water_type"=>"fresh", "volume"=>"500", "temperature"=>"5", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (24.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (0.5ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (9.0ms)[0m  [1m[33mUPDATE `tanks` SET `name` = 'a', `description` = 'b', `volume` = 500.0, `temperature` = 5.0, `year_built` = 2017 WHERE `tanks`.`tank_id` = 1[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (1.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (11.5ms)
  Rendered tanks/edit.html.erb within layouts/application (140.1ms)
Completed 200 OK in 953ms (Views: 787.7ms | ActiveRecord: 36.5ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-06 13:42:45 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (16.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (94.1ms)
Completed 200 OK in 2157ms (Views: 1692.5ms | ActiveRecord: 16.0ms)


Started GET "/habitats" for 127.0.0.1 at 2017-12-06 13:42:52 -0500
  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/controllers/habitats_controller.rb:85: syntax error, unexpected end-of-input, expecting keyword_end):
  
app/controllers/habitats_controller.rb:85: syntax error, unexpected end-of-input, expecting keyword_end
Started PATCH "/animals/1" for 127.0.0.1 at 2017-12-06 13:44:41 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"nTVLAP3bVBNzBk8RdDzUI4Pq0VgfWvuZnvAGMV4bMxqIe8v1wgeIOPgjLFKVDiJPPyQAjIcmg0hCUXPA2pUpgw==", "animal"=>{"animal_id"=>"1", "name"=>"", "species"=>"Piranha", "tank_id"=>"1", "birth_date(1i)"=>"2012", "birth_date(2i)"=>"1", "birth_date(3i)"=>"18", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"1"}
  [1m[36mAnimal Load (0.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35mSQL (1.5ms)[0m  [1m[33mUPDATE `animals` SET `name` = '', `birth_date` = '2012-01-18 00:00:00' WHERE `animals`.`animal_id` = 1[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (329.7ms)
  Rendered animals/edit.html.erb within layouts/application (452.8ms)
Completed 200 OK in 1441ms (Views: 1230.9ms | ActiveRecord: 19.5ms)


Started PATCH "/animals/1" for 127.0.0.1 at 2017-12-06 13:45:44 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"5xNWtW3rIK/J08WZlY1Mgk0y1V8g1G/RgjP+qA72oqLbgZIn7n43zSvfTHQ0PVFzAMcb0R35iRK9CY+B1ZzJYg==", "animal"=>{"animal_id"=>"1", "name"=>"", "species"=>"Piranh", "tank_id"=>"1", "birth_date(1i)"=>"2012", "birth_date(2i)"=>"1", "birth_date(3i)"=>"18", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"1"}
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mAnimal Load (9.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (8.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35mSQL (2.5ms)[0m  [1m[33mUPDATE `animals` SET `name` = '', `species` = 'Piranh', `birth_date` = '2012-01-18 00:00:00' WHERE `animals`.`animal_id` = 1[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (37.0ms)
  Rendered animals/edit.html.erb within layouts/application (313.2ms)
Completed 200 OK in 1673ms (Views: 1512.5ms | ActiveRecord: 25.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-06 13:45:47 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (58.0ms)
Completed 200 OK in 424ms (Views: 344.6ms | ActiveRecord: 1.5ms)


Started GET "/habitats" for 127.0.0.1 at 2017-12-06 13:45:54 -0500
Processing by HabitatsController#index as HTML
  Rendering habitats/index.html.erb within layouts/application
  [1m[36mHabitat Load (5.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats`[0m
  Rendered habitats/index.html.erb within layouts/application (27.0ms)
Completed 200 OK in 561ms (Views: 415.0ms | ActiveRecord: 8.5ms)


Started GET "/habitats/1/edit" for 127.0.0.1 at 2017-12-06 13:46:00 -0500
Processing by HabitatsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  Rendering habitats/edit.html.erb within layouts/application
  Rendered habitats/_form.html.erb (19.0ms)
  Rendered habitats/edit.html.erb within layouts/application (280.7ms)
Completed 200 OK in 1757ms (Views: 1540.7ms | ActiveRecord: 2.0ms)


Started PATCH "/habitats/1" for 127.0.0.1 at 2017-12-06 13:46:05 -0500
Processing by HabitatsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"UZGVLL91tGIKTSf44H8+d0STXTx/6qUzsrLi0b9EdWrsLxtQfk7HEY2MEZWzwRq0NOTNrhz9oIFpL2iiRLMjiw==", "habitat"=>{"habitat_id"=>"1", "name"=>"", "description"=>"Explore the exotic aquatic animals of the Amazon Rainforest. Located in South America, the Amazon Rainforest is home to thousands of diverse species.", "year_added"=>"2017"}, "commit"=>"Update Habitat", "id"=>"1"}
  [1m[36mHabitat Load (0.5ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
Completed 500 Internal Server Error in 527ms (ActiveRecord: 0.5ms)


  
NoMethodError (undefined method `strip' for nil:NilClass):
  
app/controllers/habitats_controller.rb:59:in `rescue in block in update'
app/controllers/habitats_controller.rb:50:in `block in update'
app/controllers/habitats_controller.rb:49:in `update'
Started GET "/habitats" for 127.0.0.1 at 2017-12-06 13:48:09 -0500
  [1m[35m (15.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by HabitatsController#index as HTML
  Rendering habitats/index.html.erb within layouts/application
  [1m[36mHabitat Load (3.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats`[0m
  Rendered habitats/index.html.erb within layouts/application (29.5ms)
Completed 200 OK in 1317ms (Views: 1213.9ms | ActiveRecord: 7.0ms)


Started GET "/habitats/1/edit" for 127.0.0.1 at 2017-12-06 13:49:04 -0500
Processing by HabitatsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  Rendering habitats/edit.html.erb within layouts/application
  Rendered habitats/_form.html.erb (514.9ms)
  Rendered habitats/edit.html.erb within layouts/application (892.6ms)
Completed 200 OK in 2326ms (Views: 2065.7ms | ActiveRecord: 3.0ms)


Started PATCH "/habitats/1" for 127.0.0.1 at 2017-12-06 13:49:32 -0500
Processing by HabitatsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"BOUZIP32YoovcwuQdShtJ7LaXag2N3RZ5etae9UTgpC5W5dcPM0R+aiyPf0mlknkwq3NOlUgces+dtAILuTUcQ==", "habitat"=>{"habitat_id"=>"1", "name"=>"", "description"=>"Explore the exotic aquatic animals of the Amazon Rainforest. Located in South America, the Amazon Rainforest is home to thousands of diverse species.", "year_added"=>"2017"}, "commit"=>"Update Habitat", "id"=>"1"}
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[33mUPDATE `habitats` SET `name` = '', `year_added` = 2017 WHERE `habitats`.`habitat_id` = 1[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering habitats/edit.html.erb within layouts/application
  Rendered habitats/_form.html.erb (10.5ms)
  Rendered habitats/edit.html.erb within layouts/application (307.7ms)
Completed 200 OK in 1641ms (Views: 1605.0ms | ActiveRecord: 9.0ms)


Started PATCH "/habitats/1" for 127.0.0.1 at 2017-12-06 13:49:53 -0500
Processing by HabitatsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"GAIXSJpH9Iejv+S5YKMjv6R0mAA9Bu1xfzDpxqGb4T0kkNPaGdLj5UGzbVTBEz5O6YFWjgArC7JACpjvevGK/Q==", "habitat"=>{"habitat_id"=>"1", "name"=>"a", "description"=>"", "year_added"=>"2017"}, "commit"=>"Update Habitat", "id"=>"1"}
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[33mUPDATE `habitats` SET `name` = 'a', `description` = '', `year_added` = 2017 WHERE `habitats`.`habitat_id` = 1[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering habitats/edit.html.erb within layouts/application
  Rendered habitats/_form.html.erb (11.5ms)
  Rendered habitats/edit.html.erb within layouts/application (433.8ms)
Completed 200 OK in 1903ms (Views: 1844.7ms | ActiveRecord: 6.5ms)


Started GET "/habitats" for 127.0.0.1 at 2017-12-06 13:50:00 -0500
Processing by HabitatsController#index as HTML
  Rendering habitats/index.html.erb within layouts/application
  [1m[36mHabitat Load (28.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats`[0m
  Rendered habitats/index.html.erb within layouts/application (101.1ms)
Completed 200 OK in 1707ms (Views: 1532.8ms | ActiveRecord: 28.0ms)


Started GET "/habitats/new" for 127.0.0.1 at 2017-12-06 13:50:03 -0500
Processing by HabitatsController#new as HTML
  Rendering habitats/new.html.erb within layouts/application
  Rendered habitats/_form.html.erb (20.5ms)
  Rendered habitats/new.html.erb within layouts/application (376.3ms)
Completed 200 OK in 1509ms (Views: 1293.9ms | ActiveRecord: 0.0ms)


Started POST "/habitats" for 127.0.0.1 at 2017-12-06 13:50:06 -0500
Processing by HabitatsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"s/8vG/24VjWLe5n1U0nME37m5UAP9hU+wwzZlgU9ZMlF3xkao1vFQbAeM9kGIc9gqpLd2kF1YAKbbIZyEX4WVQ==", "habitat"=>{"habitat_id"=>"", "name"=>"", "description"=>"", "year_added"=>"2017"}, "commit"=>"Create Habitat"}
  [1m[35m (16.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `habitats` (`name`, `description`, `year_added`) VALUES ('', '', 2017)[0m
  [1m[35m (21.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering habitats/new.html.erb within layouts/application
  Rendered habitats/_form.html.erb (6.5ms)
  Rendered habitats/new.html.erb within layouts/application (294.7ms)
Completed 200 OK in 2096ms (Views: 2028.9ms | ActiveRecord: 40.5ms)


Started GET "/habitats" for 127.0.0.1 at 2017-12-06 13:50:09 -0500
Processing by HabitatsController#index as HTML
  Rendering habitats/index.html.erb within layouts/application
  [1m[36mHabitat Load (0.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats`[0m
  Rendered habitats/index.html.erb within layouts/application (5.5ms)
Completed 200 OK in 565ms (Views: 420.3ms | ActiveRecord: 0.5ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-06 13:50:12 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (33.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (289.7ms)
Completed 200 OK in 1651ms (Views: 1341.7ms | ActiveRecord: 70.5ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-06 13:50:20 -0500
  
SyntaxError (C:/Users/Kayla/Desktop/aquarium-tycoon/aquarium_tycoon/app/controllers/feeding_logs_controller.rb:85: syntax error, unexpected end-of-input, expecting keyword_end):
  
app/controllers/feeding_logs_controller.rb:85: syntax error, unexpected end-of-input, expecting keyword_end
Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-06 13:52:10 -0500
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (28.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (1.5ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (161.2ms)
Completed 200 OK in 3252ms (Views: 3101.5ms | ActiveRecord: 5.5ms)


Started GET "/feeding_logs/new" for 127.0.0.1 at 2017-12-06 13:53:05 -0500
Processing by FeedingLogsController#new as HTML
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEmployee Load (21.5ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (4.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (503.9ms)
  Rendered feeding_logs/new.html.erb within layouts/application (632.4ms)
Completed 200 OK in 1483ms (Views: 1158.8ms | ActiveRecord: 119.6ms)


Started POST "/feeding_logs" for 127.0.0.1 at 2017-12-06 13:53:10 -0500
Processing by FeedingLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"f+Zvxdlzs5JnbxuBmvVAoAo7Io/rkzPh8x3C2qbiHhDHQ5sPJb0ew0ws2l1DMPRIdmKo6sC449aYpLYZ7omrQg==", "feeding_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"18", "time(5i)"=>"53", "food"=>"", "quantity"=>"", "employee_id"=>"1", "tank_id"=>"15"}, "commit"=>"Create Feeding log"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEmployee Load (0.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  [1m[35mSQL (5.5ms)[0m  [1m[32mINSERT INTO `feeding_logs` (`time`, `food`, `employee_id`, `tank_id`) VALUES ('2017-12-01 18:53:00', '', 1, 15)[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (21.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (3.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (170.6ms)
  Rendered feeding_logs/new.html.erb within layouts/application (283.7ms)
Completed 200 OK in 1107ms (Views: 858.9ms | ActiveRecord: 32.0ms)


Started POST "/feeding_logs" for 127.0.0.1 at 2017-12-06 13:53:15 -0500
Processing by FeedingLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"VxK8c9lvStbevt3cLACrKG38DPlB7kC7tQ6xHt46a4drgHjhWvpdtDyyVDGNsLbZIAnCd3zDpniKNMA3BVAARw==", "feeding_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"18", "time(5i)"=>"53", "food"=>"a", "quantity"=>"", "employee_id"=>"1", "tank_id"=>"15"}, "commit"=>"Create Feeding log"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEmployee Load (18.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[36mTank Load (7.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  [1m[35mSQL (18.0ms)[0m  [1m[32mINSERT INTO `feeding_logs` (`time`, `food`, `employee_id`, `tank_id`) VALUES ('2017-12-01 18:53:00', 'a', 1, 15)[0m
  [1m[35m (10.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (1.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (33.0ms)
  Rendered feeding_logs/new.html.erb within layouts/application (194.6ms)
Completed 200 OK in 1245ms (Views: 866.9ms | ActiveRecord: 56.5ms)


Started POST "/feeding_logs" for 127.0.0.1 at 2017-12-06 13:53:19 -0500
Processing by FeedingLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"yY5bK5Ik50hlU8Tscc2F41/aPdtgk3T1KKqIK/UL6cn1HJ+5EbHwKodfTQHQfZgSEi/zVV2+kjYXkPkCLmGCCQ==", "feeding_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"18", "time(5i)"=>"53", "food"=>"a", "quantity"=>"-1", "employee_id"=>"1", "tank_id"=>"15"}, "commit"=>"Create Feeding log"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEmployee Load (1.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  [1m[35mSQL (2.5ms)[0m  [1m[32mINSERT INTO `feeding_logs` (`time`, `food`, `quantity`, `employee_id`, `tank_id`) VALUES ('2017-12-01 18:53:00', 'a', -1.0, 1, 15)[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (16.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (24.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (259.0ms)
  Rendered feeding_logs/new.html.erb within layouts/application (641.3ms)
Completed 200 OK in 2092ms (Views: 2011.5ms | ActiveRecord: 46.5ms)


Started POST "/feeding_logs" for 127.0.0.1 at 2017-12-06 13:53:28 -0500
Processing by FeedingLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Adlg8uLuAnmAIZ77mJj29cGvRAtgTERdCAkaVQ8iWzM9S6RgYXsVG2ItFxY5KOsEjFqKhV1hop43M2t81Egw8w==", "feeding_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"18", "time(5i)"=>"53", "food"=>"a", "quantity"=>"2", "employee_id"=>"1", "tank_id"=>"15"}, "commit"=>"Create Feeding log"}
  [1m[35m (5.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEmployee Load (9.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[36mTank Load (29.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  [1m[35mSQL (25.0ms)[0m  [1m[32mINSERT INTO `feeding_logs` (`time`, `food`, `quantity`, `employee_id`, `tank_id`) VALUES ('2017-12-01 18:53:00', 'a', 2.0, 1, 15)[0m
  [1m[35m (20.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/feeding_logs/393
Completed 302 Found in 338ms (ActiveRecord: 89.1ms)


Started GET "/feeding_logs/393" for 127.0.0.1 at 2017-12-06 13:53:29 -0500
Processing by FeedingLogsController#show as HTML
  Parameters: {"id"=>"393"}
  [1m[36mFeedingLog Load (1.0ms)[0m  [1m[34mSELECT  `feeding_logs`.* FROM `feeding_logs` WHERE `feeding_logs`.`feeding_id` = 393 LIMIT 1[0m
  Rendering feeding_logs/show.html.erb within layouts/application
  Rendered feeding_logs/show.html.erb within layouts/application (6.0ms)
Completed 200 OK in 1104ms (Views: 892.9ms | ActiveRecord: 1.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 13:53:35 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (1.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (54.0ms)
Completed 200 OK in 874ms (Views: 696.8ms | ActiveRecord: 4.5ms)


Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-06 13:53:41 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (33.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (25.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (565.9ms)
  Rendered treatment_logs/new.html.erb within layouts/application (850.2ms)
Completed 200 OK in 2557ms (Views: 2261.8ms | ActiveRecord: 101.1ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-06 13:53:46 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"GLww+wHLXg1yhFln/2pd+n+1HY/K/6NiicJm2W6g72/ukfHuykAHk8tDsLzubJJ65uBNmKfeYosKWh4wHFb4jw==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"18", "time(5i)"=>"53", "medicine"=>"", "quantity"=>"", "employee_id"=>"1", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (31.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (23.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (14.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (18.0ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `employee_id`, `animal_id`) VALUES ('2017-12-01 18:53:00', '', 1, 1)[0m
  [1m[35m (13.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (0.5ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (25.5ms)
  Rendered treatment_logs/new.html.erb within layouts/application (110.6ms)
Completed 200 OK in 723ms (Views: 470.5ms | ActiveRecord: 102.6ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-06 13:53:56 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"qoMVfXZZsrbT+2sl5XM7bRF0/IvEePaecGmAzt9ZgPWWEdHv9cyl1DH34shEwyacXIEyBflVEF1PU/HnBDPrNQ==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"18", "time(5i)"=>"53", "medicine"=>"", "quantity"=>"-2", "employee_id"=>"1", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (9.0ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `quantity`, `employee_id`, `animal_id`) VALUES ('2017-12-01 18:53:00', '', -2.0, 1, 1)[0m
  [1m[35m (5.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/treatment_logs/53
Completed 302 Found in 72ms (ActiveRecord: 17.0ms)


Started GET "/treatment_logs/53" for 127.0.0.1 at 2017-12-06 13:53:57 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"53"}
  [1m[36mTreatmentLog Load (1.0ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 53 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (5.0ms)
Completed 200 OK in 1668ms (Views: 1289.4ms | ActiveRecord: 1.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 13:54:03 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (4.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (1018.8ms)
Completed 200 OK in 3069ms (Views: 2885.1ms | ActiveRecord: 4.0ms)


  [1m[35m (27.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (303.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (3.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (4.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (0.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (54.2ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (38.5ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (2.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (52.9ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (86.8ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (108.5ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (66.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (101.6ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (116.9ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (133.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (108.6ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (109.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (21.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (10.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (38.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (45.1ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (34.5ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (17.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (35.0ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (33.5ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (34.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (45.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (32.5ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (9.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (47.5ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (41.5ms)[0m  [1m[35mCREATE TRIGGER add_habitat
BEFORE INSERT ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  END IF;
end;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (9.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (62.5ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (45.7ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (70.6ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (54.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (29.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (9.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (20.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (28.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (60.1ms)[0m  [1m[35mCREATE TRIGGER add_treatment
BEFORE INSERT ON treatment_logs
  FOR EACH ROW
BEGIN
  IF New.medicine = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a medicine';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity < 0 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';   
  END IF;

end;
[0m
  [1m[35m (9.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (17.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (29.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTanks (20171206162319)
  [1m[35m (56.5ms)[0m  [1m[35m
CREATE TRIGGER update_tank
BEFORE UPDATE ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  ELSEIF New.volume < Old.volume THEN
    SIGNAL SQLSTATE 'HY000'
    	SET MESSAGE_TEXT = 'Cannot shrink a tank.';
  END IF;

end;

[0m
  [1m[35m (44.6ms)[0m  [1m[35m
CREATE TRIGGER add_tank
BEFORE INSERT ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  END IF;

end;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171206162319')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (11.5ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-06 18:56:17', '2017-12-06 18:56:17')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 13:57:54 -0500
  [1m[35m (28.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (3.5ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (51.8ms)
Completed 200 OK in 2290ms (Views: 2155.5ms | ActiveRecord: 8.0ms)


Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-06 13:59:36 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[35m (23.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEmployee Load (9.5ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (8.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (735.0ms)
  Rendered treatment_logs/new.html.erb within layouts/application (936.7ms)
Completed 200 OK in 1876ms (Views: 1667.5ms | ActiveRecord: 56.5ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-06 13:59:41 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"OCYGy8RieNlWu1RK0XTRh6mgEqGSTBKmYCZuUpTbmFLOC8feD+khR+98vZHAch4HMPVCtv9t00/jvha75i2Psg==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"18", "time(5i)"=>"59", "medicine"=>"", "quantity"=>"", "employee_id"=>"1", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (16.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (8.0ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `employee_id`, `animal_id`) VALUES ('2017-12-01 18:59:00', '', 1, 1)[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (1.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (25.5ms)
  Rendered treatment_logs/new.html.erb within layouts/application (97.6ms)
Completed 200 OK in 851ms (Views: 482.7ms | ActiveRecord: 28.5ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-06 13:59:46 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"pTVYCrHCma12k01mLDoVbWSWnl3cIr/RhCTaFQfFEWOZp5yYMleOz5SfxIuNigicKWNQ0+EPWRK7Hqs83K96ow==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"18", "time(5i)"=>"59", "medicine"=>"a", "quantity"=>"", "employee_id"=>"1", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (1.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `employee_id`, `animal_id`) VALUES ('2017-12-01 18:59:00', 'a', 1, 1)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (1.5ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (32.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (230.7ms)
  Rendered treatment_logs/new.html.erb within layouts/application (593.5ms)
Completed 200 OK in 1957ms (Views: 1877.5ms | ActiveRecord: 43.0ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-06 14:00:02 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"kyAFcQSky8YOpRR28LKywGoOlReSIFEQB6bDVMNFnzSvssHjhzHcpOypnZtRAq8xJ/tbma8Nt9M4nLJ9GC/09A==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"18", "time(5i)"=>"59", "medicine"=>"a", "quantity"=>"-1", "employee_id"=>"1", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (8.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (17.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (17.5ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `quantity`, `employee_id`, `animal_id`) VALUES ('2017-12-01 18:59:00', 'a', -1.0, 1, 1)[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (9.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (4.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (177.1ms)
  Rendered treatment_logs/new.html.erb within layouts/application (302.2ms)
Completed 200 OK in 1098ms (Views: 877.1ms | ActiveRecord: 57.5ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-06 14:00:07 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"7C90K0lVBNC9Tzb34Y8fKT95OVZ1ZoXWjGZvtlX8MFvQvbC5ysATsl9DvxpAPwLYcoz32EhLYxWzXB6fjpZbmw==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"18", "time(5i)"=>"59", "medicine"=>"a", "quantity"=>"2", "employee_id"=>"1", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (10.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (8.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (1.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (23.0ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `quantity`, `employee_id`, `animal_id`) VALUES ('2017-12-01 18:59:00', 'a', 2.0, 1, 1)[0m
  [1m[35m (20.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/treatment_logs/53
Completed 302 Found in 177ms (ActiveRecord: 63.0ms)


Started GET "/treatment_logs/53" for 127.0.0.1 at 2017-12-06 14:00:07 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"53"}
  [1m[36mTreatmentLog Load (9.5ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 53 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (26.0ms)
Completed 200 OK in 938ms (Views: 753.4ms | ActiveRecord: 9.5ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-06 14:00:10 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (10.5ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (183.6ms)
Completed 200 OK in 1357ms (Views: 1067.8ms | ActiveRecord: 10.5ms)


Started GET "/habitats" for 127.0.0.1 at 2017-12-06 14:00:20 -0500
Processing by HabitatsController#index as HTML
  Rendering habitats/index.html.erb within layouts/application
  [1m[36mHabitat Load (12.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats`[0m
  Rendered habitats/index.html.erb within layouts/application (123.6ms)
Completed 200 OK in 1847ms (Views: 1407.4ms | ActiveRecord: 37.0ms)


Started DELETE "/habitats/1" for 127.0.0.1 at 2017-12-06 14:00:26 -0500
Processing by HabitatsController#destroy as HTML
  Parameters: {"authenticity_token"=>"cET9CjcZ4ofKsSXmYIKdN1x3M9R520t2i38t9YxogcdM1jmYtIz15Si9rAvBMoDGEYL9WkT2rbW0RVzcVwLqBw==", "id"=>"1"}
  [1m[36mHabitat Load (16.5ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35m (30.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (11.0ms)[0m  [1m[31mDELETE FROM `habitats` WHERE `habitats`.`habitat_id` = 1[0m
  [1m[35m (31.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/habitats
Completed 302 Found in 260ms (ActiveRecord: 88.5ms)


Started GET "/habitats" for 127.0.0.1 at 2017-12-06 14:00:26 -0500
Processing by HabitatsController#index as HTML
  Rendering habitats/index.html.erb within layouts/application
  [1m[36mHabitat Load (1.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats`[0m
  Rendered habitats/index.html.erb within layouts/application (8.0ms)
Completed 200 OK in 570ms (Views: 474.0ms | ActiveRecord: 1.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-06 14:00:32 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (10.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (71.1ms)
Completed 200 OK in 1430ms (Views: 1091.6ms | ActiveRecord: 15.0ms)


Started DELETE "/tanks/4" for 127.0.0.1 at 2017-12-06 14:00:40 -0500
Processing by TanksController#destroy as HTML
  Parameters: {"authenticity_token"=>"Uw7O5HPQ3+jgpeLsP2C2Cfx3BYJ69+UUshChfeK8taRvnAp28EXIigKpawGe0Kv4sYLLDEfaA9eNKtBUOdbeZA==", "id"=>"4"}
  [1m[36mTank Load (13.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 4 LIMIT 1[0m
  [1m[35m (17.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.5ms)[0m  [1m[31mDELETE FROM `tanks` WHERE `tanks`.`tank_id` = 4[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks
Completed 302 Found in 155ms (ActiveRecord: 39.5ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-06 14:00:41 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (50.5ms)
Completed 200 OK in 1671ms (Views: 1367.2ms | ActiveRecord: 1.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-06 14:00:46 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (25.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (234.7ms)
Completed 200 OK in 1065ms (Views: 866.1ms | ActiveRecord: 25.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 14:19:09 -0500
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (24.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (287.5ms)
Completed 200 OK in 4998ms (Views: 4412.8ms | ActiveRecord: 28.1ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-12-07 14:24:18 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mTank Load (12.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (732.9ms)
  Rendered animals/new.html.erb within layouts/application (961.0ms)
Completed 200 OK in 2147ms (Views: 1965.8ms | ActiveRecord: 22.0ms)


Started POST "/animals" for 127.0.0.1 at 2017-12-07 14:25:09 -0500
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Px4DvjVqVcb5oU9sTMofx1ieLTGnBvLZoIO7ucpaLOWIxIKcHwNsjVW2SvlpbVUPb8Ydksy6dLDx1o7YQnao0A==", "animal"=>{"animal_id"=>"", "name"=>"a", "species"=>"b", "tank_id"=>"11", "birth_date(1i)"=>"2017", "birth_date(2i)"=>"12", "birth_date(3i)"=>"7", "birth_date(4i)"=>"19", "birth_date(5i)"=>"24"}, "commit"=>"Create Animal"}
  [1m[35m (29.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (15.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35mSQL (36.5ms)[0m  [1m[32mINSERT INTO `animals` (`name`, `species`, `tank_id`, `birth_date`) VALUES ('a', 'b', 11, '2017-12-07 19:24:00')[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/new.html.erb within layouts/application
  [1m[36mTank Load (30.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (110.6ms)
  Rendered animals/new.html.erb within layouts/application (436.3ms)
Completed 200 OK in 2343ms (Views: 1432.4ms | ActiveRecord: 112.1ms)


Started POST "/animals" for 127.0.0.1 at 2017-12-07 14:25:19 -0500
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"RWi5n3zbURDTSOx+vXkay4lAZg887cz5oLPF9rO5WHJ5+n0N/05GcjFEZZMcyQc6xLWogQHAKjqfibTfaNMzsg==", "animal"=>{"animal_id"=>"", "name"=>"a", "species"=>"b", "tank_id"=>"11", "birth_date(1i)"=>"2017", "birth_date(2i)"=>"12", "birth_date(3i)"=>"7", "birth_date(4i)"=>"19", "birth_date(5i)"=>"06"}, "commit"=>"Create Animal"}
  [1m[35m (15.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (13.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35mSQL (18.0ms)[0m  [1m[32mINSERT INTO `animals` (`name`, `species`, `tank_id`, `birth_date`) VALUES ('a', 'b', 11, '2017-12-07 19:06:00')[0m
  [1m[35m (24.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/new.html.erb within layouts/application
  [1m[36mTank Load (30.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (182.3ms)
  Rendered animals/new.html.erb within layouts/application (405.3ms)
Completed 200 OK in 1521ms (Views: 1271.6ms | ActiveRecord: 100.6ms)


Started POST "/animals" for 127.0.0.1 at 2017-12-07 14:25:26 -0500
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"1Pm5p131EBGbAwPDvu+nP04i31Sv1NBKPHySSx7jy97oa3013mAHc3kPii4fX7rOA9cR2pL5NokDRuNixYmgHg==", "animal"=>{"animal_id"=>"", "name"=>"a", "species"=>"b", "tank_id"=>"11", "birth_date(1i)"=>"2017", "birth_date(2i)"=>"12", "birth_date(3i)"=>"6", "birth_date(4i)"=>"19", "birth_date(5i)"=>"06"}, "commit"=>"Create Animal"}
  [1m[35m (30.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (28.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `animals` (`name`, `species`, `tank_id`, `birth_date`) VALUES ('a', 'b', 11, '2017-12-06 19:06:00')[0m
  [1m[35m (11.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals/155
Completed 302 Found in 125ms (ActiveRecord: 73.1ms)


Started GET "/animals/155" for 127.0.0.1 at 2017-12-07 14:25:27 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"155"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 155 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (6.3ms)
Completed 200 OK in 1218ms (Views: 1004.0ms | ActiveRecord: 1.0ms)


Started GET "/animals/155/edit" for 127.0.0.1 at 2017-12-07 14:27:03 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"155"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 155 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (2.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (98.1ms)
  Rendered animals/edit.html.erb within layouts/application (495.9ms)
Completed 200 OK in 2229ms (Views: 2053.0ms | ActiveRecord: 3.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 14:27:08 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (2.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (214.4ms)
Completed 200 OK in 1453ms (Views: 1302.6ms | ActiveRecord: 2.0ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-12-07 14:27:11 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  [1m[36mTank Load (30.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (232.0ms)
  Rendered animals/new.html.erb within layouts/application (475.3ms)
Completed 200 OK in 1606ms (Views: 1380.8ms | ActiveRecord: 30.0ms)


Started POST "/animals" for 127.0.0.1 at 2017-12-07 14:30:48 -0500
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"sbJU1RSOsVo7Lpo1ZNnQR/Sh60dTRr4aHLybNwBrBbIGaNX3PueIEZc5n6BBfpqPw/nb5Dj6OHNN6a5WiEeBhw==", "animal"=>{"animal_id"=>"", "name"=>"a", "species"=>"b", "tank_id"=>"11", "birth_date(1i)"=>"2017", "birth_date(2i)"=>"7", "birth_date(3i)"=>"3", "birth_date(4i)"=>"19", "birth_date(5i)"=>"27"}, "commit"=>"Create Animal"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (2.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35mSQL (4.5ms)[0m  [1m[32mINSERT INTO `animals` (`name`, `species`, `tank_id`, `birth_date`) VALUES ('a', 'b', 11, '2017-07-03 19:27:00')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals/156
Completed 302 Found in 46ms (ActiveRecord: 11.5ms)


Started GET "/animals/156" for 127.0.0.1 at 2017-12-07 14:30:48 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"156"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 156 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (2.5ms)
Completed 200 OK in 1479ms (Views: 1286.8ms | ActiveRecord: 1.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 14:31:32 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (2.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (433.4ms)
Completed 200 OK in 1817ms (Views: 1637.0ms | ActiveRecord: 2.0ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-12-07 14:31:37 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  [1m[36mTank Load (30.2ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (121.0ms)
  Rendered animals/new.html.erb within layouts/application (324.4ms)
Completed 200 OK in 1206ms (Views: 1022.0ms | ActiveRecord: 30.2ms)


Started POST "/animals" for 127.0.0.1 at 2017-12-07 14:31:49 -0500
Processing by AnimalsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"N/PLX8FiWVh04BAgJIWkSq84uWPeqnq01hfL+n6Ub5CAKUp96wtgE9j3FbUBIu6CmGCJwLUW/N2HQv6b9rjrpQ==", "animal"=>{"animal_id"=>"", "name"=>"a", "species"=>"", "tank_id"=>"11", "birth_date(1i)"=>"2017", "birth_date(2i)"=>"12", "birth_date(3i)"=>"7", "birth_date(4i)"=>"19", "birth_date(5i)"=>"31"}, "commit"=>"Create Animal"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35mSQL (10.0ms)[0m  [1m[32mINSERT INTO `animals` (`name`, `species`, `tank_id`, `birth_date`) VALUES ('a', '', 11, '2017-12-07 19:31:00')[0m
  [1m[35m (4.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/new.html.erb within layouts/application
  [1m[36mTank Load (14.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (161.6ms)
  Rendered animals/new.html.erb within layouts/application (360.4ms)
Completed 200 OK in 1754ms (Views: 1604.2ms | ActiveRecord: 30.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 14:34:31 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (30.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (234.0ms)
Completed 200 OK in 1305ms (Views: 1085.3ms | ActiveRecord: 30.0ms)


Started GET "/animals/47" for 127.0.0.1 at 2017-12-07 14:34:36 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"47"}
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (1.0ms)
Completed 200 OK in 1166ms (Views: 932.9ms | ActiveRecord: 1.5ms)


Started GET "/animals/47/edit" for 127.0.0.1 at 2017-12-07 14:36:09 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"47"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (34.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (124.6ms)
  Rendered animals/edit.html.erb within layouts/application (400.4ms)
Completed 200 OK in 2183ms (Views: 1970.6ms | ActiveRecord: 35.0ms)


Started PATCH "/animals/47" for 127.0.0.1 at 2017-12-07 14:36:56 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"4GU0JEnfA7WJVXJaK60jm9Rx6SCM0X0HbU87lBnDgK8qH72E840qUMJw/Rb7tAsLPAD0s4kBnzuyxN4sP9+KMQ==", "animal"=>{"animal_id"=>"47", "name"=>"Toady", "species"=>"Toad Crab", "tank_id"=>"8", "birth_date(1i)"=>"2016", "birth_date(2i)"=>"5", "birth_date(3i)"=>"6", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"47"}
  [1m[36mAnimal Load (30.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  [1m[35m (19.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (2.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 8 LIMIT 1[0m
  [1m[35mSQL (14.0ms)[0m  [1m[33mUPDATE `animals` SET `tank_id` = 8 WHERE `animals`.`animal_id` = 47[0m
  [1m[35m (29.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals/47
Completed 302 Found in 294ms (ActiveRecord: 94.6ms)


Started GET "/animals/47" for 127.0.0.1 at 2017-12-07 14:36:56 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"47"}
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (5.0ms)
Completed 200 OK in 1303ms (Views: 1116.0ms | ActiveRecord: 1.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 14:37:02 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (30.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (464.8ms)
Completed 200 OK in 1389ms (Views: 1217.4ms | ActiveRecord: 30.0ms)


Started GET "/animals/47/edit" for 127.0.0.1 at 2017-12-07 14:37:07 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"47"}
  [1m[36mAnimal Load (4.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (22.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (177.2ms)
  Rendered animals/edit.html.erb within layouts/application (414.3ms)
Completed 200 OK in 1676ms (Views: 1370.0ms | ActiveRecord: 26.5ms)


Started PATCH "/animals/47" for 127.0.0.1 at 2017-12-07 14:37:23 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"OLiik0JQIRaJ4LbvZZhuBxfsxDvo667LyTVITH7UchTywisz+AII88LFOaO1gUaX/53ZqO07TPcWvq30WMh4ig==", "animal"=>{"animal_id"=>"47", "name"=>"LevelUp", "species"=>"Toad Crab", "tank_id"=>"8", "birth_date(1i)"=>"2016", "birth_date(2i)"=>"5", "birth_date(3i)"=>"6", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"47"}
  [1m[36mAnimal Load (2.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 8 LIMIT 1[0m
  [1m[35mSQL (2.0ms)[0m  [1m[33mUPDATE `animals` SET `name` = 'LevelUp' WHERE `animals`.`animal_id` = 47[0m
  [1m[35m (7.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals/47
Completed 302 Found in 40ms (ActiveRecord: 13.0ms)


Started GET "/animals/47" for 127.0.0.1 at 2017-12-07 14:37:23 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"47"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1652ms (Views: 1207.1ms | ActiveRecord: 1.0ms)


Started GET "/animals/47/edit" for 127.0.0.1 at 2017-12-07 14:37:34 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"47"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (14.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (57.5ms)
  Rendered animals/edit.html.erb within layouts/application (313.3ms)
Completed 200 OK in 1214ms (Views: 962.4ms | ActiveRecord: 15.0ms)


Started PATCH "/animals/47" for 127.0.0.1 at 2017-12-07 14:38:07 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"bKx14DT0rjHfltrwxEHD7b5HTEour05UeY9rHbXWDfSm1vxAjqaH1JSzVbwUWOt9VjZR2St/rGimBI6lk8oHag==", "animal"=>{"animal_id"=>"47", "name"=>"LevelUp", "species"=>"Toad Crab", "tank_id"=>"8", "birth_date(1i)"=>"2016", "birth_date(2i)"=>"5", "birth_date(3i)"=>"6", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"47"}
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  [1m[35m (7.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 8 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals/47
Completed 302 Found in 62ms (ActiveRecord: 11.0ms)


Started GET "/animals/47" for 127.0.0.1 at 2017-12-07 14:38:07 -0500
Processing by AnimalsController#show as HTML
  Parameters: {"id"=>"47"}
  [1m[36mAnimal Load (6.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  Rendering animals/show.html.erb within layouts/application
  Rendered animals/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1575ms (Views: 1237.6ms | ActiveRecord: 6.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 14:39:23 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (30.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (155.1ms)
Completed 200 OK in 1783ms (Views: 1391.5ms | ActiveRecord: 30.0ms)


Started GET "/animals/new" for 127.0.0.1 at 2017-12-07 14:39:28 -0500
Processing by AnimalsController#new as HTML
  Rendering animals/new.html.erb within layouts/application
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (23.0ms)
  Rendered animals/new.html.erb within layouts/application (233.2ms)
Completed 200 OK in 1718ms (Views: 1604.9ms | ActiveRecord: 1.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 14:39:34 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (30.7ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (550.3ms)
Completed 200 OK in 1700ms (Views: 1496.2ms | ActiveRecord: 30.7ms)


Started GET "/animals/47/edit" for 127.0.0.1 at 2017-12-07 14:39:37 -0500
Processing by AnimalsController#edit as HTML
  Parameters: {"id"=>"47"}
  [1m[36mAnimal Load (1.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (108.6ms)
  Rendered animals/edit.html.erb within layouts/application (374.0ms)
Completed 200 OK in 2068ms (Views: 1738.3ms | ActiveRecord: 3.0ms)


Started PATCH "/animals/47" for 127.0.0.1 at 2017-12-07 14:39:43 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"UpEVs2tgunla1n2uJJwWj8d2wLzUN5AsJLFQePLy9xuY65wT0TKTnBHz8uL0hT4fLwfdL9HnchD7OrXA1O79hQ==", "animal"=>{"animal_id"=>"47", "name"=>"LevelUp", "species"=>"", "tank_id"=>"8", "birth_date(1i)"=>"2016", "birth_date(2i)"=>"5", "birth_date(3i)"=>"6", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"47"}
  [1m[36mAnimal Load (43.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  [1m[35m (32.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (2.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 8 LIMIT 1[0m
  [1m[35mSQL (3.0ms)[0m  [1m[33mUPDATE `animals` SET `species` = '' WHERE `animals`.`animal_id` = 47[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (34.0ms)
  Rendered animals/edit.html.erb within layouts/application (283.7ms)
Completed 200 OK in 2221ms (Views: 1891.2ms | ActiveRecord: 82.6ms)


Started PATCH "/animals/47" for 127.0.0.1 at 2017-12-07 14:40:08 -0500
Processing by AnimalsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"MOcopfqVscnYZKpq//jah5WCyEJCr22r5s3KLbz1xpkMdew3eQCmqzpoI4deSMd22HcGzH+Ci2jZ97sEZ5+tWQ==", "animal"=>{"animal_id"=>"47", "name"=>"LevelUp", "species"=>"Toady c", "tank_id"=>"8", "birth_date(1i)"=>"2016", "birth_date(2i)"=>"5", "birth_date(3i)"=>"6", "birth_date(4i)"=>"00", "birth_date(5i)"=>"00"}, "commit"=>"Update Animal", "id"=>"47"}
  [1m[36mAnimal Load (2.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 8 LIMIT 1[0m
  [1m[35mSQL (3.0ms)[0m  [1m[33mUPDATE `animals` SET `species` = 'Toady c' WHERE `animals`.`animal_id` = 47[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering animals/edit.html.erb within layouts/application
  [1m[36mTank Load (23.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered animals/_form.html.erb (194.4ms)
  Rendered animals/edit.html.erb within layouts/application (422.1ms)
Completed 200 OK in 1789ms (Views: 1727.0ms | ActiveRecord: 31.5ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 14:41:49 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (30.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (478.6ms)
Completed 200 OK in 1660ms (Views: 1508.1ms | ActiveRecord: 30.0ms)


Started DELETE "/animals/47" for 127.0.0.1 at 2017-12-07 14:42:43 -0500
Processing by AnimalsController#destroy as HTML
  Parameters: {"authenticity_token"=>"5/uSXbw2AJ8dKm0KjW3LuSy7+/QsNDidCcFBbiDL69LbaVbPP6MX/f8m5Ocs3dZIYU41ehEZ3l42+zBH+6GAEg==", "id"=>"47"}
  [1m[36mAnimal Load (30.1ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 47 LIMIT 1[0m
  [1m[35m (24.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (29.0ms)[0m  [1m[31mDELETE FROM `animals` WHERE `animals`.`animal_id` = 47[0m
  [1m[35m (30.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals
Completed 302 Found in 290ms (ActiveRecord: 113.2ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 14:42:43 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (107.8ms)
Completed 200 OK in 914ms (Views: 771.6ms | ActiveRecord: 1.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-07 14:53:50 -0500
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (28.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (420.0ms)
Completed 200 OK in 3318ms (Views: 3041.5ms | ActiveRecord: 90.0ms)


  [1m[35m (25.4ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `ar_internal_metadata`.`value` FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment'[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (475.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (7.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (81.3ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (87.1ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (31.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (27.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (65.0ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (76.3ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (79.4ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (63.9ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (78.8ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (81.0ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) DEFAULT NULL,
        animal_id int(11) DEFAULT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (80.2ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (81.4ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (83.3ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.1ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (33.1ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (34.6ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.2ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (5.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (34.7ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (43.4ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (27.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (27.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (29.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (23.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (27.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (29.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (30.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (15.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (11.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (21.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (39.5ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (40.5ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (10.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (5.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (40.5ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (4.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (41.0ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (39.0ms)[0m  [1m[35mCREATE TRIGGER add_habitat
BEFORE INSERT ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  END IF;
end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (41.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (50.5ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (43.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (47.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (39.5ms)[0m  [1m[35mCREATE TRIGGER add_treatment
BEFORE INSERT ON treatment_logs
  FOR EACH ROW
BEGIN
  IF New.medicine = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a medicine';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity < 0 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';   
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (16.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTanks (20171206162319)
  [1m[35m (37.0ms)[0m  [1m[35m
CREATE TRIGGER update_tank
BEFORE UPDATE ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  ELSEIF New.volume < Old.volume THEN
    SIGNAL SQLSTATE 'HY000'
    	SET MESSAGE_TEXT = 'Cannot shrink a tank.';
  END IF;

end;

[0m
  [1m[35m (64.0ms)[0m  [1m[35m
CREATE TRIGGER add_tank
BEFORE INSERT ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  END IF;

end;

[0m
  [1m[35m (3.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171206162319')[0m
  [1m[35m (12.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (16.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (33.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (9.5ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-07 20:00:17', '2017-12-07 20:00:17')[0m
  [1m[35m (18.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/tanks" for 127.0.0.1 at 2017-12-07 15:03:28 -0500
  [1m[35m (3.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (11.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (65.6ms)
Completed 200 OK in 1467ms (Views: 1286.1ms | ActiveRecord: 13.0ms)


Started GET "/tanks/1" for 127.0.0.1 at 2017-12-07 15:04:25 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (30.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mTank Load (16.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (6.0ms)
Completed 200 OK in 1639ms (Views: 1233.5ms | ActiveRecord: 46.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-07 15:06:10 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (13.0ms)
Completed 200 OK in 686ms (Views: 480.9ms | ActiveRecord: 1.0ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-07 15:06:12 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (5.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (521.3ms)
  Rendered tanks/edit.html.erb within layouts/application (702.4ms)
Completed 200 OK in 1919ms (Views: 1737.6ms | ActiveRecord: 9.5ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-07 15:07:42 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (2.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (90.1ms)
Completed 200 OK in 1761ms (Views: 1460.9ms | ActiveRecord: 2.0ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-07 15:07:44 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (1.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (53.0ms)
  Rendered tanks/new.html.erb within layouts/application (379.8ms)
Completed 200 OK in 1663ms (Views: 1459.4ms | ActiveRecord: 1.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-07 15:10:49 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"qIWgRLzJEEh8PD1Ts+V1jGvjRgna8W31pwK3YsrXjeqvzto20nhcKvTJpO599TWW60rXPw0i4+++mFt80eN8aw==", "tank"=>{"tank_id"=>"", "name"=>"", "description"=>"", "water_type"=>"fresh", "volume"=>"", "temperature"=>"", "year_built"=>"2017", "habitat_id"=>"3"}, "commit"=>"Create Tank"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (8.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 3 LIMIT 1[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `year_built`, `habitat_id`) VALUES ('', '', 'fresh', 2017, 3)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (26.0ms)
  Rendered tanks/new.html.erb within layouts/application (209.1ms)
Completed 200 OK in 1663ms (Views: 1527.5ms | ActiveRecord: 15.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-07 15:11:22 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"ClDzPAwDHp+YIdmq+HDozClF7A2e7NkjoD/YHIR59Xs2wjeuj5YJ/XotUEdZwPU9ZLAig6PBP+CfBak1XxOeuw==", "tank"=>{"tank_id"=>"", "name"=>"Jellyfishes", "description"=>"Jellyfish of all shapes and sizes", "water_type"=>"salt", "volume"=>"15,000", "temperature"=>"79.2", "year_built"=>"2017", "habitat_id"=>"3"}, "commit"=>"Create Tank"}
  [1m[35m (31.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (27.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 3 LIMIT 1[0m
  [1m[35mSQL (20.0ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES ('Jellyfishes', 'Jellyfish of all shapes and sizes', 'salt', 15.0, 79.2, 2017, 3)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (1.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (20.6ms)
  Rendered tanks/new.html.erb within layouts/application (162.3ms)
Completed 200 OK in 1055ms (Views: 830.7ms | ActiveRecord: 80.8ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-07 15:11:31 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"SvA3Vm2WykDMqtyEOYyD8YXoq6mBVUJC4DWaK/G1GKF2YvPE7gPdIi6mVWmYPJ4AyB1lJ7x4pIHfD+sCKt9zYQ==", "tank"=>{"tank_id"=>"", "name"=>"Jellyfishes", "description"=>"Jellyfish of all shapes and sizes", "water_type"=>"salt", "volume"=>"15000", "temperature"=>"79.2", "year_built"=>"2017", "habitat_id"=>"3"}, "commit"=>"Create Tank"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 3 LIMIT 1[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `volume`, `temperature`, `year_built`, `habitat_id`) VALUES ('Jellyfishes', 'Jellyfish of all shapes and sizes', 'salt', 15000.0, 79.2, 2017, 3)[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/15
Completed 302 Found in 37ms (ActiveRecord: 11.0ms)


Started GET "/tanks/15" for 127.0.0.1 at 2017-12-07 15:11:31 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"15"}
  [1m[36mTank Load (2.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 15 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (5.0ms)
Completed 200 OK in 1483ms (Views: 1294.9ms | ActiveRecord: 2.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-07 15:12:15 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (28.1ms)
Completed 200 OK in 858ms (Views: 720.6ms | ActiveRecord: 1.0ms)


Started GET "/tanks/new" for 127.0.0.1 at 2017-12-07 15:12:19 -0500
Processing by TanksController#new as HTML
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (1.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (39.5ms)
  Rendered tanks/new.html.erb within layouts/application (345.2ms)
Completed 200 OK in 2166ms (Views: 1971.3ms | ActiveRecord: 1.5ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-07 15:12:32 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"pidCr0MraTxm0N/WbTX5Y80HY0mYwvcMbpyxMXRegJ+hbDjdLZolXu4lRmujJbl5Ta7yf08ReRZ3Bl0vb2pxHg==", "tank"=>{"tank_id"=>"", "name"=>"", "description"=>"", "water_type"=>"fresh", "volume"=>"", "temperature"=>"", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `year_built`, `habitat_id`) VALUES ('', '', 'fresh', 2017, 1)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (1.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (18.5ms)
  Rendered tanks/new.html.erb within layouts/application (156.1ms)
Completed 200 OK in 1301ms (Views: 1265.7ms | ActiveRecord: 9.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-07 15:12:39 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"iwB50CjMO2MuXrYpnVhrLypeiQKPDRq/cJKyK/AC1ui3kr1Cq1ksAcxSP8Q86HbeZ6tHjLIg/HxPqMMCK2i9KA==", "tank"=>{"tank_id"=>"", "name"=>"a", "description"=>"", "water_type"=>"fresh", "volume"=>"", "temperature"=>"", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (11.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (19.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (20.0ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `year_built`, `habitat_id`) VALUES ('a', '', 'fresh', 2017, 1)[0m
  [1m[35m (32.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (28.0ms)
  Rendered tanks/new.html.erb within layouts/application (430.8ms)
Completed 200 OK in 2056ms (Views: 1818.0ms | ActiveRecord: 84.0ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-07 15:12:43 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"/LseAblBLwlTjxqkLpP0k3t/E0s7j+f3Txvp4Hrt/qbAKdqTOtQ4a7GDk0mPI+liNordxQaiATRwIZjJoYeVZg==", "tank"=>{"tank_id"=>"", "name"=>"a", "description"=>"", "water_type"=>"fresh", "volume"=>"", "temperature"=>"", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `year_built`, `habitat_id`) VALUES ('a', '', 'fresh', 2017, 1)[0m
  [1m[35m (0.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (0.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (10.5ms)
  Rendered tanks/new.html.erb within layouts/application (77.3ms)
Completed 200 OK in 651ms (Views: 633.0ms | ActiveRecord: 5.5ms)


Started POST "/tanks" for 127.0.0.1 at 2017-12-07 15:12:54 -0500
Processing by TanksController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"MjFy9Ilf9tPZIp1iG8VJvvyh4LDOPd44TnK+mw6jgKwOo7ZmCsrhsTsuFI+6dVRPsVQuPvMQOPtxSM+y1cnrbA==", "tank"=>{"tank_id"=>"", "name"=>"a", "description"=>"b", "water_type"=>"fresh", "volume"=>"100", "temperature"=>"", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Create Tank"}
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `tanks` (`name`, `description`, `water_type`, `volume`, `year_built`, `habitat_id`) VALUES ('a', 'b', 'fresh', 100.0, 2017, 1)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/new.html.erb within layouts/application
  [1m[36mHabitat Load (5.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (57.0ms)
  Rendered tanks/new.html.erb within layouts/application (308.7ms)
Completed 200 OK in 1866ms (Views: 1723.9ms | ActiveRecord: 13.5ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-07 15:13:27 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (81.1ms)
Completed 200 OK in 2085ms (Views: 1947.8ms | ActiveRecord: 1.5ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-07 15:13:40 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (31.3ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (1.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (20.6ms)
  Rendered tanks/edit.html.erb within layouts/application (181.7ms)
Completed 200 OK in 1215ms (Views: 966.4ms | ActiveRecord: 32.7ms)


Started GET "/tanks/" for 127.0.0.1 at 2017-12-07 15:14:50 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (1.5ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (63.0ms)
Completed 200 OK in 2245ms (Views: 1863.8ms | ActiveRecord: 1.5ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-07 15:15:06 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (12.5ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (23.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (71.1ms)
  Rendered tanks/edit.html.erb within layouts/application (202.2ms)
Completed 200 OK in 1696ms (Views: 1382.0ms | ActiveRecord: 35.5ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-07 15:16:03 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"j3fMwkX+mshoen5RMDiRGGTuN2o6hXWEN8a9TvvLSH6YD5i96ISpVgNAjg1+AKC6wNxtxYj3Rj6dMTdb9vozwA==", "tank"=>{"tank_id"=>"1", "name"=>"River", "description"=>"Meet the menacing inhabitants of the Amazon River!", "water_type"=>"fresh", "volume"=>"2500.0", "temperature"=>"76.0", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (2.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (5.0ms)[0m  [1m[33mUPDATE `tanks` SET `volume` = 2500.0, `year_built` = 2017 WHERE `tanks`.`tank_id` = 1[0m
  [1m[35m (3.7ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks/1
Completed 302 Found in 47ms (ActiveRecord: 13.7ms)


Started GET "/tanks/1" for 127.0.0.1 at 2017-12-07 15:16:03 -0500
Processing by TanksController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/show.html.erb within layouts/application
  Rendered tanks/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1334ms (Views: 1184.2ms | ActiveRecord: 1.0ms)


Started GET "/tanks/1/edit" for 127.0.0.1 at 2017-12-07 15:16:28 -0500
Processing by TanksController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (30.0ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (131.1ms)
  Rendered tanks/edit.html.erb within layouts/application (358.3ms)
Completed 200 OK in 1449ms (Views: 1141.6ms | ActiveRecord: 31.0ms)


Started PATCH "/tanks/1" for 127.0.0.1 at 2017-12-07 15:16:42 -0500
Processing by TanksController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"UES21hE2QM3F6OPpT857MlSsQN20BaE49YcAJKxSmYJHPOKpvExzU67SE7UB9kqQ8J4acgZ3koJfcIoxoWPiPA==", "tank"=>{"tank_id"=>"1", "name"=>"River", "description"=>"Meet the menacing inhabitants of the Amazon River!", "water_type"=>"fresh", "volume"=>"2400.0", "temperature"=>"76.0", "year_built"=>"2017", "habitat_id"=>"1"}, "commit"=>"Update Tank", "id"=>"1"}
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mHabitat Load (2.0ms)[0m  [1m[34mSELECT  `habitats`.* FROM `habitats` WHERE `habitats`.`habitat_id` = 1 LIMIT 1[0m
  [1m[35mSQL (4.0ms)[0m  [1m[33mUPDATE `tanks` SET `volume` = 2400.0 WHERE `tanks`.`tank_id` = 1[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering tanks/edit.html.erb within layouts/application
  [1m[36mHabitat Load (22.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats` ORDER BY name[0m
  Rendered tanks/_form.html.erb (134.1ms)
  Rendered tanks/edit.html.erb within layouts/application (395.8ms)
Completed 200 OK in 1713ms (Views: 1649.3ms | ActiveRecord: 31.5ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-07 15:16:53 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (2.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (32.0ms)
Completed 200 OK in 1693ms (Views: 1459.1ms | ActiveRecord: 2.0ms)


Started DELETE "/tanks/1" for 127.0.0.1 at 2017-12-07 15:18:06 -0500
Processing by TanksController#destroy as HTML
  Parameters: {"authenticity_token"=>"aGgeNBSrf+Gs5bKRa/aQECw1PJ2TwYJ0LO7/TAt+65ZU+tqmlz5og07pO3zKRo3hYcDyE67sZLcT1I5l0BSAVg==", "id"=>"1"}
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 1 LIMIT 1[0m
  [1m[35m (2.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.0ms)[0m  [1m[31mDELETE FROM `tanks` WHERE `tanks`.`tank_id` = 1[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/tanks
Completed 302 Found in 48ms (ActiveRecord: 21.0ms)


Started GET "/tanks" for 127.0.0.1 at 2017-12-07 15:18:06 -0500
Processing by TanksController#index as HTML
  Rendering tanks/index.html.erb within layouts/application
  [1m[36mTank Load (2.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks`[0m
  Rendered tanks/index.html.erb within layouts/application (57.5ms)
Completed 200 OK in 1483ms (Views: 1330.0ms | ActiveRecord: 2.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-07 15:19:33 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (12.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (231.7ms)
Completed 200 OK in 1823ms (Views: 1614.3ms | ActiveRecord: 38.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 15:20:35 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (6.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (112.7ms)
Completed 200 OK in 1332ms (Views: 1000.1ms | ActiveRecord: 10.0ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-07 15:24:09 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (31.0ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (712.1ms)
Completed 200 OK in 1421ms (Views: 1278.6ms | ActiveRecord: 35.1ms)


Started GET "/feeding_logs/1" for 127.0.0.1 at 2017-12-07 15:26:36 -0500
Processing by FeedingLogsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mFeedingLog Load (34.5ms)[0m  [1m[34mSELECT  `feeding_logs`.* FROM `feeding_logs` WHERE `feeding_logs`.`feeding_id` = 1 LIMIT 1[0m
  Rendering feeding_logs/show.html.erb within layouts/application
  Rendered feeding_logs/show.html.erb within layouts/application (6.5ms)
Completed 200 OK in 1871ms (Views: 1564.4ms | ActiveRecord: 34.5ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-07 15:27:42 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (29.5ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (827.3ms)
Started GET "/feeding_logs/new" for 127.0.0.1 at 2017-12-07 15:27:44 -0500
Processing by FeedingLogsController#new as HTML
Completed 200 OK in 3358ms (Views: 3203.4ms | ActiveRecord: 29.5ms)


  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (9.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (8.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (429.3ms)
  Rendered feeding_logs/new.html.erb within layouts/application (695.5ms)
Completed 200 OK in 2209ms (Views: 1733.3ms | ActiveRecord: 28.0ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-07 15:27:50 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (4.5ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
Started GET "/feeding_logs/new" for 127.0.0.1 at 2017-12-07 15:27:52 -0500
Processing by FeedingLogsController#new as HTML
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (51.0ms)[0m  [1m[35mcall current_employees()[0m
  Rendered feeding_logs/index.html.erb within layouts/application (1615.7ms)
  [1m[36mTank Load (35.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (528.1ms)
  Rendered feeding_logs/new.html.erb within layouts/application (875.5ms)
Completed 200 OK in 4010ms (Views: 3811.8ms | ActiveRecord: 4.5ms)


Completed 200 OK in 2349ms (Views: 2041.0ms | ActiveRecord: 86.1ms)


Started POST "/feeding_logs" for 127.0.0.1 at 2017-12-07 15:30:04 -0500
Processing by FeedingLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"PuiIASmI7UoDG63jAl1e5uqCvkC3SrPi7U3WlX/uqdyGTXzL1UZAGyhYbD/bmOoOlts0JZxhY9WG9KJWN4Ucjg==", "feeding_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"01", "time(5i)"=>"29", "food"=>"sardines", "quantity"=>"15", "employee_id"=>"1", "tank_id"=>"14"}, "commit"=>"Create Feeding log"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEmployee Load (9.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[36mTank Load (1.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 14 LIMIT 1[0m
  [1m[35mSQL (5.5ms)[0m  [1m[32mINSERT INTO `feeding_logs` (`time`, `food`, `quantity`, `employee_id`, `tank_id`) VALUES ('2017-12-01 01:29:00', 'sardines', 15.0, 1, 14)[0m
  [1m[35m (3.5ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/feeding_logs/393
Completed 302 Found in 72ms (ActiveRecord: 20.0ms)


Started GET "/feeding_logs/393" for 127.0.0.1 at 2017-12-07 15:30:04 -0500
Processing by FeedingLogsController#show as HTML
  Parameters: {"id"=>"393"}
  [1m[36mFeedingLog Load (1.0ms)[0m  [1m[34mSELECT  `feeding_logs`.* FROM `feeding_logs` WHERE `feeding_logs`.`feeding_id` = 393 LIMIT 1[0m
  Rendering feeding_logs/show.html.erb within layouts/application
  Rendered feeding_logs/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1587ms (Views: 1388.4ms | ActiveRecord: 1.0ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-07 15:31:36 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (13.8ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (384.5ms)
Completed 200 OK in 1526ms (Views: 1318.5ms | ActiveRecord: 13.8ms)


Started GET "/feeding_logs/new" for 127.0.0.1 at 2017-12-07 15:31:43 -0500
Processing by FeedingLogsController#new as HTML
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (30.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (25.1ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (270.1ms)
  Rendered feeding_logs/new.html.erb within layouts/application (510.5ms)
Completed 200 OK in 1499ms (Views: 1298.1ms | ActiveRecord: 55.1ms)


Started POST "/feeding_logs" for 127.0.0.1 at 2017-12-07 15:31:53 -0500
Processing by FeedingLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"kXTur7UmRLGQHbXiZPO2yYycm6KKI4hsEEBeh0JPDMMp0RplSejp4LtedD69NgIh8MURx6EIWFt7+SpECiS5kQ==", "feeding_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"20", "time(5i)"=>"31", "food"=>"", "quantity"=>"15", "employee_id"=>"1", "tank_id"=>"11"}, "commit"=>"Create Feeding log"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[36mTank Load (3.0ms)[0m  [1m[34mSELECT  `tanks`.* FROM `tanks` WHERE `tanks`.`tank_id` = 11 LIMIT 1[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `feeding_logs` (`time`, `food`, `quantity`, `employee_id`, `tank_id`) VALUES ('2017-12-01 20:31:00', '', 15.0, 1, 11)[0m
  [1m[35m (2.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering feeding_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (23.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mTank Load (27.0ms)[0m  [1m[34mSELECT `tanks`.* FROM `tanks` ORDER BY name[0m
  Rendered feeding_logs/_form.html.erb (381.6ms)
  Rendered feeding_logs/new.html.erb within layouts/application (577.4ms)
Completed 200 OK in 1982ms (Views: 1892.4ms | ActiveRecord: 59.1ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-07 15:32:32 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (33.0ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (572.9ms)
Completed 200 OK in 2275ms (Views: 1916.5ms | ActiveRecord: 33.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 15:33:23 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (13.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (518.9ms)
Completed 200 OK in 1849ms (Views: 1632.1ms | ActiveRecord: 47.0ms)


Started GET "/treatment_logs/1" for 127.0.0.1 at 2017-12-07 15:34:27 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTreatmentLog Load (11.0ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 1 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (5.0ms)
Completed 200 OK in 990ms (Views: 828.6ms | ActiveRecord: 11.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 15:35:25 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (31.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (263.7ms)
Completed 200 OK in 1285ms (Views: 978.6ms | ActiveRecord: 31.0ms)


Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-07 15:35:28 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (29.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (93.0ms)
  Rendered treatment_logs/new.html.erb within layouts/application (328.7ms)
Completed 200 OK in 1650ms (Views: 1379.8ms | ActiveRecord: 30.0ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-07 15:36:51 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"aS5GgOlKXBh29/21A7pY4Z/EaPsuZWRKRb9oWAreyaCfA4eVIsEFhs8wFG4SvJdhBpE47ENEpaPGJxCxeCjeQA==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"20", "time(5i)"=>"35", "medicine"=>"", "quantity"=>"", "employee_id"=>"1", "animal_id"=>"154"}, "commit"=>"Create Treatment log"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (11.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 154 LIMIT 1[0m
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `employee_id`, `animal_id`) VALUES ('2017-12-01 20:35:00', '', 1, 154)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (15.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (9.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (265.2ms)
  Rendered treatment_logs/new.html.erb within layouts/application (629.5ms)
Completed 200 OK in 1935ms (Views: 1847.1ms | ActiveRecord: 41.5ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-07 15:37:11 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"NZhD8xRY1xg927fZeqnQvRuyjTxSJHvtXpfGe4mHBsUJCodhl83Aet/XPjTbGc1MVkdDsm8JnS5hrbdSUu1tBQ==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"01", "time(5i)"=>"29", "medicine"=>"Advil", "quantity"=>"2", "employee_id"=>"1", "animal_id"=>"154"}, "commit"=>"Create Treatment log"}
  [1m[35m (11.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (29.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 154 LIMIT 1[0m
  [1m[36mEmployee Load (27.1ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `quantity`, `employee_id`, `animal_id`) VALUES ('2017-12-01 01:29:00', 'Advil', 2.0, 1, 154)[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/treatment_logs/53
Completed 302 Found in 218ms (ActiveRecord: 74.6ms)


Started GET "/treatment_logs/53" for 127.0.0.1 at 2017-12-07 15:37:12 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"53"}
  [1m[36mTreatmentLog Load (1.5ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 53 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (6.5ms)
Completed 200 OK in 1728ms (Views: 1543.2ms | ActiveRecord: 1.5ms)


Started GET "/treatment_logs/53/edit" for 127.0.0.1 at 2017-12-07 15:37:26 -0500
Processing by TreatmentLogsController#edit as HTML
  Parameters: {"id"=>"53"}
  [1m[36mTreatmentLog Load (1.0ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 53 LIMIT 1[0m
  Rendering treatment_logs/edit.html.erb within layouts/application
  [1m[36mEmployee Load (10.5ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (2.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (126.1ms)
  Rendered treatment_logs/edit.html.erb within layouts/application (495.4ms)
Completed 200 OK in 2131ms (Views: 1945.0ms | ActiveRecord: 14.0ms)


Started GET "/treatment_logs/53" for 127.0.0.1 at 2017-12-07 15:37:33 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"53"}
  [1m[36mTreatmentLog Load (31.0ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 53 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (12.5ms)
Completed 200 OK in 1879ms (Views: 1620.7ms | ActiveRecord: 31.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 15:37:37 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (30.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (420.8ms)
Completed 200 OK in 1375ms (Views: 1172.0ms | ActiveRecord: 30.0ms)


Started GET "/treatment_logs/1" for 127.0.0.1 at 2017-12-07 15:37:40 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTreatmentLog Load (2.0ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 1 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (4.5ms)
Completed 200 OK in 1814ms (Views: 1448.6ms | ActiveRecord: 2.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 15:37:45 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (30.3ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (240.4ms)
Completed 200 OK in 1686ms (Views: 1501.8ms | ActiveRecord: 30.3ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 15:43:04 -0500
  [1m[35m (23.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (2.5ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (24.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (282.1ms)
Completed 200 OK in 2820ms (Views: 2380.0ms | ActiveRecord: 30.0ms)


Started GET "/treatment_logs/1" for 127.0.0.1 at 2017-12-07 15:44:46 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mTreatmentLog Load (7.1ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 1 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (4.0ms)
Completed 200 OK in 1754ms (Views: 1588.6ms | ActiveRecord: 8.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 15:44:50 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (2.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (68.0ms)
Completed 200 OK in 896ms (Views: 798.8ms | ActiveRecord: 2.0ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-07 15:44:54 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (37.0ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (573.4ms)
Completed 200 OK in 2090ms (Views: 1886.9ms | ActiveRecord: 41.5ms)


Started GET "/feeding_logs/1" for 127.0.0.1 at 2017-12-07 15:44:57 -0500
Processing by FeedingLogsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mFeedingLog Load (8.0ms)[0m  [1m[34mSELECT  `feeding_logs`.* FROM `feeding_logs` WHERE `feeding_logs`.`feeding_id` = 1 LIMIT 1[0m
  Rendering feeding_logs/show.html.erb within layouts/application
  Rendered feeding_logs/show.html.erb within layouts/application (10.0ms)
Completed 200 OK in 1912ms (Views: 1717.1ms | ActiveRecord: 8.0ms)


Started GET "/feeding_logs" for 127.0.0.1 at 2017-12-07 15:45:02 -0500
Processing by FeedingLogsController#index as HTML
  Rendering feeding_logs/index.html.erb within layouts/application
  [1m[36mFeedingLog Load (3.5ms)[0m  [1m[34mSELECT `feeding_logs`.* FROM `feeding_logs`[0m
  Rendered feeding_logs/index.html.erb within layouts/application (546.4ms)
Completed 200 OK in 1994ms (Views: 1729.3ms | ActiveRecord: 3.5ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 15:45:06 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (31.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (361.5ms)
Completed 200 OK in 1790ms (Views: 1415.8ms | ActiveRecord: 31.0ms)


Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-07 15:45:12 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (8.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (10.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (374.5ms)
  Rendered treatment_logs/new.html.erb within layouts/application (600.6ms)
Completed 200 OK in 1650ms (Views: 1461.6ms | ActiveRecord: 25.7ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-07 15:45:17 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"zm5YHweDoKSj4iOe8RJMIQmb5AA97hscwYVZKa1R9to4Q5kKzAj5OholykXgFIOhkM60F1DP2vVCHSHA36fhOg==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"20", "time(5i)"=>"45", "medicine"=>"", "quantity"=>"", "employee_id"=>"1", "animal_id"=>"14"}, "commit"=>"Create Treatment log"}
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (9.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 14 LIMIT 1[0m
  [1m[36mEmployee Load (11.5ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `employee_id`, `animal_id`) VALUES ('2017-12-01 20:45:00', '', 1, 14)[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (2.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (10.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (133.7ms)
  Rendered treatment_logs/new.html.erb within layouts/application (422.9ms)
Completed 200 OK in 1576ms (Views: 1232.5ms | ActiveRecord: 37.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-07 15:46:09 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (30.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (453.7ms)
Completed 200 OK in 1541ms (Views: 1312.7ms | ActiveRecord: 69.5ms)


Started GET "/event_registrations/1" for 127.0.0.1 at 2017-12-07 15:47:34 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEventRegistration Load (12.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (14.0ms)
Completed 200 OK in 1774ms (Views: 1342.6ms | ActiveRecord: 12.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-07 15:48:19 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (30.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (198.2ms)
Completed 200 OK in 1816ms (Views: 1645.3ms | ActiveRecord: 30.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-07 15:48:49 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (30.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (6.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (311.3ms)
  Rendered event_registrations/new.html.erb within layouts/application (545.5ms)
Completed 200 OK in 1863ms (Views: 1472.9ms | ActiveRecord: 41.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-07 15:50:10 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"baDnOFfBmgAr9EOc0fpSERL1PQDqMyhP3cHIrNin/Mu0m4RcE3TEvNN6In1sSIR6DFgpnlCiKvBmCiwhWJrzpA==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-07 15:48:50 -0500", "member_id"=>"26", "event_id"=>"1", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (36.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-07 20:48:50', 26, 1, 1)[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/19
Completed 302 Found in 60ms (ActiveRecord: 41.0ms)


Started GET "/event_registrations/19" for 127.0.0.1 at 2017-12-07 15:50:10 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"19"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 19 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (6.5ms)
Completed 200 OK in 2131ms (Views: 1656.3ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-07 15:50:35 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (31.0ms)
Completed 200 OK in 898ms (Views: 753.2ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-07 15:50:42 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (2.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (2.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (33.1ms)
  Rendered event_registrations/new.html.erb within layouts/application (229.3ms)
Completed 200 OK in 1174ms (Views: 996.6ms | ActiveRecord: 4.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-07 15:50:51 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"7IpCazO52wr7J8qUSj9Q23VXguWxO3AlVp1d0oY2qaM1sSEPdwyFtgOpq3X3jYawa/qWewuqcprtVrlfBgumzA==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-07 15:50:43 -0500", "member_id"=>"26", "event_id"=>"5", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-07 20:50:43', 26, 5, 1)[0m
  [1m[35m (33.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/20
Completed 302 Found in 171ms (ActiveRecord: 37.0ms)


Started GET "/event_registrations/20" for 127.0.0.1 at 2017-12-07 15:50:51 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"20"}
  [1m[36mEventRegistration Load (31.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 20 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1441ms (Views: 1177.5ms | ActiveRecord: 31.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-07 15:50:55 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (30.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (88.3ms)
Completed 200 OK in 1024ms (Views: 830.7ms | ActiveRecord: 30.0ms)


Started GET "/event_registrations/new" for 127.0.0.1 at 2017-12-07 15:51:23 -0500
Processing by EventRegistrationsController#new as HTML
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (2.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (2.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (28.0ms)
  Rendered event_registrations/new.html.erb within layouts/application (185.2ms)
Completed 200 OK in 1126ms (Views: 935.0ms | ActiveRecord: 4.0ms)


Started POST "/event_registrations" for 127.0.0.1 at 2017-12-07 15:51:39 -0500
Processing by EventRegistrationsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"UdXyTBf2PaeYUz/LAuXE0PjOaq/Di6q/Ye18cSf4IEyI7pEoU0NjG2DdXiq/VxK75mN+MXkaqADaJpj8p8UvIw==", "event_registration"=>{"registration_code"=>"", "time"=>"2017-12-07 15:51:24 -0500", "member_id"=>"6", "event_id"=>"1", "guest_count"=>"1"}, "commit"=>"Create Event registration"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (4.0ms)[0m  [1m[32mINSERT INTO `event_registrations` (`time`, `member_id`, `event_id`, `guest_count`) VALUES ('2017-12-07 20:51:24', 6, 1, 1)[0m
  [1m[35m (1.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/new.html.erb within layouts/application
  [1m[36mMember Load (25.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (212.7ms)
  Rendered event_registrations/new.html.erb within layouts/application (409.9ms)
Completed 200 OK in 1779ms (Views: 1549.8ms | ActiveRecord: 32.5ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-07 15:52:54 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (28.0ms)
Completed 200 OK in 1541ms (Views: 1174.8ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations/1/edit" for 127.0.0.1 at 2017-12-07 15:53:52 -0500
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (3.5ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (2.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (82.1ms)
  Rendered event_registrations/edit.html.erb within layouts/application (536.4ms)
Completed 200 OK in 1877ms (Views: 1734.5ms | ActiveRecord: 6.5ms)


Started PATCH "/event_registrations/1" for 127.0.0.1 at 2017-12-07 15:54:32 -0500
Processing by EventRegistrationsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"ZIEAhhPqLloXITNY7f4u0sVvKuGa+1mlt6ImNyk18i9vGDf716SDgKX7zqXJ/qx1rDn7n004r5nfhal4Z5O5Tw==", "event_registration"=>{"registration_code"=>"1", "time"=>"2017-12-07 15:53:53 -0500", "member_id"=>"8", "event_id"=>"1", "guest_count"=>"3"}, "commit"=>"Update Event registration", "id"=>"1"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[33mUPDATE `event_registrations` SET `time` = '2017-12-07 20:53:53' WHERE `event_registrations`.`registration_code` = 1[0m
  [1m[35m (6.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/1
Completed 302 Found in 31ms (ActiveRecord: 10.0ms)


Started GET "/event_registrations/1" for 127.0.0.1 at 2017-12-07 15:54:32 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (3.0ms)
Completed 200 OK in 905ms (Views: 753.4ms | ActiveRecord: 1.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-07 15:54:37 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (31.1ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (334.1ms)
Completed 200 OK in 1288ms (Views: 1116.5ms | ActiveRecord: 31.1ms)


Started GET "/event_registrations/1/edit" for 127.0.0.1 at 2017-12-07 15:54:41 -0500
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (16.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (1.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (204.2ms)
  Rendered event_registrations/edit.html.erb within layouts/application (375.4ms)
Completed 200 OK in 2001ms (Views: 1397.6ms | ActiveRecord: 18.5ms)


Started PATCH "/event_registrations/1" for 127.0.0.1 at 2017-12-07 15:54:46 -0500
Processing by EventRegistrationsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"iRY+lBF6G9XkAEPjM/fbmkCaRddajoycehgKjzDeXuWCjwnp1TS2D1bavh4X91k9KcyUqY1NeqASP4XAfngVhQ==", "event_registration"=>{"registration_code"=>"1", "time"=>"2017-12-07 15:54:43 -0500", "member_id"=>"8", "event_id"=>"1", "guest_count"=>"2"}, "commit"=>"Update Event registration", "id"=>"1"}
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (3.0ms)[0m  [1m[33mUPDATE `event_registrations` SET `time` = '2017-12-07 20:54:43', `guest_count` = 2 WHERE `event_registrations`.`registration_code` = 1[0m
  [1m[35m (13.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations/1
Completed 302 Found in 340ms (ActiveRecord: 19.0ms)


Started GET "/event_registrations/1" for 127.0.0.1 at 2017-12-07 15:54:46 -0500
Processing by EventRegistrationsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEventRegistration Load (2.5ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  Rendering event_registrations/show.html.erb within layouts/application
  Rendered event_registrations/show.html.erb within layouts/application (4.0ms)
Completed 200 OK in 1044ms (Views: 820.7ms | ActiveRecord: 2.5ms)


Started GET "/event_registrations/1/edit" for 127.0.0.1 at 2017-12-07 15:56:04 -0500
Processing by EventRegistrationsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEventRegistration Load (1.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (2.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (2.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (31.0ms)
  Rendered event_registrations/edit.html.erb within layouts/application (198.2ms)
Completed 200 OK in 1547ms (Views: 1411.4ms | ActiveRecord: 5.0ms)


Started PATCH "/event_registrations/1" for 127.0.0.1 at 2017-12-07 15:56:12 -0500
Processing by EventRegistrationsController#update as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"Ukx0CWRetYAWTFnQnN1f8sNP+FkLqZN3b9u4HQmW7q1Z1UN0oBAYWqSWpC243d1VqhkpJ9xqZUsH/DdSRzClzQ==", "event_registration"=>{"registration_code"=>"1", "time"=>"2017-12-07 15:56:05 -0500", "member_id"=>"8", "event_id"=>"10", "guest_count"=>"2"}, "commit"=>"Update Event registration", "id"=>"1"}
  [1m[36mEventRegistration Load (2.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[33mUPDATE `event_registrations` SET `time` = '2017-12-07 20:56:05', `event_id` = 10 WHERE `event_registrations`.`registration_code` = 1[0m
  [1m[35m (1.0ms)[0m  [1m[31mROLLBACK[0m
  Rendering event_registrations/edit.html.erb within layouts/application
  [1m[36mMember Load (2.0ms)[0m  [1m[35mcall current_members()[0m
  [1m[36mEvent Load (2.0ms)[0m  [1m[35mcall upcoming_events()[0m
  Rendered event_registrations/_form.html.erb (37.0ms)
  Rendered event_registrations/edit.html.erb within layouts/application (206.1ms)
Completed 200 OK in 1295ms (Views: 1264.3ms | ActiveRecord: 10.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-07 15:56:35 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (31.0ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (182.0ms)
Completed 200 OK in 1771ms (Views: 1609.8ms | ActiveRecord: 31.0ms)


Started DELETE "/event_registrations/1" for 127.0.0.1 at 2017-12-07 15:57:17 -0500
Processing by EventRegistrationsController#destroy as HTML
  Parameters: {"authenticity_token"=>"4TZnSYi4jzgEAk/OPJLP51Mev7PRewativEL2zSSiDvdpKPbCy2YWuYOxiOdItIWHutxPexW4G61y3ry7/jj+w==", "id"=>"1"}
  [1m[36mEventRegistration Load (3.0ms)[0m  [1m[34mSELECT  `event_registrations`.* FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[31mDELETE FROM `event_registrations` WHERE `event_registrations`.`registration_code` = 1[0m
  [1m[35m (35.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/event_registrations
Completed 302 Found in 94ms (ActiveRecord: 41.0ms)


Started GET "/event_registrations" for 127.0.0.1 at 2017-12-07 15:57:17 -0500
Processing by EventRegistrationsController#index as HTML
  Rendering event_registrations/index.html.erb within layouts/application
  [1m[36mEventRegistration Load (1.5ms)[0m  [1m[34mSELECT `event_registrations`.* FROM `event_registrations`[0m
  Rendered event_registrations/index.html.erb within layouts/application (56.5ms)
Completed 200 OK in 1809ms (Views: 1428.0ms | ActiveRecord: 1.5ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-07 16:00:11 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (30.0ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (185.3ms)
Completed 200 OK in 1605ms (Views: 1408.7ms | ActiveRecord: 30.0ms)


Started DELETE "/employees/1" for 127.0.0.1 at 2017-12-07 16:00:16 -0500
Processing by EmployeesController#destroy as HTML
  Parameters: {"authenticity_token"=>"KoCnzyNWg2Yr/qMqWXngTrlBVD31Q54RFxHEiiLXfocWEmNdoMOUBMnyKsf4yf2/9LSas8hueNIoK7Wj+b0VRw==", "id"=>"1"}
  [1m[36mEmployee Load (2.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[33mUPDATE `employees` SET `fired_date` = '2017-12-07' WHERE `employees`.`employee_id` = 1[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/employees
Completed 302 Found in 33ms (ActiveRecord: 11.0ms)


Started GET "/employees" for 127.0.0.1 at 2017-12-07 16:00:16 -0500
Processing by EmployeesController#index as HTML
  Rendering employees/index.html.erb within layouts/application
  [1m[36mEmployee Load (1.5ms)[0m  [1m[34mSELECT `employees`.* FROM `employees`[0m
  Rendered employees/index.html.erb within layouts/application (16.5ms)
Completed 200 OK in 875ms (Views: 733.6ms | ActiveRecord: 1.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-07 16:00:22 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (1.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (24.0ms)
Completed 200 OK in 875ms (Views: 709.5ms | ActiveRecord: 1.0ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-07 16:00:25 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[36mEvent Load (28.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  [1m[36mEmployee Load (1.0ms)[0m  [1m[35mcall current_employees()[0m
  Rendered events/_form.html.erb (50.1ms)
  Rendered events/edit.html.erb within layouts/application (226.7ms)
Completed 200 OK in 1612ms (Views: 1248.3ms | ActiveRecord: 29.5ms)


Started GET "/events/" for 127.0.0.1 at 2017-12-07 16:01:58 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (2.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (25.0ms)
Completed 200 OK in 1094ms (Views: 945.4ms | ActiveRecord: 2.0ms)


Started GET "/events/new" for 127.0.0.1 at 2017-12-07 16:02:01 -0500
Processing by EventsController#new as HTML
  Rendering events/new.html.erb within layouts/application
  [1m[36mEmployee Load (13.0ms)[0m  [1m[35mcall current_employees()[0m
  Rendered events/_form.html.erb (66.5ms)
  Rendered events/new.html.erb within layouts/application (329.2ms)
Completed 200 OK in 2579ms (Views: 2288.7ms | ActiveRecord: 13.0ms)


Started GET "/habitats" for 127.0.0.1 at 2017-12-07 16:07:37 -0500
Processing by HabitatsController#index as HTML
  Rendering habitats/index.html.erb within layouts/application
  [1m[36mHabitat Load (27.5ms)[0m  [1m[34mSELECT `habitats`.* FROM `habitats`[0m
  Rendered habitats/index.html.erb within layouts/application (124.1ms)
Completed 200 OK in 1853ms (Views: 1581.0ms | ActiveRecord: 42.5ms)


  [1m[35m (25.7ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (271.4ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (68.4ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (53.7ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (102.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (107.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (94.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (72.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (113.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (106.6ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        animal_id int(11) NOT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (89.1ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (107.1ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (77.1ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (4.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (7.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (5.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (3.5ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (50.5ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (41.0ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (6.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (31.5ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (46.0ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (40.0ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (46.5ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (8.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (35.0ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (1.5ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (33.0ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (30.0ms)[0m  [1m[35mCREATE TRIGGER add_habitat
BEFORE INSERT ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  END IF;
end;
[0m
  [1m[35m (2.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (9.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (52.0ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (61.0ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (30.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (30.6ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (30.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (8.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (1.5ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (36.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (28.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (10.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (22.1ms)[0m  [1m[35mCREATE TRIGGER add_treatment
BEFORE INSERT ON treatment_logs
  FOR EACH ROW
BEGIN
  IF New.medicine = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a medicine';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity < 0 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';   
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (9.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTanks (20171206162319)
  [1m[35m (24.0ms)[0m  [1m[35m
CREATE TRIGGER update_tank
BEFORE UPDATE ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  ELSEIF New.volume < Old.volume THEN
    SIGNAL SQLSTATE 'HY000'
    	SET MESSAGE_TEXT = 'Cannot shrink a tank.';
  END IF;

end;

[0m
  [1m[35m (29.4ms)[0m  [1m[35m
CREATE TRIGGER add_tank
BEFORE INSERT ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  END IF;

end;

[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.8ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171206162319')[0m
  [1m[35m (10.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-07 21:25:07', '2017-12-07 21:25:07')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events" for 127.0.0.1 at 2017-12-07 16:28:58 -0500
  [1m[35m (23.5ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  
ActiveRecord::PendingMigrationError (

Migrations are pending. To resolve this issue, run:

        bin/rails db:migrate RAILS_ENV=development

):
  
activerecord (5.1.4) lib/active_record/migration.rb:576:in `check_pending!'
activerecord (5.1.4) lib/active_record/migration.rb:553:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:26:in `block in call'
activesupport (5.1.4) lib/active_support/callbacks.rb:97:in `run_callbacks'
actionpack (5.1.4) lib/action_dispatch/middleware/callbacks.rb:24:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/debug_exceptions.rb:59:in `call'
web-console (3.5.1) lib/web_console/middleware.rb:135:in `call_app'
web-console (3.5.1) lib/web_console/middleware.rb:28:in `block in call'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `catch'
web-console (3.5.1) lib/web_console/middleware.rb:18:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/show_exceptions.rb:31:in `call'
railties (5.1.4) lib/rails/rack/logger.rb:36:in `call_app'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `block in call'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `block in tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:26:in `tagged'
activesupport (5.1.4) lib/active_support/tagged_logging.rb:69:in `tagged'
railties (5.1.4) lib/rails/rack/logger.rb:24:in `call'
sprockets-rails (3.2.1) lib/sprockets/rails/quiet_assets.rb:13:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/remote_ip.rb:79:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/request_id.rb:25:in `call'
rack (2.0.3) lib/rack/method_override.rb:22:in `call'
rack (2.0.3) lib/rack/runtime.rb:22:in `call'
activesupport (5.1.4) lib/active_support/cache/strategy/local_cache_middleware.rb:27:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/executor.rb:12:in `call'
actionpack (5.1.4) lib/action_dispatch/middleware/static.rb:125:in `call'
rack (2.0.3) lib/rack/sendfile.rb:111:in `call'
railties (5.1.4) lib/rails/engine.rb:522:in `call'
puma (3.10.0) lib/puma/configuration.rb:225:in `call'
puma (3.10.0) lib/puma/server.rb:605:in `handle_request'
puma (3.10.0) lib/puma/server.rb:437:in `process_client'
puma (3.10.0) lib/puma/server.rb:301:in `block in run'
puma (3.10.0) lib/puma/thread_pool.rb:120:in `block in spawn_thread'
  [1m[35m (27.7ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (366.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_development`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS `aquarium_tycoon_test`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (8.5ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_development` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (1.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (5.4ms)[0m  [1m[35mCREATE DATABASE `aquarium_tycoon_test` DEFAULT CHARACTER SET `utf8`[0m
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (79.5ms)[0m  [1m[35mCREATE TABLE `schema_migrations` (`version` varchar(255) NOT NULL PRIMARY KEY) ENGINE=InnoDB[0m
  [1m[35m (62.9ms)[0m  [1m[35mCREATE TABLE `ar_internal_metadata` (`key` varchar(255) NOT NULL PRIMARY KEY, `value` varchar(255), `created_at` datetime NOT NULL, `updated_at` datetime NOT NULL) ENGINE=InnoDB[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT GET_LOCK(721477603616571690, 0)[0m
  [1m[35m (7.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Migrating to CreateDatabase (20171123010118)
  [1m[35m (91.1ms)[0m  [1m[35m      CREATE TABLE `habitats` (
        `habitat_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `year_added` int(11) NOT NULL,
 CHECK (year_added <= YEAR(CURDATE)),
        PRIMARY KEY (`habitat_id`) 

      );
[0m
  [1m[35m (91.1ms)[0m  [1m[35m      CREATE TABLE `tanks` (
        `tank_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) NOT NULL,
        `description` varchar(200) DEFAULT NULL,
        `water_type` enum('fresh','salt') NOT NULL,
        `volume` double NOT NULL,
        `temperature` double NOT NULL,
        `year_built` int(11) NOT NULL,
        `habitat_id` int(11) NOT NULL,
        PRIMARY KEY (`tank_id`),
        CONSTRAINT `fk_habitat_tank` FOREIGN KEY (`habitat_id`) REFERENCES `habitats` (`habitat_id`) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_temp CHECK (temperature < 100 AND temperautre > 0)      
);
[0m
  [1m[35m (78.1ms)[0m  [1m[35m      CREATE TABLE `animals` (
        `animal_id` int(11) NOT NULL AUTO_INCREMENT,
        `name` varchar(45) DEFAULT NULL,
        `species` varchar(45) NOT NULL,
        `tank_id` int(11) NOT NULL,
        birth_date datetime DEFAULT NULL,
        PRIMARY KEY (animal_id),
        CONSTRAINT fk_tank_animal FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT valid_bday CHECK (birth_date <= CURDATE())
      );
[0m
  [1m[35m (78.1ms)[0m  [1m[35m      CREATE TABLE employees (
        employee_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        hired_date date NOT NULL,
        fired_date date NULL,
        salary double NOT NULL,
        PRIMARY KEY (employee_id),
	CONSTRAINT valid_sal CHECK (salary >= 40000)
      );
[0m
  [1m[35m (102.1ms)[0m  [1m[35m      CREATE TABLE feeding_logs (
        feeding_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        food varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        tank_id int(11) DEFAULT NULL,
        PRIMARY KEY (feeding_id),
        CONSTRAINT fk_tank_feeding FOREIGN KEY (tank_id) REFERENCES tanks(tank_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
        CONSTRAINT fk_employee_feeding FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (112.1ms)[0m  [1m[35m      CREATE TABLE treatment_logs (
        treatment_id int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        medicine varchar(45) NOT NULL,
        quantity float NOT NULL,
        employee_id int(11) NOT NULL,
        animal_id int(11) NOT NULL,
        PRIMARY KEY (treatment_id),
        CONSTRAINT fk_animal_treatment FOREIGN KEY (animal_id) REFERENCES animals(animal_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_employee_treatment FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (76.2ms)[0m  [1m[35m      CREATE TABLE events (
        event_id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(45) NOT NULL,
        description varchar(200),
        price float NOT NULL,
        managing_employee int(11) NOT NULL,
        max_guests_per_person int(11) DEFAULT NULL,
        max_attending int(11) NOT NULL,
        event_date datetime NOT NULL,
        PRIMARY KEY (event_id),
        KEY manager (managing_employee),
        CONSTRAINT fk_employee_events FOREIGN KEY (managing_employee) REFERENCES employees(employee_id) ON UPDATE CASCADE,
  	CONSTRAINT valid_guest_limit CHECK (max_guests_per_person <= max_attending)	
);
[0m
  [1m[35m (71.3ms)[0m  [1m[35m      CREATE TABLE members (
        member_id int(11) NOT NULL AUTO_INCREMENT,
        first_name varchar(45) NOT NULL,
        last_name varchar(45) NOT NULL,
        date_joined date NOT NULL,
        expiration_date date NOT NULL,
        fee double NOT NULL,
        PRIMARY KEY (member_id)
      );
[0m
  [1m[35m (86.3ms)[0m  [1m[35m      CREATE TABLE event_registrations (
        registration_code int(11) NOT NULL AUTO_INCREMENT,
        time datetime NOT NULL,
        member_id int(11) NOT NULL,
        event_id int(11) NOT NULL,
        guest_count int(11) DEFAULT NULL,
        PRIMARY KEY (registration_code),
        KEY eventRegistered (event_id),
        KEY memberRegistering (member_id),
        CONSTRAINT fk_event_registration FOREIGN KEY (event_id) REFERENCES events(event_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
        CONSTRAINT fk_member_registration FOREIGN KEY (member_id) REFERENCES members(member_id)
        ON DELETE CASCADE ON UPDATE CASCADE
      );
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171123010118')[0m
  [1m[35m (3.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToAnimals (20171124173109)
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE all_animals()
      BEGIN
        SELECT * FROM animals;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_species
      (
        species_name VARCHAR(45)
      )
      BEGIN
        SELECT * FROM animals
        WHERE species = species_name;
      END;
[0m
  [1m[35m (1.9ms)[0m  [1m[35m      CREATE PROCEDURE get_by_name
      (
        animal_name VARCHAR(45)
      )
      BEGIN
        select * from animals
          where name = animal_name;
      END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_name
      (
        tank_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, animals.tank, birth_date
        FROM animals
        JOIN tanks ON animals.tank = tanks.tank_id
        WHERE tanks.name = tank_name;
      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_tank_id
      (
        tank_id integer
      )
      BEGIN
        SELECT *
        FROM animals
        WHERE tank = tank_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_habitat
      (
        habitat_name VARCHAR(45)
      )
      BEGIN
        SELECT animal_id, animals.name, species, tank, birth_date
        FROM animals
        JOIN tanks on animals.tank = tanks.tank_id
        JOIN habitats on tanks.habitat_id = habitats.habitat_id
        WHERE habitats.name = habitat_name;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_by_birthday
      (
        birthday dateTime
      )
      BEGIN
        SELECT *
          FROM animals
          WHERE birth_date = birthday;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE create_animal
      (
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        INSERT INTO animals
        (name, species, tank, birth_date)
        VALUES
        (a_name, a_species, t_id, birthday);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE update_animal
      (
        a_id int(11),
        a_name varchar(45),
        a_species varchar(45),
        t_id int(11),
        birthday dateTime
      )
      BEGIN
        UPDATE animals
         SET name = IFNULL(a_name, name),
             species    = IFNULL(a_species, species),
             tank   = IFNULL(t_id, tank),
             birthDate = IFNULL(birthday, birth_date)
       WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE delete_animal
      (
        a_id int(11)
      )
      BEGIN
        DELETE from animals
          WHERE animal_id = a_id;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m      CREATE PROCEDURE get_animal
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      BEGIN
        SELECT * FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE FUNCTION get_animal_count
      (
        aID int(11),
        aname varchar(45),
        aspecies varchar(45),
        tID int(11),
        birthday dateTime
      )
      RETURNS INT
      BEGIN
        DECLARE numAnimals INT;
    
        SELECT count(*) 
        INTO numAnimals 
        FROM animals
        where (animalID = aID OR aID IS NULL) AND
        (aname = name OR aname IS NULL) AND
        (aspecies = species OR aspecies IS NULL) AND
        ( tID = tank OR tID is NULL) AND 
        (birthday = birthDate OR birthday IS NULL);
    
        RETURN numAnimals;
      END;
[0m
  [1m[35m (42.2ms)[0m  [1m[35m
CREATE TRIGGER update_animal
BEFORE UPDATE ON animals
  FOR EACH ROW
BEGIN
  IF New.species != Old.species THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Cannot change species';
  ELSEIF New.birth_date != Old.birth_date THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot change birthday';  
  END IF;
END;
[0m
  [1m[35m (37.9ms)[0m  [1m[35m
CREATE TRIGGER add_animal
BEFORE INSERT ON animals
  FOR EACH ROW
BEGIN
  IF New.species = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a species';
  ELSEIF New.birth_date > CURDATE() THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Can only add animals that have already been born.';  
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171124173109')[0m
  [1m[35m (17.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEmployees (20171125123314)
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE PROCEDURE get_employee
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  BEGIN
    SELECT * FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m  CREATE FUNCTION get_employee_count
  (
    eID int(11),
      fName varchar(45),
      lName varchar(45),
      hired varChar(45),
      eSalary double
  )
  RETURNS INT
  BEGIN
    DECLARE numEmployees INT;

    SELECT count(*)
      INTO numEmployees
      FROM employees
      where (eID = employee_id OR eID IS NULL) AND
      (fname = first_name OR fName IS NULL) AND
    (lName = last_name OR lName IS NULL) AND
     ( hired = hired_date OR hired is NULL) AND
      (eSalary = salary OR eSalary IS NULL);

      RETURN numEmployees;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE FUNCTION events_managed (emp int)
RETURNS int(11)
RETURN (SELECT COUNT(*) FROM events where emp = managing_employee AND events.event_date >= CURDATE());
[0m
  [1m[35m (28.6ms)[0m  [1m[35mCREATE TRIGGER update_employee
 BEFORE UPDATE ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.fired_date IS NOT NULL AND Old.fired_date IS NOT NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Cannot refire this employee';
  ELSEIF New.fired_date IS NOT NULL AND events_managed(New.employee_id) > 0 THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Cannot fire this employee until all events under their management are transferred to another employee';
  END IF;
  END;

[0m
  [1m[35m (29.7ms)[0m  [1m[35mCREATE TRIGGER add_employee
 BEFORE INSERT ON employees
  FOR EACH ROW
BEGIN
  IF New.salary < 40000 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = '$40,000.00 Is the minimum salary';
  ELSEIF New.first_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert first name';
  ELSEIF New.last_name = '' THEN
	SIGNAL SQLSTATE 'HY000'
		SET MESSAGE_TEXT = 'Must insert last name';
  END IF;
  END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE PROCEDURE current_employees()
BEGIN
SELECT * FROM employees WHERE fired_date IS NULL ORDER BY last_name;
END;


[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (7.1ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123314')[0m
  [1m[35m (4.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEvents (20171125123353)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Create an Event
    -- ------------------------------------------
    CREATE PROCEDURE createEvent(eventName VARCHAR(45), eventDescription VARCHAR(45), price float, manager int, guestsPerPerson int, maxGuests int, eventStart datetime)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Events (title, description, price, managing_employee, max_guests_per_person, max_attending, event_date)
      VALUES (eventName , eventDescription, price, manager, guestsPerPerson, maxGuests, eventStart);
    SELECT CONCAT('new event "', eventName, '" was inserted.') AS 'result';

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventName, '" was not inserted') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all events
    -- ------------------------------------------
    CREATE PROCEDURE viewEvents()
    BEGIN

    SELECT * FROM events
      ORDER BY event_date DESC;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events managed by a given employee
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByManager(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM events where managing_employee = ID);

    SELECT * FROM events
      WHERE ID = Managingemployee
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not have any upcoming events.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events within a given price range
    -- --------------------------------------------

    CREATE PROCEDURE viewEventsByPrice(low float, high float)
    BEGIN

    SELECT * FROM events
      WHERE price >= low AND price <=high
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- View all events for a given month and year
    -- --------------------------------------------
    CREATE PROCEDURE viewEventsByDate(Eyear int, Emonth int)
    BEGIN

    SELECT * FROM events
      WHERE MONTH(event_date) = Emonth AND YEAR(event_date) = Eyear
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event title
    -- --------------------------------------------

    CREATE PROCEDURE updateEventTitle(eventNo int, newTitle varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET title = newTitle WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s title updated to ', newTitle) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.5ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event description
    -- --------------------------------------------

    CREATE PROCEDURE updateEventDescription(eventNo int, newDescription varchar(45))
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);

    UPDATE events
    SET description = newDescription WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, '''s description updated to ', newDescription) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.1ms)[0m  [1m[35m
    -- --------------------------------------------
    -- Update event manager
    -- --------------------------------------------

   CREATE PROCEDURE updateEventManager(eventNo int, newManager int)
    BEGIN
    DECLARE eventExist INT DEFAULT 0;
    DECLARE employeeExist INT DEFAULT 0;
    SET eventExist = (SELECT COUNT(*) FROM events WHERE eventNo = event_ID);
    SET employeeExist = (SELECT COUNT(*) FROM employees WHERE newManager = employeeID);

    UPDATE events
    SET managing_employee = newManager WHERE eventNo = event_ID;

    IF eventExist = 0 THEN
      SELECT CONCAT('Event ', eventNo, ' does not exist') as 'result';
    ELSEIF employeeExist = 0 THEN
      SELECT CONCAT('Employee ', newManger, ' does not exist. Pick a different manager') as 'result';
    ELSEIF eventExist = 1 THEN
      SELECT CONCAT('Event ', eventNo, 'is now managed by employee', newManager) as 'result';
    END IF;
    END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- Delete an event
    -- --------------------------------------------
    CREATE PROCEDURE deleteEvent(eventNo int)
    BEGIN

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

    DELETE FROM EVENTS WHERE event_ID = eventNo;

    END;

      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Event "', eventNo, '" was not deleted') AS 'result';
      ELSE
      SELECT CONCAT('Event "', eventNo, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    CREATE PROCEDURE get_event
    (
        eID int(11),
        eTitle varchar(45),
        eDescription varchar(200),
        ePrice float,
        eManager int(11),
        maxGuests int(11),
        maxAttend int(11),
        eDate dateTime
    )
    BEGIN
        SELECT * FROM events
        where (eID = event_ID OR eID IS NULL) AND
        (eTitle = title OR eTitle IS NULL) AND
        (eDescription = description OR eDescription IS NULL) AND
       (ePrice = price OR ePrice is NULL) AND
        (eManager = managing_employee OR eManager IS NULL) AND
        (maxGuests = max_guests_per_person OR maxGuests is NULL) AND
        ( maxAttend = max_attending OR maxAttend is NULL) AND
        (eDate = event_date OR eDate is NULL);
    END;
[0m
  [1m[35m (37.1ms)[0m  [1m[35m-- -----------------------------------------
-- Update event trigger
-- -----------------------------------------
CREATE TRIGGER invalid_event_update
 BEFORE UPDATE ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.event_date < Old.event_date THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only move an event to a later date';
  ELSEIF New.max_attending < Old.max_attending THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Can only increase the max number of guests';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) =DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (39.0ms)[0m  [1m[35m-- --------------------------------------------------
-- insert event trigger
-- --------------------------------------------------
CREATE TRIGGER invalid_event_insert
 BEFORE INSERT ON events
  FOR EACH ROW
BEGIN
  IF New.managing_employee NOT IN (SELECT employee_id FROM employees) THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must have a valid managing employee';
  ELSEIF New.event_id IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'An event with the given ID already exists';
  ELSEIF New.title = '' THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have an event title';
  ELSEIF 0 < (SELECT COUNT(*) FROM events WHERE event_id != New.event_id AND DATE(event_date) = DATE(New.event_date)) THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There is already an event scheduled for that date';
  ELSEIF 0 > New.max_guests_per_person THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Max guests per person must be at least 0';
  ELSEIF New.price < 0 THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Must have price listed of at least 0';
  ELSEIF DATE(New.event_date) <= CURDATE() THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Event must take place after today';
  ELSEIF New.max_attending <= New.max_guests_per_person THEN
   SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Capacity of event must be greater than the number of guests per person';
  END IF;
  END;

[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE PROCEDURE upcoming_events()
BEGIN
SELECT * FROM events WHERE event_date >= CURDATE() ORDER BY event_date asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123353')[0m
  [1m[35m (3.6ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToFeedingLogs (20171125123432)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- Log a feeding
    -- ------------------------------------------
    CREATE PROCEDURE logFeeding(
    tank_IDID varchar(45), employee_IDID int, foodGiven varchar(45), quantityGiven double)

    BEGIN
    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO feeding_logs (time, food, quantity, employee_ID, tank_ID) VALUES (NOW(), foodGiven, quantityGiven, employee_IDID, tank_IDID);
    SELECT CONCAT('feeding logged for tank_ID ', tank_IDID) AS 'result';

    END;

    IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Feeding not logged.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings of one tank_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewTankFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = tank_ID);

    SELECT * FROM feeding_logs
      WHERE ID = tank_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Tank "', ID, '" does not exist.') AS 'result';
      END IF;
    END;

[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all feedings by an employee_ID
    -- ------------------------------------------

    CREATE PROCEDURE viewEmployeeFeedings(ID int)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where ID = employee_ID);

    SELECT * FROM feeding_logs
      WHERE ID = employee_ID
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('Employee "', ID, '" does not exist.') AS 'result';
      END IF;
    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- ------------------------------------------
    -- View all feedings on a certain date
    -- ------------------------------------------

    CREATE PROCEDURE viewDateFeedings(feedingDate DATE)
    BEGIN

    DECLARE notFound INT DEFAULT FALSE;

    SET notFound = (SELECT COUNT(*) FROM feeding_logs where DATE(time) = feedingDate);

    SELECT * FROM feeding_logs
      WHERE DATE(time) = feedingDate
        ORDER BY time DESC;


      IF notFound = 0 THEN
        SELECT CONCAT('No feedings on ', feedingDate) AS 'result';
      END IF;
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m  CREATE PROCEDURE get_feeding
  (
    fID int(11),
      fTime datetime,
      fFood varchar(45),
      fQuantity float,
      fEmployee int(11),
      tID int(11)
  )
  BEGIN
    SELECT * FROM feeding_logs
      where (fID = feeding_id OR fID IS NULL) AND
      (fTime = time OR fTime IS NULL) AND
    (fFood = food OR fFood IS NULL) AND
     (fQuantity = quantity OR fQuantity is NULL) AND 
      (fEmployee = employee_ID OR fEmployee IS NULL) AND
      (tID = tank_ID OR tID is NULL);
  END;
[0m
  [1m[35m (33.9ms)[0m  [1m[35m
CREATE TRIGGER add_feeding
BEFORE INSERT ON feeding_logs
  FOR EACH ROW
BEGIN
  IF New.food = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input food type.';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity <= 0 THEN 
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';    
  END IF;

end;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123432')[0m
  [1m[35m (10.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToHabitats (20171125123505)
  [1m[35m (2.0ms)[0m  [1m[35m        CREATE PROCEDURE createHabitat(habitatName VARCHAR(45), habitatDescription VARCHAR(200))
          BEGIN

          -- Habitats must have unique names
          DECLARE duplicateName INT DEFAULT FALSE;
          -- general error handler
          DECLARE sqlError INT DEFAULT FALSE;

          BEGIN
          -- Error handler setups
          DECLARE CONTINUE HANDLER FOR 1062 SET duplicateName = TRUE;
          DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
          INSERT INTO HABITATS (name, description, yearAdded) VALUES (habitatName, habitatDescription, YEAR(CURDATE()));
          SELECT CONCAT('new habitat "', habitatName, '" was inserted.') AS 'result';
          END;

          IF duplicateName = TRUE THEN
            SELECT CONCAT('Habitat "', habitatName, '" was not inserted - there is already a habitat with this name') AS 'result';
          ELSEIF sqlError = TRUE THEN
            SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not inserted') AS 'result';
          END IF;

          END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- --------------------------------------------
    -- delete a habitat by name
    -- --------------------------------------------

    CREATE PROCEDURE deleteHabitat(habitatName VARCHAR(45))
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      BEGIN
      -- Error handler setups
      DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


      -- DELETE HABITAT, DELETE ALL ANIMALS IN IT? **************
      DELETE FROM HABITATS WHERE name = habitatName;

      END;

      IF sqlError = TRUE THEN
        SELECT CONCAT('SQL Error. Habitat "', habitatName, '" was not deleted') AS 'result';
      ELSE
        SELECT CONCAT('Habitat "', habitatName, '" removed.') AS 'result';
      END IF;

    END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view all habitats
    -- -------------------------------------

    CREATE PROCEDURE viewHabitat()
      BEGIN

      -- general error handler
      DECLARE sqlError INT DEFAULT FALSE;

      SELECT * FROM habitats;

      END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- -------------------------------------
    -- view habitat with the given name
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByName(habitatName VARCHAR(45))
      BEGIN

        DECLARE notFound INT DEFAULT FALSE;

        SET notFound = (SELECT COUNT(*) FROM habitats where name = habitatName);

        SELECT * FROM habitats
        WHERE name = habitatName;

        IF notFound = 0 THEN
          SELECT CONCAT('Habitat "', habitatName, '" does not exist.') AS 'result';
        END IF;

      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m
    -- -------------------------------------
    -- view habitat by construction year
    -- -------------------------------------

    CREATE PROCEDURE viewHabitatByYear(constructionYear int)
      BEGIN

      DECLARE notFound INT DEFAULT FALSE;

      SET notFound = (SELECT COUNT(*) FROM habitats where yearAdded = constructionYear);

      SELECT * FROM habitats
        WHERE yearAdded = constructionYear;

      IF notFound = 0 THEN
        SELECT CONCAT('No habitats built in ', constructionYear) AS 'result';
      END IF;

    END;

[0m
  [1m[35m (1.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat name
    -- ------------------------------------------
    CREATE PROCEDURE updateHabitatName(ID int, newName varchar(45))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET name = newName WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s name updated to ', newName) as 'result';
      END IF;
      END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- update habitat description
    -- ------------------------------------------

    CREATE PROCEDURE updateHabitatDescription(ID int, newDescription varchar(200))
      BEGIN
      DECLARE habitatExist INT DEFAULT 0;
      SET habitatExist = (SELECT COUNT(*) FROM habitats WHERE habitatID = ID);

      UPDATE habitats
      SET description = newDescription WHERE habitatID = ID;

      IF habitatExist = 0 THEN
        SELECT CONCAT('Habitat ', ID, ' does not exist') as 'result';
      ELSEIF employeeExist = 1 THEN
        SELECT CONCAT('Habitat ', ID, '''s description updated to ', newDescription) as 'result';
      END IF;
      END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m      CREATE PROCEDURE get_habitats
      (
        hID int(11),
          hName varchar(45),
          hDescription varchar(200),
          hYear int(11)
      )
      BEGIN
        SELECT * FROM habitats
          where (hID = habitatID OR hID IS NULL) AND
          (hName = name OR hName IS NULL) AND
        (hDescription = description OR hDescription IS NULL) AND
         (hYear = yearAdded OR hYear is NULL);
      END;
[0m
  [1m[35m (42.6ms)[0m  [1m[35m
CREATE TRIGGER update_habitat
BEFORE UPDATE ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';    
  END IF;

end;
[0m
  [1m[35m (35.1ms)[0m  [1m[35mCREATE TRIGGER add_habitat
BEFORE INSERT ON habitats
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  END IF;
end;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123505')[0m
  [1m[35m (4.9ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToEventRegistrations (20171125123539)
  [1m[35m (2.0ms)[0m  [1m[35m    -- ---------------------------------------------------
    -- calculate number of members registered for an event
    -- ---------------------------------------------------
    CREATE FUNCTION memsRegistered(eventNo int)
    RETURNS int
    BEGIN
    RETURN (SELECT SUM(guest_count + 1) FROM event_registrations where event_id = eventNo);
    END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all event registrations
        -- -----------------------------------------------------

        CREATE PROCEDURE allRegistrations()
        BEGIN

        SELECT * FROM event_registrations;

        END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified event
        -- -----------------------------------------------------

        CREATE PROCEDURE registrationsForEvent(eventNo int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE event_id = eventNo
            ORDER BY time desc;

        END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m        -- -----------------------------------------------------
        -- View all registrations for a specified member
        -- -----------------------------------------------------
        CREATE PROCEDURE registrationsForMember(memberID int)
        BEGIN

        SELECT * FROM event_registrations
          WHERE member_id = memberID
            ORDER BY time desc;

        END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35m        -- --------------------------------------------
        -- Delete an event registration
        -- --------------------------------------------
        CREATE PROCEDURE deleteRegistration(memNo int, eventNo int)
        BEGIN

        -- general error handler
        DECLARE sqlError INT DEFAULT FALSE;

        BEGIN
        -- Error handler setups
        DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;

        DELETE FROM event_registrations WHERE event_id = eventNo AND member_id = memNo;

        END;

          IF sqlError = TRUE THEN
          SELECT CONCAT('SQL Error. Registration not eleted.') AS 'result';
          ELSE
          SELECT CONCAT('Registration deleted') AS 'result';
          END IF;

        END;
[0m
  [1m[35m (1.5ms)[0m  [1m[35m      CREATE PROCEDURE get_event_registration
      (
        regCode int(11),
          eTime datetime,
          eMember int(11),
          eID int(11),
          guests int(11)
      )
      BEGIN
        SELECT * FROM event_registrations
          where (regCode = registration_code OR regCode IS NULL) AND
          (eTime = time OR eTime IS NULL) AND
        (eMember = member_id OR eMember IS NULL) AND
         ( eID = event_id OR eID is NULL) AND
          (guests = guest_count OR guests IS NULL);
      END;
[0m
  [1m[35m (47.5ms)[0m  [1m[35mCREATE TRIGGER update_registration_guests
 BEFORE UPDATE ON event_registrations
  FOR EACH ROW
BEGIN
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.event_id != Old.event_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register for a different event, cancel this registration and start a new one.';  
 ELSEIF New.member_id != Old.member_id THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'To register a different member, cancel this registration and start a new one.';
 ELSEIF New.guest_count > (SELECT max_guests_per_person FROM events WHERE event_id = New.event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Exceeding guest limit';
  END IF;
  END;
[0m
  [1m[35m (60.6ms)[0m  [1m[35mCREATE TRIGGER add_registration_guests
 BEFORE INSERT ON event_registrations
  FOR EACH ROW
BEGIN
DECLARE maxGuestsTotal INT DEFAULT 0;
DECLARE guestsSoFar INT DEFAULT 0;
DECLARE maxGuest INT DEFAULT 0;

SET maxGuestsTotal = (SELECT max_attending FROM events where event_id = New.event_id);
SET maxGuest = (SELECT max_guests_per_person FROM events where event_id = New.event_id);
SET guestsSoFar = (SELECT SUM(guest_count + 1) FROM event_registrations where event_id= New.event_id);
  IF New.guest_count < 0 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Guest count must be at least 0';
  ELSEIF New.member_id IN (SELECT member_id FROM event_registrations WHERE New.event_id = event_id) THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'This member is already registered for this event';

  ELSEIF New.member_id NOT IN (SELECT member_id from members) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid member';
  ELSEIF New.event_id NOT IN (SELECT event_id from events) THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Not a valid event';
  ELSEIF New.guest_count > maxGuest THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'Number of guests exceeds limit for this event';
  ELSEIF New.guest_count + guestsSoFar > maxGuestsTotal THEN
  SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'There are not enough tickets for you and your guests';
  ELSEIF (SELECT DATE(event_date) FROM events WHERE event_id = New.event_id) > (SELECT DATE(expiration_date) FROM members WHERE member_id = new.member_id) THEN
    SIGNAL SQLSTATE 'HY000'
    SET MESSAGE_TEXT = 'That member must renew their membership in order to attend.';  
  END IF;
END;
[0m
  [1m[35m (27.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123539')[0m
  [1m[35m (31.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToMembers (20171125123613)
  [1m[35m (23.1ms)[0m  [1m[35m    -- ------------------------------------------
    -- Add a new member
    -- ------------------------------------------

    CREATE PROCEDURE addMember(fName varchar(45), lName varchar(45), expirationDate date, feePaid float)
    BEGIN 

    -- general error handler
    DECLARE sqlError INT DEFAULT FALSE;

    BEGIN
    -- Error handler setups
    DECLARE EXIT HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;


    INSERT INTO Members (firstName, lastName, dateJoined, expirationDate, fee) 
      VALUES (fName, lName, CURDATE(), DATE_ADD(curdate(), INTERVAL 18 month), feePaid)  ;
    SELECT CONCAT('new member "', fName, ' ', lastName, '" was inserted.') AS 'result';    

    END; 
      IF sqlError = TRUE THEN
      SELECT CONCAT('SQL Error. Member "', fName, ' ', lastName, '" was not inserted') AS 'result';    
      END IF;

    END;
[0m
  [1m[35m (31.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- View all members
    -- ------------------------------------------

    CREATE PROCEDURE viewMembers()
    BEGIN 

    SELECT * FROM members
      ORDER BY dateJoined DESC;
    END;
[0m
  [1m[35m (27.0ms)[0m  [1m[35m    -- -----------------------------------------------------
    -- View members expiring within the given number of days
    -- -----------------------------------------------------

    CREATE PROCEDURE expiringMembers(days int)
    BEGIN 

    SELECT * FROM events
      WHERE expirationDate <= DATE_ADD(curdate(), INTERVAL days day)
        ORDER BY time DESC;

    END;

[0m
  [1m[35m (12.0ms)[0m  [1m[35m
    -- -----------------------------------------------------
    -- Update member: renew membership
    -- -----------------------------------------------------

    CREATE PROCEDURE renewMember(memID int, Newfee float) 

    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE memID = memberID);

    UPDATE members
    SET expirationDate = DATE_ADD(expirationDate, INTERVAL 18 month), fee = newFee
    WHERE memID = memberID;

    IF memberExist = 0 THEN 
      SELECT CONCAT('Member ', memID, ' does not exist') as 'result';
    ELSEIF memberExist = 1 THEN
      SELECT CONCAT('Member ', memID, ' has renewed their membership.') as 'result';
    END IF;
    END;

[0m
  [1m[35m (6.0ms)[0m  [1m[35m    -- ------------------------------------------
    -- delete member
    -- ------------------------------------------

    CREATE PROCEDURE deleteMember(ID int)
    BEGIN 
    DECLARE memberExist INT DEFAULT 0;
    DECLARE sqlError TINYINT DEFAULT FALSE;

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET sqlError = TRUE;
    SET memberExist = (SELECT COUNT(*) FROM members WHERE ID = memberID);

    DELETE FROM Members WHERE ID = memberID;

    IF sqlError = FALSE and employeeExist = 1 THEN
        SELECT CONCAT('Employee ', ID, ' no longer a member.') as 'result';
    ELSE
      SELECT CONCAT('cannot remove employee ', ID, '.') as 'result';

    END IF;
    END;

[0m
  [1m[35m (7.0ms)[0m  [1m[35m  CREATE PROCEDURE get_member
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  BEGIN
    SELECT * FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
  END;
[0m
  [1m[35m (2.0ms)[0m  [1m[35m  CREATE FUNCTION get_member_count
  (
    memID int(11),
      fName varchar(45),
      lName varchar(45),
      joined date,
      exp date,
      mFee double
  )
  RETURNS INT
  BEGIN
    DECLARE memCount INT;
      
    SELECT count(*)
      INTO memCount
      FROM members
      where (memID = memberID OR memID IS NULL) AND
      (fname = firstName OR fName IS NULL) AND
    (lName = lastName OR lName IS NULL) AND
     ( joined = dateJoined OR joined is NULL) AND 
      ( exp = expirationDate OR exp is NULL) AND
      (mFee = fee OR mFee IS NULL);
      
      RETURN memCount;
  END;
[0m
  [1m[35m (56.0ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Update members
-- -------------------------------------------
CREATE TRIGGER invalid_member_update
 BEFORE UPDATE ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
  ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';    
  END IF;
  END;
[0m
  [1m[35m (48.5ms)[0m  [1m[35m-- ------------------------------------------
-- Trigger Insert members
-- -------------------------------------------
CREATE TRIGGER invalid_member_insert
 BEFORE INSERT ON members
  FOR EACH ROW
BEGIN
  IF New.fee < 100 THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Fee must be greater than $100';
        ELSEIF New.first_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'First name must be input';  
    ELSEIF New.last_name = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Last name must be input';   
  END IF;
  END;
[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE PROCEDURE current_members()
BEGIN
SELECT * FROM members WHERE expiration_date >= CURDATE() ORDER BY last_name asc;
END;
[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123613')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTreatmentLogs (20171125123732)
  [1m[35m (33.5ms)[0m  [1m[35mCREATE TRIGGER add_treatment
BEFORE INSERT ON treatment_logs
  FOR EACH ROW
BEGIN
  IF New.medicine = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a medicine';
  ELSEIF New.quantity IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a quantity';  
  ELSEIF New.quantity < 0 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a valid quantity';   
  END IF;

end;
[0m
  [1m[35m (0.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171125123732')[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Migrating to AddStoredProceduresToTanks (20171206162319)
  [1m[35m (43.9ms)[0m  [1m[35m
CREATE TRIGGER update_tank
BEFORE UPDATE ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  ELSEIF New.volume < Old.volume THEN
    SIGNAL SQLSTATE 'HY000'
    	SET MESSAGE_TEXT = 'Cannot shrink a tank.';
  END IF;

end;

[0m
  [1m[35m (38.2ms)[0m  [1m[35m
CREATE TRIGGER add_tank
BEFORE INSERT ON tanks
  FOR EACH ROW
BEGIN
  IF New.name = '' THEN
    SIGNAL SQLSTATE 'HY000' -- 'HY000' indicates a general error
      SET MESSAGE_TEXT = 'Must input a title';
  ELSEIF New.description = '' THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input a description';  
  ELSEIF New.volume < 500 OR New.Volume > 100000 THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Volume must be between 500 and 100,000 gallons';
  ELSEIF New.volume IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
      SET MESSAGE_TEXT = 'Must input volume';
  ELSEIF New.temperature IS NULL THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Must input a temperature';
  ELSEIF New.temperature < 0 OR New.Temperature > 100 THEN
    SIGNAL SQLSTATE 'HY000'
  	SET MESSAGE_TEXT = 'Temerature must be between 0 and 100';	
  END IF;

end;

[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO `schema_migrations` (`version`) VALUES ('20171206162319')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT  `ar_internal_metadata`.* FROM `ar_internal_metadata` WHERE `ar_internal_metadata`.`key` = 'environment' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.2ms)[0m  [1m[32mINSERT INTO `ar_internal_metadata` (`key`, `value`, `created_at`, `updated_at`) VALUES ('environment', 'development', '2017-12-07 21:30:43', '2017-12-07 21:30:43')[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.0ms)[0m  [1m[34mSELECT RELEASE_LOCK(721477603616571690)[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Started GET "/events" for 127.0.0.1 at 2017-12-07 16:33:06 -0500
  [1m[35m (27.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT `schema_migrations`.`version` FROM `schema_migrations` ORDER BY `schema_migrations`.`version` ASC[0m
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (5.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (74.2ms)
Completed 200 OK in 2539ms (Views: 2439.4ms | ActiveRecord: 13.5ms)


Started GET "/events/1/edit" for 127.0.0.1 at 2017-12-07 16:33:50 -0500
Processing by EventsController#edit as HTML
  Parameters: {"id"=>"1"}
  [1m[35m (2.0ms)[0m  [1m[35mSET NAMES utf8,  @@SESSION.sql_mode = CONCAT(CONCAT(@@sql_mode, ',STRICT_ALL_TABLES'), ',NO_AUTO_VALUE_ON_ZERO'),  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483[0m
  [1m[36mEvent Load (8.5ms)[0m  [1m[34mSELECT  `events`.* FROM `events` WHERE `events`.`event_id` = 1 LIMIT 1[0m
  Rendering events/edit.html.erb within layouts/application
  [1m[36mEmployee Load (9.0ms)[0m  [1m[35mcall current_employees()[0m
  Rendered events/_form.html.erb (488.4ms)
  Rendered events/edit.html.erb within layouts/application (622.6ms)
Completed 200 OK in 1585ms (Views: 1370.7ms | ActiveRecord: 47.5ms)


Started GET "/events" for 127.0.0.1 at 2017-12-07 16:33:53 -0500
Processing by EventsController#index as HTML
  Rendering events/index.html.erb within layouts/application
  [1m[36mEvent Load (20.0ms)[0m  [1m[34mSELECT `events`.* FROM `events`[0m
  Rendered events/index.html.erb within layouts/application (95.1ms)
Completed 200 OK in 542ms (Views: 462.6ms | ActiveRecord: 20.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 16:33:59 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (7.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (60.0ms)
Completed 200 OK in 903ms (Views: 654.5ms | ActiveRecord: 9.0ms)


Started GET "/treatment_logs/1" for 127.0.0.1 at 2017-12-07 16:34:01 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"1"}
  [1m[36mTreatmentLog Load (2.0ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 1 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (7.5ms)
Completed 200 OK in 2228ms (Views: 2011.0ms | ActiveRecord: 2.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 16:34:04 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (5.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (275.7ms)
Started GET "/treatment_logs/new" for 127.0.0.1 at 2017-12-07 16:34:05 -0500
Processing by TreatmentLogsController#new as HTML
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (2.0ms)[0m  [1m[35mcall current_employees()[0m
Completed 200 OK in 1680ms (Views: 1540.1ms | ActiveRecord: 5.0ms)


  [1m[36mAnimal Load (9.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (232.8ms)
  Rendered treatment_logs/new.html.erb within layouts/application (437.1ms)
Completed 200 OK in 1051ms (Views: 929.3ms | ActiveRecord: 14.0ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-07 16:34:11 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"2bjZ7wyHDZ1HgaxqTNZx04DRTobhGI7vuSQsHVULMHQvlRj6xwxUA/5GRbFd0L5TGYQekYw5TwY6vFT0J/0nlA==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"21", "time(5i)"=>"34", "medicine"=>"a2", "quantity"=>"", "employee_id"=>"1", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (5.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (5.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (7.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (5.5ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `employee_id`, `animal_id`) VALUES ('2017-12-01 21:34:00', 'a2', 1, 1)[0m
  [1m[35m (0.5ms)[0m  [1m[31mROLLBACK[0m
  Rendering treatment_logs/new.html.erb within layouts/application
  [1m[36mEmployee Load (27.0ms)[0m  [1m[35mcall current_employees()[0m
  [1m[36mAnimal Load (27.0ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered treatment_logs/_form.html.erb (323.7ms)
  Rendered treatment_logs/new.html.erb within layouts/application (437.4ms)
Completed 200 OK in 1137ms (Views: 960.7ms | ActiveRecord: 77.1ms)


Started POST "/treatment_logs" for 127.0.0.1 at 2017-12-07 16:34:14 -0500
Processing by TreatmentLogsController#create as HTML
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"ZUobDDsJPTKcNp5qYZx4obmbBh0HvREh8WxD3h5AHYBZ2N+euJwqUH46F4fALGVQ9G7IkzqQ9+LOVjL3xSp2QA==", "treatment_log"=>{"time(1i)"=>"2017", "time(2i)"=>"12", "time(3i)"=>"1", "time(4i)"=>"21", "time(5i)"=>"34", "medicine"=>"a2", "quantity"=>"2", "employee_id"=>"1", "animal_id"=>"1"}, "commit"=>"Create Treatment log"}
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mAnimal Load (2.5ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 1 LIMIT 1[0m
  [1m[36mEmployee Load (1.0ms)[0m  [1m[34mSELECT  `employees`.* FROM `employees` WHERE `employees`.`employee_id` = 1 LIMIT 1[0m
  [1m[35mSQL (4.5ms)[0m  [1m[32mINSERT INTO `treatment_logs` (`time`, `medicine`, `quantity`, `employee_id`, `animal_id`) VALUES ('2017-12-01 21:34:00', 'a2', 2.0, 1, 1)[0m
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/treatment_logs/53
Completed 302 Found in 88ms (ActiveRecord: 12.0ms)


Started GET "/treatment_logs/53" for 127.0.0.1 at 2017-12-07 16:34:14 -0500
Processing by TreatmentLogsController#show as HTML
  Parameters: {"id"=>"53"}
  [1m[36mTreatmentLog Load (1.0ms)[0m  [1m[34mSELECT  `treatment_logs`.* FROM `treatment_logs` WHERE `treatment_logs`.`treatment_id` = 53 LIMIT 1[0m
  Rendering treatment_logs/show.html.erb within layouts/application
  Rendered treatment_logs/show.html.erb within layouts/application (7.0ms)
Completed 200 OK in 1418ms (Views: 962.0ms | ActiveRecord: 1.0ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 16:34:17 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (2.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (352.3ms)
Completed 200 OK in 2142ms (Views: 1944.8ms | ActiveRecord: 2.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 16:34:45 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (9.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (187.5ms)
Completed 200 OK in 1327ms (Views: 1106.7ms | ActiveRecord: 9.5ms)


Started DELETE "/animals/109" for 127.0.0.1 at 2017-12-07 16:35:13 -0500
Processing by AnimalsController#destroy as HTML
  Parameters: {"authenticity_token"=>"Q08T+5mr6xPwpoE/6kfvUh4WyxlyIrq9hGQl4TdkdrZ/3ddpGj78cRKqCNJL9/KjU+MFl08PXH67XlTI7A4ddg==", "id"=>"109"}
  [1m[36mAnimal Load (1.0ms)[0m  [1m[34mSELECT  `animals`.* FROM `animals` WHERE `animals`.`animal_id` = 109 LIMIT 1[0m
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (5.0ms)[0m  [1m[31mDELETE FROM `animals` WHERE `animals`.`animal_id` = 109[0m
  [1m[35m (10.0ms)[0m  [1m[35mCOMMIT[0m
Redirected to http://localhost:3000/animals
Completed 302 Found in 31ms (ActiveRecord: 17.0ms)


Started GET "/animals" for 127.0.0.1 at 2017-12-07 16:35:13 -0500
Processing by AnimalsController#index as HTML
  Rendering animals/index.html.erb within layouts/application
  [1m[36mAnimal Load (30.5ms)[0m  [1m[34mSELECT `animals`.* FROM `animals`[0m
  Rendered animals/index.html.erb within layouts/application (391.8ms)
Completed 200 OK in 1224ms (Views: 1089.9ms | ActiveRecord: 30.5ms)


Started GET "/treatment_logs" for 127.0.0.1 at 2017-12-07 16:35:19 -0500
Processing by TreatmentLogsController#index as HTML
  Rendering treatment_logs/index.html.erb within layouts/application
  [1m[36mTreatmentLog Load (1.0ms)[0m  [1m[34mSELECT `treatment_logs`.* FROM `treatment_logs`[0m
  Rendered treatment_logs/index.html.erb within layouts/application (14.9ms)
Completed 200 OK in 910ms (Views: 731.4ms | ActiveRecord: 1.0ms)


